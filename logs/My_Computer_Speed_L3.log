[15-09-2021_15-49-16] DEBUG :: __main__ >> 
  ####################################################################################################################  
                                                                                                                        
                                                ░█████╗░░██████╗██╗░░██╗                                                
                                                ██╔══██╗██╔════╝██║░░██║                                                
                                                ███████║╚█████╗░███████║                                                
                                                ██╔══██║░╚═══██╗██╔══██║                                                
                                                ██║░░██║██████╔╝██║░░██║                                                
                                                ╚═╝░░╚═╝╚═════╝░╚═╝░░╚═╝                                                
                                                                                                                        
                        =======================================================================                         
                            ASH - The ASP based Hierarchical Conformance Refinement Planner                             
                                      Copyright (C)  2021  Oliver Michael Kamperis                                      
                        =======================================================================                         
                                                                                                                        
          This program comes with ABSOLUTELY NO WARRANTY; for details use `--warranty'. This is free software,          
            and you are welcome to redistribute it under certain conditions; use `--conditions' for details.            
                    For help and usage instructions use `--help' and `--instructions' respectively.                     
                                                                                                                        
  ####################################################################################################################  

[15-09-2021_15-49-16] DEBUG :: __main__ >> 
                    ================================================================================                    
                                                                                                                        
                            THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY                            
                         APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT                         
                       HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY                        
                        OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,                        
                         THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR                         
                       PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM                       
                        IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF                        
                                     ALL NECESSARY SERVICING, REPAIR OR CORRECTION.                                     
                                                                                                                        
                    ================================================================================                    

[15-09-2021_15-49-16] DEBUG :: __main__ >> 
                    ================================================================================                    
                                                                                                                        
                            ASH - The ASP based Hierarchical Conformance Refinement Planner                             
                                      Copyright (C)  2021  Oliver Michael Kamperis                                      
                                             Email: o.m.kamperis@gmail.com                                              
                                                                                                                        
                          This program is free software: you can redistribute it and/or modify                          
                          it under the terms of the GNU General Public License as published by                          
                           the Free Software Foundation, either version 3 of the License, or                            
                                                   any later version.                                                   
                                                                                                                        
                            This program is distributed in the hope that it will be useful,                             
                             but WITHOUT ANY WARRANTY; without even the implied warranty of                             
                              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the                              
                                      GNU General Public License for more details.                                      
                                                                                                                        
                           You should have received a copy of the GNU General Public License                            
                         along with this program. If not, see <https://www.gnu.org/licenses/>.                          
                                                                                                                        
                    ================================================================================                    

[15-09-2021_15-49-16] DEBUG :: __main__ >> Command line arguments:
'./test_problems/blocks_world_plus/BWP_system_laws.lp'
'./test_problems/blocks_world_plus/BWP_problem_small_3.lp'
'-m'
'hcr'
'-t'
'sequential'
'-yield'
'True'
'-method'
'ground-first'
'-conc'
'False'
'-min_bound'
'disable'
'-ao'
'standard'
'-dpos'
'-plc'
'False'
'-pic'
'False'
'-strat'
'none'
'-bound'
'3=2'
'2=2'
'1=3'
'-lblend'
'3=0.1'
'2=0.1'
'-rblend'
'3=0.1'
'2=0.1'
'-ll'
'3=50'
'2=100'
'1=150'

[15-09-2021_15-49-16] DEBUG :: __main__ >> Parsed command line argumenys:
('files', ['./test_problems/blocks_world_plus/BWP_system_laws.lp', './test_problems/blocks_world_plus/BWP_problem_small_3.lp'])
('display_loader', None)
('domain_rules', None)
('domain_structure', None)
('problem_specifics', None)
('load_schema', None)
('plan_file', './solutions/plans/ASH_Plan_15-09-2021_15-49-16.txt')
('log_file', './logs/ASH_Log_15-09-2021_15-49-16.log')
('excel_file', None)
('data_file', None)
('data_sep', ' ')
('data_end', '\n')
('make_schema', None)
('warranty', False)
('conditions', False)
('instructions', False)
('ash_output', 'standard')
('clingo_output', False)
('console_logging', 'INFO')
('disable_logging', False)
('disable_pause_on_start', True)
('display_graph', True)
('operation', 'standard')
('experimental_runs', 1)
('initial_runs', 0)
('pause_on_run_completion', False)
('threads', 8)
('planning_time_limit', 3600)
('search_length_limit', {3: 50, 2: 100, 1: 150})
('planning_mode', 'hcr')
('conformance_type', 'sequential')
('enable_concurrency', False)
('minimise_actions', None)
('sequential_yielding', True)
('detect_interleaving', False)
('minimum_search_length_bound', False)
('problem_space_level', 1)
('generate_search_space', False)
('generate_solution_space', False)
('pause_on_level_change', False)
('pause_on_increment_change', False)
('top_level', None)
('bottom_level', 1)
('online_method', 'ground-first')
('division_strategy', 'none')
('division_strategy_bounds', {3: 2, 2: 2, 1: 3})
('left_blend_quantities', {3: 0.1, 2: 0.1})
('right_blend_quantities', {3: 0.1, 2: 0.1})
('treat_tasks_as_independent', True)
('save_grounding', False)
('positive_final_goal_preemptive_achievement_heuristic', None)
('negative_final_goal_preemptive_achievement_heuristic', None)
('final_goal_intermediate_achievement_ordering_preferences', None)
('detect_dependencies', False)

[15-09-2021_15-49-16] DEBUG :: core.Planner >> Instantiating new planning domain:
Name = None
Domain files = [./test_problems/blocks_world_plus/BWP_system_laws.lp
                ./test_problems/blocks_world_plus/BWP_problem_small_3.lp]

[15-09-2021_15-49-16] DEBUG :: core.Planner >> The domain files ['./test_problems/blocks_world_plus/BWP_system_laws.lp', './test_problems/blocks_world_plus/BWP_problem_small_3.lp'] were loaded successfully, contain all required program parts, and contain optional program parts: {'initial_state': True, 'static_state': True, 'entities': True, 'goal_state': True}.

[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Instantiating logic program...

[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Setting input storing variables:
	solver_options = []
	assumptions = []
	context = None
	incrementor = None
	base_parts = []
	inc_parts = []

[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Output storing variables reset.

[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Logic program instantiated.

[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Entering new one-shot solve call:
('self', LogicProgram(#program base.
#program abstraction_levels(planning_level, mode).
al((1..abstraction_max)).
pl(AL) :- AL = planning_level; al(AL).
sl(AL) :- AL = planning_level; mode = classical; al(AL).
sl(AL) :- AL >= planning_level; AL <= (planning_level+1); mode = refinement; al(AL).
sl(AL) :- AL >= planning_level; AL <= abstraction_max; mode = hierarchical; al(AL).
#program instance_module.
boolean(true;false).
insta_of(AL,CLS,EN) :- entity(CLS,EN); class(AL,CLS); al(AL).
insta_of(AL_3,CLS_1,EN) :- insta_of(AL_2,CLS_2,EN); super_class(CLS_1,CLS_2); entity(CLS_3,EN); class(AL_3,CLS_3); class(AL_1,CLS_1); AL_1 >= AL_2; al(AL_1); al(AL_2); al(AL_3).
insta_of((AL-1),CLS,EN) :- insta_of(AL,CLS,EN); not overridden((AL-1),CLS,EN); class(_,CLS); al(AL); al((AL-1)).
overridden((AL-1),CLS,EN_1) :- overridden_by((AL-1),CLS,EN_1,EN_2); insta_of(AL,CLS,EN_1); insta_of((AL-1),CLS,EN_2); class(_,CLS); al(AL); al((AL-1)).
overridden_by((AL-1),CLS_3,EN_1,EN_2) :- insta_of(AL,CLS_1,EN_1); insta_of((AL-1),CLS_2,EN_2); insta_of(AL,CLS_3,EN_1); insta_of((AL-1),CLS_3,EN_2); desce_of((AL-1),EN_1,EN_2); override_class(CLS_1,CLS_2,CLS_3); class(_,CLS_1); class(_,CLS_2); class(_,CLS_3); al(AL); al((AL-1)).
state_of(AL,EN,S) :- state(AL,CLS,S); insta_of(AL,CLS,EN); al(AL).
child_of(AL,EN,DESCE) :- ancestry_relation(EN,DESCE); insta_of(AL,_,EN); insta_of(AL,_,DESCE); al(AL).
desce_of(AL,EN,DESCE) :- child_of(AL,EN,DESCE); insta_of(AL,_,EN); insta_of(AL,_,DESCE); al(AL).
desce_of(AL,EN,DESCE_1) :- desce_of(AL,DESCE_2,DESCE_1); desce_of(AL,EN,DESCE_2); insta_of(AL,_,EN); insta_of(AL,_,DESCE_1); insta_of(AL,_,DESCE_2); al(AL).
has_desce(AL,EN) :- desce_of(AL,EN,DESCE); insta_of(AL,_,EN); insta_of(AL,_,DESCE); al(AL).
has_desce(AL,EN,CLS) :- desce_of(AL,EN,DESCE); insta_of(AL,_,EN); insta_of(AL,CLS,DESCE); al(AL).
siblings(AL,DESCE_1,DESCE_2) :- child_of(AL,EN,DESCE_1); child_of(AL,EN,DESCE_2); DESCE_1 != DESCE_2; insta_of(AL,_,EN); insta_of(AL,_,DESCE_1); insta_of(AL,_,DESCE_2); al(AL).
siblings(AL,DESCE_2,DESCE_1) :- siblings(AL,DESCE_1,DESCE_2); insta_of(AL,_,DESCE_1); insta_of(AL,_,DESCE_2); al(AL).
#program state_module(step, start).
{ holds(AL,F,V,step) } :- fluent(AL,inertial,F,V); sl(AL); step = start.
#false :- not 1 = { holds(AL,F,V,step): fluent(AL,_,F,V) }; fluent(AL,_,F,_); sl(AL).
holds(AL,F,V,step) :- holds(AL,F,V,(step-1)); not not holds(AL,F,V,step); fluent(AL,inertial,F,V); sl(AL); step > start.
holds(AL,F,false,step) :- not holds(AL,F,true,step); fluent(AL,defined,F,B); boolean(B); sl(AL).
#program plan_module(step, start, concurrency, achieve_fgoals).
{ occurs(AL,ROBOT,A,step): action(AL,_,ROBOT,A) } :- incomplete_plan((step-1)); pl(AL); step > start.
occurs(AL,ROBOT,step) :- occurs(AL,ROBOT,A,step); action(AL,_,ROBOT,A); pl(AL); step > start.
occurs(AL,step) :- occurs(AL,ROBOT,step); insta_of(AL,robot,ROBOT); pl(AL); step > start.
holds(AL,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V,step); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
holds(AL,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,true,step); not holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,true); not holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,false,step); holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,false); holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- not 1 = { occurs(AL,R,A,step): action(AL,_,ROBOT,A) }; incomplete_plan((step-1)); pl(AL); step > start; concurrency = false.
#false :- not 1 <= { occurs(AL,R,A,step): action(AL,_,ROBOT,A) }; incomplete_plan((step-1)); pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT,A_1,step); occurs(AL,ROBOT,A_2,step); A_1 != A_2; action(AL,_,ROBOT,A_1); action(AL,_,ROBOT,A_2); pl(AL); step > start; concurrency = false.
#false :- occurs(AL,ROBOT,A_1,step); occurs(AL,ROBOT,A_2,step); A_1 != A_2; action(AL,sequential,ROBOT,A_1); action(AL,_,ROBOT,A_2); pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); effect(AL,ROBOT_2,A_2,F,V_2,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; ROBOT_1 != ROBOT_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); effect(AL,ROBOT_2,A_2,F,V_2); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; ROBOT_1 != ROBOT_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1); effect(AL,ROBOT_2,A_2,F,V_2); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; ROBOT_1 != ROBOT_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); precond(AL,ROBOT_2,A_2,F,V_2,true,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); precond(AL,ROBOT_2,A_2,F,V_2,true); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V,step); precond(AL,ROBOT_2,A_2,F,V,false,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V,step); precond(AL,ROBOT_2,A_2,F,V,false); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1); precond(AL,ROBOT_2,A_2,F,V_2,true,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1); precond(AL,ROBOT_2,A_2,F,V_2,true); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V); precond(AL,ROBOT_2,A_2,F,V,false,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V); precond(AL,ROBOT_2,A_2,F,V,false); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#external seq_achieve_fgoals(step). [false]
enforce_achieve_fgoals(step) :- achieve_fgoals = true.
enforce_achieve_fgoals(step) :- 0 <= S; S <= step; seq_achieve_fgoals(S).
goal_satisfied(AL,F,V,true,step) :- final_goal(AL,F,V,true); holds(AL,F,V,step); fluent(AL,_,F,V); pl(AL); enforce_achieve_fgoals(step).
goal_satisfied(AL,F,V,false,step) :- final_goal(AL,F,V,false); not holds(AL,F,V,step); fluent(AL,_,F,V); pl(AL); enforce_achieve_fgoals(step).
incomplete_plan(step) :- final_goal(AL,F,V,B); not goal_satisfied(AL,F,V,B,step); fluent(AL,_,F,V); pl(AL); boolean(B); enforce_achieve_fgoals(step).
sub_goal(AL,ROBOT,A,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V,step); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); AL != 1; step > start.
sub_goal(AL,ROBOT,A,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); AL != 1; step > start.
#program optimisation_module(step, start, minimise_length, minimise_actions, minimise_cost, preempt_pos_fgoals, preempt_neg_fgoals, order_fgoals_achievement).
:~ occurs(AL,step); incomplete_plan((step-1)); pl(AL); step > start; minimise_length = true. [1@3,step]
:~ occurs(AL,ROBOT,A,step); action(AL,_,ROBOT,A); incomplete_plan((step-1)); pl(AL); step > start; minimise_actions = true. [1@2,ROBOT,A,step]
#heuristic occurs(AL,ROBOT,A,step) : action(AL,_,ROBOT,A); effect(AL,ROBOT,A,F,V); fluent(AL,inertial,F,V); final_goal(AL,F,V,true); pl(AL); step > start; preempt_pos_fgoals = true. [10@1,true]
#heuristic occurs(AL,ROBOT,A,step) : action(AL,_,ROBOT,A); effect(AL,ROBOT,A,F,V); fluent(AL,inertial,F,V); final_goal(AL,F,V,false); pl(AL); step > start; preempt_neg_fgoals = true. [10@0,false]
#program check(step).
#external query(step). [false]
#false :- incomplete_plan(step); query(step).
#program conformance_module(step, start, first, last, type, yield).
#external current_last_sgoals(I,step) : sgoals_index(I); yield = true. [false]
include_sgoals(I,step) :- I <= I_L; S <= step; current_last_sgoals(I_L,S); sgoals_index(I).
include_sgoals(I,step) :- sgoals_index(I); yield = false.
sgoals_index((first..last)).
current_sub_goal((AL+1),ROBOT,A,F,V,first,start) :- sub_goal((AL+1),ROBOT,A,F,V,first); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
sub_goal_satisfied((AL+1),ROBOT,A,F,V,I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,(step-1)); holds((AL+1),F,V,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,(step-1)); not sub_goal_satisfied((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); type = sequential; pl(AL).
unachieved_sgoals((AL+1),I_SG,step) :- current_sub_goal_index((AL+1),I_SG,(step-1)); sub_goal((AL+1),ROBOT,A,F,V,I_SG); not sub_goal_satisfied((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,(step-1)); unachieved_sgoals((AL+1),I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); type = simultaneous; pl(AL).
current_sub_goal((AL+1),ROBOT_1,A_1,F_1,V_1,(I_SG+1),step) :- include_sgoals((I_SG+1),step); sub_goal((AL+1),ROBOT_1,A_1,F_1,V_1,(I_SG+1)); current_sub_goal_index((AL+1),I_SG,(step-1)); not current_sub_goal_index((AL+1),I_SG,step); action((AL+1),_,ROBOT_1,A_1); fluent((AL+1),inertial,F_1,V_1); pl(AL).
sgoals_ach_at((AL+1),I_SG,step) :- current_sub_goal_index((AL+1),I_SG,(step-1)); not current_sub_goal_index((AL+1),I_SG,step); pl(AL).
current_sub_goal_index((AL+1),I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
incomplete_plan(step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
#program goal_abstraction_module.
holds(AL,F,V,0) :- final_goal(AL,F,V,true); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
not holds(AL,F,V,0) :- final_goal(AL,F,V,false); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
final_goal(AL,F,V,true) :- holds(AL,F,V,0); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
final_goal(AL,F,V,false) :- not holds(AL,F,V,0); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
{ holds(AL,F,V,0) } :- goal_fluent(AL,F); fluent(AL,inertial,F,V); al(AL).
#false :- not 1 = { holds(AL,F,V,0): fluent(AL,_,F,V) }; goal_fluent(AL,F); fluent(AL,_,F,_); al(AL).
holds(AL,F,false,0) :- not holds(AL,F,true,0); goal_fluent(AL,F); fluent(AL,defined,F,B); boolean(B); al(AL).
#program domain_sorts.
#const abstraction_max = 3.
#const reduc = 3.
#const conde = 2.
#const groun = 1.
class(3,robot).
class(3,armed_robot).
class(3,location).
class(3,room).
class(3,object).
class(3,grounded).
class(3,graspable).
class(3,placeable).
class(3,block).
class(3,surface).
class(3,table).
class(3,colour).
class(3,manipulator_arm).
class(3,grasper).
class(2,door).
class(2,handle).
class(2,configurable).
class(2,extensible).
class(1,cell).
class(1,manipulator_limb).
class(1,manipulator_end).
class(1,side).
super_class(robot,armed_robot).
super_class(location,room).
super_class(location,cell).
super_class(object,robot).
super_class(object,manipulator_arm).
super_class(object,manipulator_limb).
super_class(object,manipulator_end).
super_class(object,table).
super_class(object,side).
super_class(object,block).
super_class(object,grounded).
super_class(grounded,handle).
super_class(configurable,extensible).
super_class(configurable,grasper).
super_class(configurable,door).
super_class(extensible,manipulator_arm).
super_class(extensible,manipulator_limb).
super_class(grasper,manipulator_arm).
super_class(grasper,manipulator_end).
super_class(graspable,block).
super_class(graspable,handle).
super_class(placeable,block).
super_class(surface,table).
super_class(surface,side).
super_class(surface,block).
override_class(manipulator_arm,manipulator_end,grasper).
override_class(manipulator_arm,manipulator_limb,extensible).
override_class(room,cell,location).
override_class(table,side,surface).
state(AL,extensible,extended) :- AL < reduc; al(AL).
state(AL,extensible,retracted) :- AL < reduc; al(AL).
state(AL,manipulator_end,aligned_with(OBJ)) :- insta_of(AL,graspable,OBJ); class(AL,manipulator_end); AL < reduc; al(AL).
state(AL,manipulator_end,aligned_with(nothing)) :- AL < reduc; al(AL).
state(AL,door,open) :- AL < reduc; al(AL).
state(AL,door,closed) :- AL < reduc; al(AL).
static(AL,connected(L_1,L_2)) :- insta_of(AL,location,L_1); insta_of(AL,location,L_2); al(AL).
static(AL,connected_by_door(D,L_1,L_2)) :- insta_of(AL,door,D); insta_of(AL,location,L_1); insta_of(AL,location,L_2); AL < reduc; al(AL).
static(AL,in(OBJ,L)) :- insta_of(AL,object,OBJ); insta_of(AL,grounded,OBJ); insta_of(AL,location,L); AL < reduc; al(AL).
static(AL,colour_of(BLOCK,COLOUR)) :- insta_of(AL,block,BLOCK); insta_of(AL,colour,COLOUR); al(AL).
fluent(AL_1,inertial,in(OBJ),L) :- insta_of(AL_1,location,L); insta_of(AL_2,object,OBJ); OBJ != nothing; not insta_of(AL_2,grounded,OBJ); sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,on(OBJ),SURFACE) :- OBJ != SURFACE; insta_of(AL_1,surface,SURFACE); insta_of(AL_2,placeable,OBJ); sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,grasping(DESC),OBJ) :- insta_of(AL_1,graspable,OBJ); insta_of(AL_2,grasper,DESC); sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,configuration(DESC),STATE) :- state_of(AL_1,DESC,STATE); insta_of(AL_2,configurable,DESC); AL_1 < reduc; AL_2 < reduc; sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,configuration(D),STATE) :- state_of(AL_1,D,STATE); insta_of(AL_2,door,D); AL_1 < reduc; AL_2 < reduc; sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL,defined,tower_base(BASE),B) :- insta_of(AL,block,BASE); sl(AL); boolean(B).
fluent(AL,defined,in_tower(BASE,BLOCK),B) :- insta_of(AL,block,BASE); insta_of(AL,block,BLOCK); sl(AL); boolean(B).
fluent(AL,defined,unordered_tower(BASE),B) :- insta_of(AL,block,BASE); sl(AL); boolean(B).
fluent(AL,defined,complete(COLOUR),B) :- insta_of(AL,colour,COLOUR); sl(AL); boolean(B).
action(AL,sequential,ROBO,move(L)) :- insta_of(AL,robot,ROBO); insta_of(AL,location,L); sl(AL).
action(AL,concurrent,ROBO,grasp(DESC,OBJ)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; sl(AL).
action(AL,concurrent,ROBO,release(DESC,OBJ)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; sl(AL).
action(AL,concurrent,ROBO,configure(DESC,STATE)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,configurable,DESC); state_of(AL,DESC,STATE); AL < reduc; sl(AL).
action(AL,concurrent,ROBO,put(DESC,OBJ,SURFACE)) :- OBJ != SURFACE; SURFACE != nothing; desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); sl(AL).
action(AL,concurrent,ROBO,lift(DESC,OBJ)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); sl(AL).
action(AL,sequential,ROBO,actuate(DESC,D)) :- insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,door,D); AL < reduc; sl(AL).
#program action_effects(t).
effect(AL,ROBO,move(L),in(ROBO),L) :- action(AL,_,ROBO,move(L)); fluent(AL,inertial,in(ROBO),L); insta_of(AL,robot,ROBO); insta_of(AL,location,L); pl(AL).
effect(AL,ROBO,grasp(DESC,OBJ),grasping(DESC),OBJ) :- action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; pl(AL).
effect(AL,ROBO,release(DESC,OBJ),grasping(DESC),nothing) :- action(AL,_,ROBO,release(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); pl(AL).
effect(AL,ROBO,release(END,OBJ),configuration(END),aligned_with(nothing)) :- action(AL,_,ROBO,release(END,OBJ)); fluent(AL,inertial,configuration(END),aligned_with(nothing)); desce_of(AL,ROBO,END); insta_of(AL,armed_robot,ROBO); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); state_of(AL,END,aligned_with(nothing)); AL < reduc; pl(AL).
effect(AL,ROBO,configure(DESC,STATE),configuration(DESC),STATE) :- action(AL,_,ROBO,configure(DESC,STATE)); fluent(AL,inertial,configuration(DESC),STATE); desce_of(AL,ROBO,DESC); insta_of(AL,robot,ROBO); insta_of(AL,configurable,DESC); state_of(AL,DESC,STATE); AL < reduc; pl(AL).
effect(AL,ROBO,configure(ARM,retracted),configuration(END),aligned_with(nothing),t) :- holds(AL,grasping(END),nothing,(t-1)); action(AL,_,ROBO,configure(ARM,retracted)); fluent(AL,inertial,configuration(END),aligned_with(nothing)); desce_of(AL,ROBO,ARM); desce_of(AL,ROBO,END); siblings(AL,ARM,END); insta_of(AL,armed_robot,ROBO); insta_of(AL,extensible,ARM); insta_of(AL,manipulator_end,END); state_of(AL,END,aligned_with(nothing)); AL < reduc; pl(AL).
effect(AL,ROBO,put(DESC,OBJ,SURFACE),on(OBJ),SURFACE) :- action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,on(OBJ),SURFACE); OBJ != SURFACE; SURFACE != nothing; desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); pl(AL).
effect(AL,ROBO,lift(DESC,OBJ),on(OBJ),nothing) :- action(AL,_,ROBO,lift(DESC,OBJ)); fluent(AL,inertial,on(OBJ),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); pl(AL).
effect(AL,ROBO,actuate(DESC,D),configuration(D),STATE_1,t) :- holds(AL,configuration(D),STATE_2,(t-1)); fluent(AL,inertial,configuration(D),STATE_1); fluent(AL,inertial,configuration(D),STATE_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,door,D); state_of(AL,D,STATE_1); state_of(AL,D,STATE_2); STATE_1 != STATE_2; AL < reduc; pl(AL).
#program action_preconditions(t).
1 = { precond(AL,ROBO,move(P_2),in(ROBO),P_1,true,t): is(AL,connected(P_1,P_2)), fluent(AL,inertial,in(ROBO),P_1), static(AL,connected(P_1,P_2)), P_1 != P_2, insta_of(AL,location,P_1) } :- action(AL,_,ROBO,move(P_2)); insta_of(AL,robot,ROBO); insta_of(AL,location,P_2); AL < reduc; pl(AL).
precond(AL,ROBO,move(L_2),configuration(D),open,true,t) :- holds(AL,in(ROBO),L_1,(t-1)); is(AL,connected_by_door(D,L_1,L_2)); L_1 != L_2; action(AL,_,ROBO,move(L_2)); fluent(AL,inertial,configuration(D),open); fluent(AL,_,in(ROBO),L_1); static(AL,connected_by_door(D,L_1,L_2)); insta_of(AL,robot,ROBO); insta_of(AL,location,L_1); insta_of(AL,location,L_2); insta_of(AL,door,D); AL < reduc; pl(AL).
1 = { precond(AL,ROBO,actuate(COMP,D),grasping(COMP),H,true,t): desce_of(AL,D,H), insta_of(AL,handle,H), action(AL,_,ROBO,actuate(COMP,D)), fluent(AL,inertial,grasping(COMP),H) } :- desce_of(AL,ROBO,COMP); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,COMP); insta_of(AL,door,D); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),in(ROBO),L,true) :- is(AL,in(OBJ,L)); action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,in(ROBO),L); static(AL,in(OBJ,L)); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,grounded,OBJ); insta_of(AL,location,L); AL < reduc; pl(AL).
precond(AL,ROBO,move(L),configuration(DESC),retracted,true) :- action(AL,_,ROBO,move(L)); fluent(AL,inertial,configuration(DESC),retracted); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,extensible,DESC); insta_of(AL,location,L); state_of(AL,DESC,retracted); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),in(OBJ),L,true,t) :- holds(AL,in(ROBO),L,(t-1)); OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,in(OBJ),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),in(ROBO),L,true,t) :- holds(AL,in(OBJ),L,(t-1)); OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,in(OBJ),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),grasping(DESC),nothing,true) :- OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ_1),on(OBJ_2),OBJ_1,false) :- OBJ_1 != OBJ_2; OBJ_1 != nothing; action(AL,_,ROBO,grasp(DESC,OBJ_1)); fluent(AL,inertial,on(OBJ_2),OBJ_1); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ_1); insta_of(AL,surface,OBJ_1); insta_of(AL,placeable,OBJ_2); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),configuration(DESC),extended,true) :- OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,configuration(DESC),extended); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,extensible,DESC); insta_of(AL,graspable,OBJ); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(DESC_1,OBJ),configuration(DESC_2),extended,true) :- OBJ != nothing; action(AL,_,ROBO,grasp(DESC_1,OBJ)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC_1); not insta_of(AL,extensible,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,graspable,OBJ); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(END,OBJ),configuration(END),aligned_with(OBJ),true) :- OBJ != nothing; action(AL,_,ROBO,grasp(END,OBJ)); fluent(AL,inertial,configuration(END),aligned_with(OBJ)); desce_of(AL,ROBO,END); insta_of(AL,armed_robot,ROBO); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); state_of(AL,END,aligned_with(OBJ)); AL < reduc; pl(AL).
precond(AL,ROBO,release(DESC,OBJ),grasping(DESC),OBJ,true) :- OBJ != nothing; action(AL,_,ROBO,release(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); pl(AL).
precond(AL,ROBO,release(DESC,OBJ),configuration(DESC),extended,true) :- OBJ != nothing; action(AL,_,ROBO,release(DESC,OBJ)); fluent(AL,inertial,configuration(DESC),extended); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); state_of(AL,DESC,extended); pl(AL); t > 0.
precond(AL,ROBO,release(DESC_1,OBJ),configuration(DESC_2),extended,true) :- OBJ != nothing; action(AL,_,ROBO,release(DESC_1,OBJ)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC_1); not insta_of(AL,extensible,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,graspable,OBJ); pl(AL).
precond(AL,ROBO,configure(DESC_1,STATE),configuration(DESC_2),extended,true) :- action(AL,_,ROBO,configure(DESC_1,STATE)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); desce_of(AL,ROBO,ARM); child_of(AL,ARM,DESC_1); child_of(AL,ARM,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,configurable,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,manipulator_arm,ARM); state_of(AL,DESC_1,STATE); AL < reduc; pl(AL).
precond(AL,ROBO,configure(DESC,aligned_with(OBJ)),grasping(DESC),nothing,true) :- action(AL,_,ROBO,configure(DESC,aligned_with(OBJ))); fluent(AL,inertial,grasping(DESC),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,manipulator_end,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; state_of(AL,DESC,aligned_with(OBJ)); AL < reduc; pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),in(SURFACE),L,true,t) :- holds(AL,in(ROBO),L,(t-1)); action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,in(SURFACE),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),in(ROBO),L,true,t) :- holds(AL,in(SURFACE),L,(t-1)); action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,in(SURFACE),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,put(DESC,OBJ_1,BLOCK),on(OBJ_2),BLOCK,false) :- OBJ_1 != OBJ_2; action(AL,_,ROBO,put(DESC,OBJ_1,SURFACE)); fluent(AL,inertial,on(OBJ_2),BLOCK); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ_1); insta_of(AL,placeable,OBJ_2); insta_of(AL,block,BLOCK); pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),grasping(DESC),OBJ,true) :- OBJ != SURFACE; OBJ != nothing; SURFACE != nothing; action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); pl(AL).
precond(AL,ROBO_1,put(DESC_1,OBJ_1,OBJ_2),grasping(DESC_2),OBJ_2,false) :- OBJ_1 != OBJ_2; DESC_1 != DESC_2; action(AL,_,ROBO,put(DESC_1,OBJ_1,OBJ_2)); fluent(AL,inertial,grasping(DESC_2),OBJ_2); desce_of(AL,ROBO_1,DESC_1); desce_of(AL,ROBO_2,DESC_2); insta_of(AL,armed_robot,ROBO_1); insta_of(AL,armed_robot,ROBO_2); insta_of(AL,grasper,DESC_1); insta_of(AL,grasper,DESC_2); insta_of(AL,placeable,OBJ_1); insta_of(AL,surface,OBJ_2); insta_of(AL,graspable,OBJ_2); pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),configuration(DESC),extended,true) :- action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,configuration(DESC),extended); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,extensible,DESC); insta_of(AL,graspable,OBJ); insta_of(AL,surface,SURFACE); AL < reduc; pl(AL).
precond(AL,ROBO,put(DESC_1,OBJ,SURFACE),configuration(DESC_2),extended,true) :- action(AL,_,ROBO,put(DESC_1,OBJ,SURFACE)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC_1); not insta_of(AL,extensible,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,graspable,OBJ); insta_of(AL,surface,SURFACE); AL < reduc; pl(AL).
precond(AL,ROBO,lift(DESC,OBJ_1),on(OBJ_2),OBJ_1,false) :- OBJ_1 != OBJ_2; action(AL,_,ROBO,lift(DESC,OBJ_1)); fluent(AL,inertial,on(OBJ_2),OBJ_1); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ_1); insta_of(AL,surface,OBJ_1); insta_of(AL,placeable,OBJ_2); pl(AL).
precond(AL,ROBO,lift(DESC,OBJ),grasping(DESC),OBJ,true) :- OBJ != SURFACE; action(AL,_,ROBO,lift(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,surface,SURFACE); pl(AL).
#program variable_relations(t).
#false :- holds(AL,grasping(DESC),OBJ,t); holds(AL,in(ROBO),L,t); not holds(AL,in(OBJ),L,t): not insta_of(AL,grounded,OBJ), fluent(AL,inertial,in(OBJ),L); not is(AL,in(OBJ,L)): insta_of(AL,grounded,OBJ), static(AL,in(OBJ,L)); fluent(AL,inertial,grasping(DESC),OBJ); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,location,L); sl(AL).
#false :- holds(AL,configuration(END),aligned_with(OBJ),t); holds(AL,in(ROBO),L,t); not holds(AL,in(OBJ),L,t): not insta_of(AL,grounded,OBJ), fluent(AL,inertial,in(OBJ),L); not is(AL,in(OBJ,L)): insta_of(AL,grounded,OBJ), static(AL,in(OBJ,L)); fluent(AL,inertial,configuration(END),aligned_with(OBJ)); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,END); insta_of(AL,robot,ROBO); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,location,L); state_of(AL,END,aligned_with(OBJ)); sl(AL).
#false :- holds(AL,grasping(END),OBJ,t); not holds(AL,configuration(END),aligned_with(OBJ),t); fluent(AL,inertial,grasping(END),OBJ); fluent(AL,inertial,configuration(END),aligned_with(OBJ)); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); OBJ != nothing; state_of(AL,END,aligned_with(OBJ)); sl(AL).
#false :- holds(AL,grasping(DESC),OBJ_1,t); holds(AL,on(OBJ_2),OBJ_1,t); fluent(AL,inertial,grasping(DESC),OBJ_1); fluent(AL,inertial,on(OBJ_2),OBJ_1); desce_of(AL,ROBO,DESC); insta_of(AL,robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ_1); OBJ_1 != nothing; insta_of(AL,surface,OBJ_1); insta_of(AL,placeable,OBJ_2); sl(AL).
#false :- holds(AL,on(OBJ),SURFACE,t); holds(AL,in(SURFACE),L,t); not holds(AL,in(OBJ),L,t); fluent(AL,inertial,on(OBJ),SURFACE); fluent(AL,inertial,in(SURFACE),L); fluent(AL,inertial,in(OBJ),L); insta_of(AL,location,L); insta_of(AL,location,L); insta_of(AL,surface,SURFACE); insta_of(AL,object,OBJ); sl(AL).
#false :- holds(AL,on(BLOCK_1),BLOCK_2,t); holds(AL,on(BLOCK_2),nothing,t); fluent(AL,inertial,on(BLOCK_1),BLOCK_2); fluent(AL,inertial,on(BLOCK_2),nothing); insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); sl(AL).
#false :- holds(AL,on(BLOCK_1),BLOCK_3,t); holds(AL,on(BLOCK_2),BLOCK_3,t); fluent(AL,inertial,on(BLOCK_1),BLOCK_3); fluent(AL,inertial,on(BLOCK_2),BLOCK_3); BLOCK_1 != BLOCK_2; insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); insta_of(AL,block,BLOCK_3); sl(AL).
holds(AL,tower_base(BASE),true,t) :- holds(AL,on(BASE),TABLE,t); fluent(AL,defined,tower_base(BASE),true); fluent(AL,inertial,on(BASE),TABLE); insta_of(AL,block,BASE); insta_of(AL,table,TABLE); sl(AL).
holds(AL,tower_base(BASE),true,t) :- holds(AL,on(BASE),SURFACE,t); fluent(AL,defined,tower_base(BASE),true); fluent(AL,inertial,on(BASE),SURFACE); desce_of(AL,TABLE,SURFACE); insta_of(AL,block,BASE); insta_of(AL,surface,SURFACE); insta_of(AL,table,TABLE); sl(AL).
holds(AL,in_tower(BASE,BASE),true,t) :- holds(AL,tower_base(BASE),true,t); fluent(AL,defined,in_tower(BASE,BASE),true); fluent(AL,defined,tower_base(BASE),true); insta_of(AL,block,BASE); sl(AL).
holds(AL,in_tower(BLOCK_1,BLOCK_2),true,t) :- holds(AL,on(BLOCK_2),BLOCK_3,t); holds(AL,in_tower(BLOCK_1,BLOCK_3),true,t); fluent(AL,defined,in_tower(BLOCK_1,BLOCK_2),true); fluent(AL,defined,in_tower(BLOCK_1,BLOCK_3),true); fluent(AL,inertial,on(BLOCK_2),BLOCK_3); BLOCK_1 != BLOCK_2; insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); insta_of(AL,block,BLOCK_3); sl(AL).
holds(AL,unordered_tower(BASE),true,t) :- holds(AL,on(BLOCK_1),BLOCK_2,t); holds(AL,in_tower(BASE,BLOCK_1),true,t); holds(AL,in_tower(BASE,BLOCK_2),true,t); holds(AL,tower_base(BASE),true,t); fluent(AL,defined,unordered_tower(BASE),true); fluent(AL,defined,in_tower(BASE,BLOCK_1),true); fluent(AL,defined,in_tower(BASE,BLOCK_2),true); fluent(AL,defined,tower_base(BASE),true); fluent(AL,inertial,on(BLOCK_1),BLOCK_2); BLOCK_1 = (block,N_1); number(N_1); BLOCK_2 = (block,N_2); number(N_2); BLOCK_1 != BLOCK_2; N_1 > N_2; insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); insta_of(AL,block,BASE); sl(AL).
holds(AL,complete(COLOUR),true,t) :- N = #count { BLOCK: holds(AL,in_tower(BASE,BLOCK),true,t), is(AL,colour_of(BLOCK,COLOUR)), fluent(AL,defined,in_tower(BASE,BLOCK),true), static(AL,colour_of(BLOCK,COLOUR)), insta_of(AL,block,BLOCK) }; N = #count { BLOCK: is(AL,colour_of(BLOCK,COLOUR)), static(AL,colour_of(BLOCK,COLOUR)), insta_of(AL,block,BLOCK) }; holds(AL,unordered_tower(BASE),false,t); holds(AL,tower_base(BASE),true,t); fluent(AL,defined,unordered_tower(BASE),true); fluent(AL,defined,tower_base(BASE),true); is(AL,colour_of(BASE,COLOUR)); static(AL,colour_of(BASE,COLOUR)); insta_of(AL,colour,COLOUR); insta_of(AL,block,BASE); sl(AL).
#program abstraction_mappings(t).
is(AL_1,connected(L_1,L_2)) :- is(AL_2,connected(L_1_C,L_2_C)); static(AL_1,connected(L_1,L_2)); static(AL_2,connected(L_1_C,L_2_C)); L_1 != L_2; desce_of(AL_2,L_1,L_1_C); desce_of(AL_2,L_2,L_2_C); insta_of(AL_1,location,L_1); insta_of(AL_1,location,L_2); insta_of(AL_2,location,L_1_C); insta_of(AL_2,location,L_2_C); al(AL_1); al(AL_2); AL_1 >= AL_2.
is(AL_1,connected(L_1,L_2)) :- is(AL_2,connected(L_1,L_2)); static(AL_1,connected(L_1,L_2)); static(AL_2,connected(L_1,L_2)); L_1 != L_2; insta_of(AL_1,location,L_1); insta_of(AL_1,location,L_2); insta_of(AL_2,location,L_1); insta_of(AL_2,location,L_2); al(AL_1); al(AL_2); AL_1 >= AL_2.
is(AL_1,connected_by_door(D,L_1,L_2)) :- is(AL_2,connected_by_door(D,L_1_C,L_2_C)); static(AL_1,connected_by_door(D,L_1,L_2)); static(AL_2,connected_by_door(D,L_1_C,L_2_C)); L_1 != L_2; desce_of(AL_2,L_1,L_1_C); desce_of(AL_2,L_2,L_2_C); insta_of(AL_1,door,D); insta_of(AL_2,door,D); insta_of(AL_1,location,L_1); insta_of(AL_1,location,L_2); insta_of(AL_2,location,L_1_C); insta_of(AL_2,location,L_2_C); al(AL_1); al(AL_2); AL_1 >= AL_2.
is(AL_1,in(OBJ,L_1)) :- is(AL_2,in(OBJ,L_2)); static(AL_1,in(OBJ,L_1)); static(AL_2,in(OBJ,L_2)); desce_of(AL_2,L_1,L_2); insta_of(AL_1,location,L_1); insta_of(AL_1,object,OBJ); insta_of(AL_1,grounded,OBJ); insta_of(AL_1,location,L_1); insta_of(AL_2,location,L_2); al(AL_1); al(AL_2); AL_1 >= AL_2.
holds(AL_1,in(OBJ),L_1,t) :- holds(AL_2,in(OBJ),L_2,t); fluent(AL_1,inertial,in(OBJ),L_1); fluent(AL_2,inertial,in(OBJ),L_2); desce_of(AL_2,L_1,L_2); insta_of(AL_1,location,L_1); insta_of(AL_2,location,L_2); insta_of(AL_3,object,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
holds(AL_1,in(OBJ),L,t) :- holds(AL_2,in(OBJ),L,t); fluent(AL_1,inertial,in(OBJ),L); fluent(AL_2,inertial,in(OBJ),L); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,object,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
holds(AL_1,in(DESC),L,t) :- holds(AL_2,in(OBJ),L,t); fluent(AL_1,inertial,in(DESC),L); fluent(AL_2,inertial,in(OBJ),L); desce_of(AL_2,OBJ,DESC); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,object,OBJ); insta_of(AL_4,_,DESC); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_2; sl(AL_4); AL_4 >= AL_1.
holds(AL_1,in(OBJ),L,t) :- holds(AL_2,in(DESC),L,t); fluent(AL_1,inertial,in(OBJ),L); fluent(AL_2,inertial,in(DESC),L); desce_of(AL_2,OBJ,DESC); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,object,OBJ); insta_of(AL_4,_,DESC); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_2.
holds(AL_1,in(OBJ),L,t) :- holds(AL_2,in(ROBO),L,t); holds(AL_3,grasping(DESC),OBJ,t); fluent(AL_1,inertial,in(OBJ),L); fluent(AL_2,inertial,in(ROBO),L); fluent(AL_3,inertial,grasping(DESC),OBJ); desce_of(AL_2,ROBO,DESC); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,graspable,OBJ); OBJ != nothing; insta_of(AL_4,grasper,DESC); insta_of(AL_5,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_3; sl(AL_5); AL_5 >= AL_3.
holds(AL_1,grasping(DESC),OBJ_1,t) :- holds(AL_2,grasping(DESC),OBJ_2,t); fluent(AL_1,inertial,grasping(DESC),OBJ_1); fluent(AL_2,inertial,grasping(DESC),OBJ_2); desce_of(AL_2,ROBO,DESC); desce_of(AL_2,OBJ_1,OBJ_2); insta_of(AL_1,graspable,OBJ_1); insta_of(AL_2,graspable,OBJ_2); insta_of(AL_3,grasper,DESC); insta_of(AL_4,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_1.
holds(AL_1,grasping(DESC_1),OBJ,t) :- holds(AL_2,grasping(DESC_2),OBJ,t); fluent(AL_1,inertial,grasping(DESC_1),OBJ); fluent(AL_2,inertial,grasping(DESC_2),OBJ); desce_of(AL_2,ROBO,DESC_1); desce_of(AL_2,ROBO,DESC_2); desce_of(AL_2,DESC_1,DESC_2); insta_of(AL_1,graspable,OBJ); insta_of(AL_2,graspable,OBJ); insta_of(AL_3,grasper,DESC_1); insta_of(AL_4,grasper,DESC_2); insta_of(AL_5,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_2; sl(AL_5); AL_5 >= AL_1.
holds(AL_1,grasping(DESC),OBJ,t) :- holds(AL_2,grasping(DESC),OBJ,t); fluent(AL_1,inertial,grasping(DESC),OBJ); fluent(AL_2,inertial,grasping(DESC),OBJ); desce_of(AL_2,ROBO,DESC); insta_of(AL_1,graspable,OBJ); insta_of(AL_2,graspable,OBJ); insta_of(AL_3,grasper,DESC); insta_of(AL_4,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_1; boolean(B).
holds(AL_1,configuration(DESC_1),STATE,t) :- holds(AL_2,configuration(DESC_2),STATE,t); fluent(AL_1,inertial,configuration(DESC_1),STATE); fluent(AL_2,inertial,configuration(DESC_2),STATE); desce_of(AL_2,DESC_1,DESC_2); state_of(AL_1,DESC_1,STATE); state_of(AL_2,DESC_2,STATE); insta_of(AL_1,configurable,DESC_1); insta_of(AL_2,configurable,DESC_2); sl(AL_1); sl(AL_2); AL_1 >= AL_2.
holds(AL_1,configuration(DESC),STATE,t) :- holds(AL_2,configuration(DESC),STATE,t); fluent(AL_1,inertial,configuration(DESC),STATE); fluent(AL_2,inertial,configuration(DESC),STATE); state_of(AL_1,DESC,STATE); state_of(AL_2,DESC,STATE); insta_of(AL_1,configurable,DESC); insta_of(AL_2,configurable,DESC); sl(AL_1); sl(AL_2); AL_1 >= AL_2.
holds(AL_1,on(OBJ),SURFACE_1,t) :- holds(AL_2,on(OBJ),SURFACE_2,t); fluent(AL_1,inertial,on(OBJ),SURFACE_1); fluent(AL_2,inertial,on(OBJ),SURFACE_2); desce_of(AL_2,SURFACE_1,SURFACE_2); insta_of(AL_1,surface,SURFACE_1); insta_of(AL_2,surface,SURFACE_2); insta_of(AL_3,placeable,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
holds(AL_1,on(OBJ),SURFACE,t) :- holds(AL_2,on(OBJ),SURFACE,t); fluent(AL_1,inertial,on(OBJ),SURFACE); fluent(AL_2,inertial,on(OBJ),SURFACE); insta_of(AL_1,surface,SURFACE); insta_of(AL_2,surface,SURFACE); insta_of(AL_3,placeable,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
#program static_state.
is(1,connected((starting_room,1),(hallway,1))).
is(1,connected((store_room,1),(hallway,0))).
is(1,connected((hallway,2),(puzzle_room,0))).
is(1,connected_by_door(store_room_door,(store_room,1),(hallway,0))).
is(1,connected_by_door(puzzle_room_door,(hallway,2),(puzzle_room,0))).
is(1,in(store_room_door_handle_inner,(store_room,1))).
is(1,in(store_room_door_handle_outer,(hallway,0))).
is(1,in(starting_room_door_handle_inner,(starting_room,1))).
is(1,in(starting_room_door_handle_outer,(hallway,1))).
is(1,in(puzzle_room_door_handle_inner,(puzzle_room,0))).
is(1,in(puzzle_room_door_handle_outer,(hallway,2))).
is(AL,colour_of((BLOCK,N),red)) :- static(AL,colour_of((BLOCK,N),red)); insta_of(AL,block,(BLOCK,N)); N <= 3; al(AL).
is(AL,colour_of((BLOCK,N),blue)) :- static(AL,colour_of((BLOCK,N),blue)); insta_of(AL,block,(BLOCK,N)); N > 3; N <= 6; al(AL).
is(1,connected((A,X_1),(A,X_2))) :- insta_of(1,cell,(A,X_1)); insta_of(1,cell,(A,X_2)); X_2 = (X_1+1).
is(1,connected(C_1,C_2)) :- is(1,connected(C_2,C_1)); insta_of(1,cell,C_1); insta_of(1,cell,C_2).
is(1,connected_by_door(D,C_1,C_2)) :- is(1,connected_by_door(D,C_2,C_1)); insta_of(1,door,D); insta_of(1,cell,C_1); insta_of(1,cell,C_2).
#program initial_state.
holds(1,in(talos),(starting_room,0),0).
holds(AL,grasping(DESC),nothing,0) :- fluent(AL,inertial,grasping(DESC),nothing); insta_of(AL,grasper,DESC); al(AL).
holds(AL,configuration(DESC),retracted,0) :- fluent(AL,inertial,configuration(DESC),retracted); insta_of(AL,extensible,DESC); sl(AL).
holds(1,configuration(END),aligned_with(nothing),0) :- fluent(AL,inertial,configuration(END),aligned_with(nothing)); insta_of(AL,manipulator_end,END); state_of(AL,END,aligned_with(nothing)); sl(AL).
holds(1,configuration(DOOR),closed,0) :- fluent(AL,inertial,configuration(DOOR),closed); insta_of(AL,door,DOOR); state_of(AL,DOOR,closed); sl(AL).
holds(1,in(puzzle_room_table),(puzzle_room,1),0).
holds(1,on((block,1)),puzzle_room_table_left,0).
holds(1,on((block,2)),puzzle_room_table_right,0).
holds(1,on((block,3)),(block,1),0).
holds(1,in((block,4)),(store_room,0),0).
holds(1,in((block,5)),(store_room,0),0).
holds(1,in((block,6)),(store_room,0),0).
holds(1,on((block,4)),nothing,0).
holds(1,on((block,5)),nothing,0).
holds(1,on((block,6)),nothing,0).
#program goal_state.
goal_fluent(AL,complete(COLOUR)) :- insta_of(AL,colour,COLOUR); al(AL).
goal_fluent(AL,on((block,3))) :- al(AL).
goal_fluent(AL,on((block,6))) :- al(AL).
final_goal(AL,complete(COLOUR),true,true) :- insta_of(AL,colour,COLOUR); al(AL).
final_goal(1,on((block,3)),puzzle_room_table_left,true).
final_goal(1,on((block,6)),puzzle_room_table_right,true).
#program entities.
entity(armed_robot,talos).
entity(manipulator_arm,manipulator_arm_1).
entity(manipulator_limb,manipulator_limb_1).
entity(manipulator_end,manipulator_end_1).
entity(manipulator_arm,manipulator_arm_2).
entity(manipulator_limb,manipulator_limb_2).
entity(manipulator_end,manipulator_end_2).
number((1..6)).
entity(block,(block,N)) :- number(N).
entity(room,starting_room).
entity(room,store_room).
entity(room,puzzle_room).
entity(room,hallway).
x((0..3)).
size(starting_room,2).
size(store_room,2).
size(hallway,3).
size(puzzle_room,2).
entity(cell,(ROOM,X)) :- entity(room,ROOM); size(ROOM,MAX); X < MAX; x(X).
entity(door,store_room_door).
entity(door,starting_room_door).
entity(door,puzzle_room_door).
entity(handle,store_room_door_handle_inner).
entity(handle,store_room_door_handle_outer).
entity(handle,starting_room_door_handle_inner).
entity(handle,starting_room_door_handle_outer).
entity(handle,puzzle_room_door_handle_inner).
entity(handle,puzzle_room_door_handle_outer).
entity(table,puzzle_room_table).
entity(side,puzzle_room_table_left).
entity(side,puzzle_room_table_right).
entity(colour,red).
entity(colour,blue).
entity(surface,nothing).
entity(graspable,nothing).
ancestry_relation(talos,manipulator_arm_1).
ancestry_relation(talos,manipulator_arm_2).
ancestry_relation(manipulator_arm_1,manipulator_limb_1).
ancestry_relation(manipulator_arm_2,manipulator_limb_2).
ancestry_relation(manipulator_arm_1,manipulator_end_1).
ancestry_relation(manipulator_arm_2,manipulator_end_2).
ancestry_relation(ROOM,(ROOM,X)) :- entity(room,ROOM); entity(cell,(ROOM,X)); x(X).
ancestry_relation(store_room_door,store_room_door_handle_inner).
ancestry_relation(store_room_door,store_room_door_handle_outer).
ancestry_relation(starting_room_door,starting_room_door_handle_inner).
ancestry_relation(starting_room_door,starting_room_door_handle_outer).
ancestry_relation(puzzle_room_door,puzzle_room_door_handle_inner).
ancestry_relation(puzzle_room_door,puzzle_room_door_handle_outer).
ancestry_relation(puzzle_room_table,puzzle_room_table_left).
ancestry_relation(puzzle_room_table,puzzle_room_table_right)., Anonymous #1))
	('solver_options', ['--parallel-mode=1,compete'])
	('assumptions', [])
	('context', None)
	('solve_incrementor', None)
	('base_parts', [BasePart(name='abstraction_levels', args=[0, 'hierarchical']), BasePart(name='domain_sorts', args=())])
	('inc_parts', [IncPart(name='step', args=['#inc'], range_=None)])
	('incremental', False)

[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Setting input storing variables:
	solver_options = ['--parallel-mode=1,compete']
	assumptions = []
	context = None
	incrementor = None
	base_parts = [BasePart(name='abstraction_levels', args=[0, 'hierarchical']), BasePart(name='domain_sorts', args=())]
	inc_parts = [IncPart(name='step', args=['#inc'], range_=None)]

[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Output storing variables reset.

[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Program building started :: Processing 331 rules

[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Program building completed in 0.0028133000000000186s

[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Running one-shot ground and solve of program parts:
[BasePart(name='abstraction_levels', args=[0, 'hierarchical']), BasePart(name='domain_sorts', args=())]

[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Grounding program parts:
[('abstraction_levels', [Number(0), Function('hierarchical', [], True)]), ('domain_sorts', [])]

[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:91:58-77: info: atom does not occur in any rule head:
  insta_of(#X0,#P1,#X2)


[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:574:50-78: info: atom does not occur in any rule head:
  insta_of(AL,graspable,OBJ)


[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:587:36-63: info: atom does not occur in any rule head:
  insta_of(AL,location,L_1)


[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:588:36-63: info: atom does not occur in any rule head:
  insta_of(AL,location,L_2)


[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:592:47-68: info: atom does not occur in any rule head:
  insta_of(AL,door,D)


[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:593:47-74: info: atom does not occur in any rule head:
  insta_of(AL,location,L_1)


[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:594:47-74: info: atom does not occur in any rule head:
  insta_of(AL,location,L_2)


[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:598:27-52: info: atom does not occur in any rule head:
  insta_of(AL,object,OBJ)


[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:599:27-54: info: atom does not occur in any rule head:
  insta_of(AL,grounded,OBJ)


[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:600:27-52: info: atom does not occur in any rule head:
  insta_of(AL,location,L)


[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:604:41-67: info: atom does not occur in any rule head:
  insta_of(AL,block,BLOCK)


[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:605:41-69: info: atom does not occur in any rule head:
  insta_of(AL,colour,COLOUR)


[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:617:39-66: info: atom does not occur in any rule head:
  insta_of(AL_1,location,L)


[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:618:39-66: info: atom does not occur in any rule head:
  insta_of(AL_2,object,OBJ)


[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:619:43-72: info: atom does not occur in any rule head:
  insta_of(AL_2,grounded,OBJ)


[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:625:45-77: info: atom does not occur in any rule head:
  insta_of(AL_1,surface,SURFACE)


[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:626:45-75: info: atom does not occur in any rule head:
  insta_of(AL_2,placeable,OBJ)


[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:631:48-78: info: atom does not occur in any rule head:
  insta_of(AL_1,graspable,OBJ)


[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:632:48-77: info: atom does not occur in any rule head:
  insta_of(AL_2,grasper,DESC)


[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:637:55-82: info: atom does not occur in any rule head:
  state_of(AL_1,DESC,STATE)


[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Grounding completed in 0.011645s.

[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Solving program.

[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Model found:
Model :: Total atoms = 67, Cost = (), Optimality proven = False, Number = 1, Thread ID = 0, Model type = ModelType.StableModel

[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Solving completed in 0.001580s with result Satisfiable.

[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Freeing held grounding...

[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Setting input storing variables:
	solver_options = []
	assumptions = []
	context = None
	incrementor = None
	base_parts = []
	inc_parts = []

[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Held grounding freed.

[15-09-2021_15-49-16] DEBUG :: Logic Program Anonymous #1 >> Returning from standard solve call:
Result :: SATISFIABLE : SEARCH INTERRUPTED : Total models = 1
Statistics :: Grounding = 0.011645s, Solving = 0.001580s, Total = 0.013224s, Memory = (RSS = 80.000000b, VMS = 70.000000b)
Final Model :: Total atoms = 67, Cost = (), Optimality proven = False, Number = 1, Thread ID = 0, Model type = ModelType.StableModel

[15-09-2021_15-49-16] DEBUG :: core.Planner >> Planning Domain Anon #1 :: Abstraction range = [1-3] instantiated successfully

[15-09-2021_15-49-16] DEBUG :: Logic Program ASH #1 >> Instantiating logic program...

[15-09-2021_15-49-16] DEBUG :: Logic Program ASH #1 >> Setting input storing variables:
	solver_options = []
	assumptions = []
	context = None
	incrementor = None
	base_parts = []
	inc_parts = []

[15-09-2021_15-49-16] DEBUG :: Logic Program ASH #1 >> Output storing variables reset.

[15-09-2021_15-49-16] DEBUG :: Logic Program ASH #1 >> Logic program instantiated.

[15-09-2021_15-49-16] DEBUG :: ASH Planner Main #1 >> Instantiated with program:
LogicProgram(#program base.
#program abstraction_levels(planning_level, mode).
al((1..abstraction_max)).
pl(AL) :- AL = planning_level; al(AL).
sl(AL) :- AL = planning_level; mode = classical; al(AL).
sl(AL) :- AL >= planning_level; AL <= (planning_level+1); mode = refinement; al(AL).
sl(AL) :- AL >= planning_level; AL <= abstraction_max; mode = hierarchical; al(AL).
#program instance_module.
boolean(true;false).
insta_of(AL,CLS,EN) :- entity(CLS,EN); class(AL,CLS); al(AL).
insta_of(AL_3,CLS_1,EN) :- insta_of(AL_2,CLS_2,EN); super_class(CLS_1,CLS_2); entity(CLS_3,EN); class(AL_3,CLS_3); class(AL_1,CLS_1); AL_1 >= AL_2; al(AL_1); al(AL_2); al(AL_3).
insta_of((AL-1),CLS,EN) :- insta_of(AL,CLS,EN); not overridden((AL-1),CLS,EN); class(_,CLS); al(AL); al((AL-1)).
overridden((AL-1),CLS,EN_1) :- overridden_by((AL-1),CLS,EN_1,EN_2); insta_of(AL,CLS,EN_1); insta_of((AL-1),CLS,EN_2); class(_,CLS); al(AL); al((AL-1)).
overridden_by((AL-1),CLS_3,EN_1,EN_2) :- insta_of(AL,CLS_1,EN_1); insta_of((AL-1),CLS_2,EN_2); insta_of(AL,CLS_3,EN_1); insta_of((AL-1),CLS_3,EN_2); desce_of((AL-1),EN_1,EN_2); override_class(CLS_1,CLS_2,CLS_3); class(_,CLS_1); class(_,CLS_2); class(_,CLS_3); al(AL); al((AL-1)).
state_of(AL,EN,S) :- state(AL,CLS,S); insta_of(AL,CLS,EN); al(AL).
child_of(AL,EN,DESCE) :- ancestry_relation(EN,DESCE); insta_of(AL,_,EN); insta_of(AL,_,DESCE); al(AL).
desce_of(AL,EN,DESCE) :- child_of(AL,EN,DESCE); insta_of(AL,_,EN); insta_of(AL,_,DESCE); al(AL).
desce_of(AL,EN,DESCE_1) :- desce_of(AL,DESCE_2,DESCE_1); desce_of(AL,EN,DESCE_2); insta_of(AL,_,EN); insta_of(AL,_,DESCE_1); insta_of(AL,_,DESCE_2); al(AL).
has_desce(AL,EN) :- desce_of(AL,EN,DESCE); insta_of(AL,_,EN); insta_of(AL,_,DESCE); al(AL).
has_desce(AL,EN,CLS) :- desce_of(AL,EN,DESCE); insta_of(AL,_,EN); insta_of(AL,CLS,DESCE); al(AL).
siblings(AL,DESCE_1,DESCE_2) :- child_of(AL,EN,DESCE_1); child_of(AL,EN,DESCE_2); DESCE_1 != DESCE_2; insta_of(AL,_,EN); insta_of(AL,_,DESCE_1); insta_of(AL,_,DESCE_2); al(AL).
siblings(AL,DESCE_2,DESCE_1) :- siblings(AL,DESCE_1,DESCE_2); insta_of(AL,_,DESCE_1); insta_of(AL,_,DESCE_2); al(AL).
#program state_module(step, start).
{ holds(AL,F,V,step) } :- fluent(AL,inertial,F,V); sl(AL); step = start.
#false :- not 1 = { holds(AL,F,V,step): fluent(AL,_,F,V) }; fluent(AL,_,F,_); sl(AL).
holds(AL,F,V,step) :- holds(AL,F,V,(step-1)); not not holds(AL,F,V,step); fluent(AL,inertial,F,V); sl(AL); step > start.
holds(AL,F,false,step) :- not holds(AL,F,true,step); fluent(AL,defined,F,B); boolean(B); sl(AL).
#program plan_module(step, start, concurrency, achieve_fgoals).
{ occurs(AL,ROBOT,A,step): action(AL,_,ROBOT,A) } :- incomplete_plan((step-1)); pl(AL); step > start.
occurs(AL,ROBOT,step) :- occurs(AL,ROBOT,A,step); action(AL,_,ROBOT,A); pl(AL); step > start.
occurs(AL,step) :- occurs(AL,ROBOT,step); insta_of(AL,robot,ROBOT); pl(AL); step > start.
holds(AL,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V,step); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
holds(AL,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,true,step); not holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,true); not holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,false,step); holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,false); holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- not 1 = { occurs(AL,R,A,step): action(AL,_,ROBOT,A) }; incomplete_plan((step-1)); pl(AL); step > start; concurrency = false.
#false :- not 1 <= { occurs(AL,R,A,step): action(AL,_,ROBOT,A) }; incomplete_plan((step-1)); pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT,A_1,step); occurs(AL,ROBOT,A_2,step); A_1 != A_2; action(AL,_,ROBOT,A_1); action(AL,_,ROBOT,A_2); pl(AL); step > start; concurrency = false.
#false :- occurs(AL,ROBOT,A_1,step); occurs(AL,ROBOT,A_2,step); A_1 != A_2; action(AL,sequential,ROBOT,A_1); action(AL,_,ROBOT,A_2); pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); effect(AL,ROBOT_2,A_2,F,V_2,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; ROBOT_1 != ROBOT_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); effect(AL,ROBOT_2,A_2,F,V_2); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; ROBOT_1 != ROBOT_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1); effect(AL,ROBOT_2,A_2,F,V_2); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; ROBOT_1 != ROBOT_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); precond(AL,ROBOT_2,A_2,F,V_2,true,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); precond(AL,ROBOT_2,A_2,F,V_2,true); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V,step); precond(AL,ROBOT_2,A_2,F,V,false,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V,step); precond(AL,ROBOT_2,A_2,F,V,false); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1); precond(AL,ROBOT_2,A_2,F,V_2,true,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1); precond(AL,ROBOT_2,A_2,F,V_2,true); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V); precond(AL,ROBOT_2,A_2,F,V,false,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V); precond(AL,ROBOT_2,A_2,F,V,false); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#external seq_achieve_fgoals(step). [false]
enforce_achieve_fgoals(step) :- achieve_fgoals = true.
enforce_achieve_fgoals(step) :- 0 <= S; S <= step; seq_achieve_fgoals(S).
goal_satisfied(AL,F,V,true,step) :- final_goal(AL,F,V,true); holds(AL,F,V,step); fluent(AL,_,F,V); pl(AL); enforce_achieve_fgoals(step).
goal_satisfied(AL,F,V,false,step) :- final_goal(AL,F,V,false); not holds(AL,F,V,step); fluent(AL,_,F,V); pl(AL); enforce_achieve_fgoals(step).
incomplete_plan(step) :- final_goal(AL,F,V,B); not goal_satisfied(AL,F,V,B,step); fluent(AL,_,F,V); pl(AL); boolean(B); enforce_achieve_fgoals(step).
sub_goal(AL,ROBOT,A,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V,step); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); AL != 1; step > start.
sub_goal(AL,ROBOT,A,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); AL != 1; step > start.
#program optimisation_module(step, start, minimise_length, minimise_actions, minimise_cost, preempt_pos_fgoals, preempt_neg_fgoals, order_fgoals_achievement).
:~ occurs(AL,step); incomplete_plan((step-1)); pl(AL); step > start; minimise_length = true. [1@3,step]
:~ occurs(AL,ROBOT,A,step); action(AL,_,ROBOT,A); incomplete_plan((step-1)); pl(AL); step > start; minimise_actions = true. [1@2,ROBOT,A,step]
#heuristic occurs(AL,ROBOT,A,step) : action(AL,_,ROBOT,A); effect(AL,ROBOT,A,F,V); fluent(AL,inertial,F,V); final_goal(AL,F,V,true); pl(AL); step > start; preempt_pos_fgoals = true. [10@1,true]
#heuristic occurs(AL,ROBOT,A,step) : action(AL,_,ROBOT,A); effect(AL,ROBOT,A,F,V); fluent(AL,inertial,F,V); final_goal(AL,F,V,false); pl(AL); step > start; preempt_neg_fgoals = true. [10@0,false]
#program check(step).
#external query(step). [false]
#false :- incomplete_plan(step); query(step).
#program conformance_module(step, start, first, last, type, yield).
#external current_last_sgoals(I,step) : sgoals_index(I); yield = true. [false]
include_sgoals(I,step) :- I <= I_L; S <= step; current_last_sgoals(I_L,S); sgoals_index(I).
include_sgoals(I,step) :- sgoals_index(I); yield = false.
sgoals_index((first..last)).
current_sub_goal((AL+1),ROBOT,A,F,V,first,start) :- sub_goal((AL+1),ROBOT,A,F,V,first); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
sub_goal_satisfied((AL+1),ROBOT,A,F,V,I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,(step-1)); holds((AL+1),F,V,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,(step-1)); not sub_goal_satisfied((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); type = sequential; pl(AL).
unachieved_sgoals((AL+1),I_SG,step) :- current_sub_goal_index((AL+1),I_SG,(step-1)); sub_goal((AL+1),ROBOT,A,F,V,I_SG); not sub_goal_satisfied((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,(step-1)); unachieved_sgoals((AL+1),I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); type = simultaneous; pl(AL).
current_sub_goal((AL+1),ROBOT_1,A_1,F_1,V_1,(I_SG+1),step) :- include_sgoals((I_SG+1),step); sub_goal((AL+1),ROBOT_1,A_1,F_1,V_1,(I_SG+1)); current_sub_goal_index((AL+1),I_SG,(step-1)); not current_sub_goal_index((AL+1),I_SG,step); action((AL+1),_,ROBOT_1,A_1); fluent((AL+1),inertial,F_1,V_1); pl(AL).
sgoals_ach_at((AL+1),I_SG,step) :- current_sub_goal_index((AL+1),I_SG,(step-1)); not current_sub_goal_index((AL+1),I_SG,step); pl(AL).
current_sub_goal_index((AL+1),I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
incomplete_plan(step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
#program goal_abstraction_module.
holds(AL,F,V,0) :- final_goal(AL,F,V,true); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
not holds(AL,F,V,0) :- final_goal(AL,F,V,false); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
final_goal(AL,F,V,true) :- holds(AL,F,V,0); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
final_goal(AL,F,V,false) :- not holds(AL,F,V,0); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
{ holds(AL,F,V,0) } :- goal_fluent(AL,F); fluent(AL,inertial,F,V); al(AL).
#false :- not 1 = { holds(AL,F,V,0): fluent(AL,_,F,V) }; goal_fluent(AL,F); fluent(AL,_,F,_); al(AL).
holds(AL,F,false,0) :- not holds(AL,F,true,0); goal_fluent(AL,F); fluent(AL,defined,F,B); boolean(B); al(AL).
#program domain_sorts.
#const abstraction_max = 3.
#const reduc = 3.
#const conde = 2.
#const groun = 1.
class(3,robot).
class(3,armed_robot).
class(3,location).
class(3,room).
class(3,object).
class(3,grounded).
class(3,graspable).
class(3,placeable).
class(3,block).
class(3,surface).
class(3,table).
class(3,colour).
class(3,manipulator_arm).
class(3,grasper).
class(2,door).
class(2,handle).
class(2,configurable).
class(2,extensible).
class(1,cell).
class(1,manipulator_limb).
class(1,manipulator_end).
class(1,side).
super_class(robot,armed_robot).
super_class(location,room).
super_class(location,cell).
super_class(object,robot).
super_class(object,manipulator_arm).
super_class(object,manipulator_limb).
super_class(object,manipulator_end).
super_class(object,table).
super_class(object,side).
super_class(object,block).
super_class(object,grounded).
super_class(grounded,handle).
super_class(configurable,extensible).
super_class(configurable,grasper).
super_class(configurable,door).
super_class(extensible,manipulator_arm).
super_class(extensible,manipulator_limb).
super_class(grasper,manipulator_arm).
super_class(grasper,manipulator_end).
super_class(graspable,block).
super_class(graspable,handle).
super_class(placeable,block).
super_class(surface,table).
super_class(surface,side).
super_class(surface,block).
override_class(manipulator_arm,manipulator_end,grasper).
override_class(manipulator_arm,manipulator_limb,extensible).
override_class(room,cell,location).
override_class(table,side,surface).
state(AL,extensible,extended) :- AL < reduc; al(AL).
state(AL,extensible,retracted) :- AL < reduc; al(AL).
state(AL,manipulator_end,aligned_with(OBJ)) :- insta_of(AL,graspable,OBJ); class(AL,manipulator_end); AL < reduc; al(AL).
state(AL,manipulator_end,aligned_with(nothing)) :- AL < reduc; al(AL).
state(AL,door,open) :- AL < reduc; al(AL).
state(AL,door,closed) :- AL < reduc; al(AL).
static(AL,connected(L_1,L_2)) :- insta_of(AL,location,L_1); insta_of(AL,location,L_2); al(AL).
static(AL,connected_by_door(D,L_1,L_2)) :- insta_of(AL,door,D); insta_of(AL,location,L_1); insta_of(AL,location,L_2); AL < reduc; al(AL).
static(AL,in(OBJ,L)) :- insta_of(AL,object,OBJ); insta_of(AL,grounded,OBJ); insta_of(AL,location,L); AL < reduc; al(AL).
static(AL,colour_of(BLOCK,COLOUR)) :- insta_of(AL,block,BLOCK); insta_of(AL,colour,COLOUR); al(AL).
fluent(AL_1,inertial,in(OBJ),L) :- insta_of(AL_1,location,L); insta_of(AL_2,object,OBJ); OBJ != nothing; not insta_of(AL_2,grounded,OBJ); sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,on(OBJ),SURFACE) :- OBJ != SURFACE; insta_of(AL_1,surface,SURFACE); insta_of(AL_2,placeable,OBJ); sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,grasping(DESC),OBJ) :- insta_of(AL_1,graspable,OBJ); insta_of(AL_2,grasper,DESC); sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,configuration(DESC),STATE) :- state_of(AL_1,DESC,STATE); insta_of(AL_2,configurable,DESC); AL_1 < reduc; AL_2 < reduc; sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,configuration(D),STATE) :- state_of(AL_1,D,STATE); insta_of(AL_2,door,D); AL_1 < reduc; AL_2 < reduc; sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL,defined,tower_base(BASE),B) :- insta_of(AL,block,BASE); sl(AL); boolean(B).
fluent(AL,defined,in_tower(BASE,BLOCK),B) :- insta_of(AL,block,BASE); insta_of(AL,block,BLOCK); sl(AL); boolean(B).
fluent(AL,defined,unordered_tower(BASE),B) :- insta_of(AL,block,BASE); sl(AL); boolean(B).
fluent(AL,defined,complete(COLOUR),B) :- insta_of(AL,colour,COLOUR); sl(AL); boolean(B).
action(AL,sequential,ROBO,move(L)) :- insta_of(AL,robot,ROBO); insta_of(AL,location,L); sl(AL).
action(AL,concurrent,ROBO,grasp(DESC,OBJ)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; sl(AL).
action(AL,concurrent,ROBO,release(DESC,OBJ)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; sl(AL).
action(AL,concurrent,ROBO,configure(DESC,STATE)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,configurable,DESC); state_of(AL,DESC,STATE); AL < reduc; sl(AL).
action(AL,concurrent,ROBO,put(DESC,OBJ,SURFACE)) :- OBJ != SURFACE; SURFACE != nothing; desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); sl(AL).
action(AL,concurrent,ROBO,lift(DESC,OBJ)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); sl(AL).
action(AL,sequential,ROBO,actuate(DESC,D)) :- insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,door,D); AL < reduc; sl(AL).
#program action_effects(t).
effect(AL,ROBO,move(L),in(ROBO),L) :- action(AL,_,ROBO,move(L)); fluent(AL,inertial,in(ROBO),L); insta_of(AL,robot,ROBO); insta_of(AL,location,L); pl(AL).
effect(AL,ROBO,grasp(DESC,OBJ),grasping(DESC),OBJ) :- action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; pl(AL).
effect(AL,ROBO,release(DESC,OBJ),grasping(DESC),nothing) :- action(AL,_,ROBO,release(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); pl(AL).
effect(AL,ROBO,release(END,OBJ),configuration(END),aligned_with(nothing)) :- action(AL,_,ROBO,release(END,OBJ)); fluent(AL,inertial,configuration(END),aligned_with(nothing)); desce_of(AL,ROBO,END); insta_of(AL,armed_robot,ROBO); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); state_of(AL,END,aligned_with(nothing)); AL < reduc; pl(AL).
effect(AL,ROBO,configure(DESC,STATE),configuration(DESC),STATE) :- action(AL,_,ROBO,configure(DESC,STATE)); fluent(AL,inertial,configuration(DESC),STATE); desce_of(AL,ROBO,DESC); insta_of(AL,robot,ROBO); insta_of(AL,configurable,DESC); state_of(AL,DESC,STATE); AL < reduc; pl(AL).
effect(AL,ROBO,configure(ARM,retracted),configuration(END),aligned_with(nothing),t) :- holds(AL,grasping(END),nothing,(t-1)); action(AL,_,ROBO,configure(ARM,retracted)); fluent(AL,inertial,configuration(END),aligned_with(nothing)); desce_of(AL,ROBO,ARM); desce_of(AL,ROBO,END); siblings(AL,ARM,END); insta_of(AL,armed_robot,ROBO); insta_of(AL,extensible,ARM); insta_of(AL,manipulator_end,END); state_of(AL,END,aligned_with(nothing)); AL < reduc; pl(AL).
effect(AL,ROBO,put(DESC,OBJ,SURFACE),on(OBJ),SURFACE) :- action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,on(OBJ),SURFACE); OBJ != SURFACE; SURFACE != nothing; desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); pl(AL).
effect(AL,ROBO,lift(DESC,OBJ),on(OBJ),nothing) :- action(AL,_,ROBO,lift(DESC,OBJ)); fluent(AL,inertial,on(OBJ),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); pl(AL).
effect(AL,ROBO,actuate(DESC,D),configuration(D),STATE_1,t) :- holds(AL,configuration(D),STATE_2,(t-1)); fluent(AL,inertial,configuration(D),STATE_1); fluent(AL,inertial,configuration(D),STATE_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,door,D); state_of(AL,D,STATE_1); state_of(AL,D,STATE_2); STATE_1 != STATE_2; AL < reduc; pl(AL).
#program action_preconditions(t).
1 = { precond(AL,ROBO,move(P_2),in(ROBO),P_1,true,t): is(AL,connected(P_1,P_2)), fluent(AL,inertial,in(ROBO),P_1), static(AL,connected(P_1,P_2)), P_1 != P_2, insta_of(AL,location,P_1) } :- action(AL,_,ROBO,move(P_2)); insta_of(AL,robot,ROBO); insta_of(AL,location,P_2); AL < reduc; pl(AL).
precond(AL,ROBO,move(L_2),configuration(D),open,true,t) :- holds(AL,in(ROBO),L_1,(t-1)); is(AL,connected_by_door(D,L_1,L_2)); L_1 != L_2; action(AL,_,ROBO,move(L_2)); fluent(AL,inertial,configuration(D),open); fluent(AL,_,in(ROBO),L_1); static(AL,connected_by_door(D,L_1,L_2)); insta_of(AL,robot,ROBO); insta_of(AL,location,L_1); insta_of(AL,location,L_2); insta_of(AL,door,D); AL < reduc; pl(AL).
1 = { precond(AL,ROBO,actuate(COMP,D),grasping(COMP),H,true,t): desce_of(AL,D,H), insta_of(AL,handle,H), action(AL,_,ROBO,actuate(COMP,D)), fluent(AL,inertial,grasping(COMP),H) } :- desce_of(AL,ROBO,COMP); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,COMP); insta_of(AL,door,D); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),in(ROBO),L,true) :- is(AL,in(OBJ,L)); action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,in(ROBO),L); static(AL,in(OBJ,L)); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,grounded,OBJ); insta_of(AL,location,L); AL < reduc; pl(AL).
precond(AL,ROBO,move(L),configuration(DESC),retracted,true) :- action(AL,_,ROBO,move(L)); fluent(AL,inertial,configuration(DESC),retracted); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,extensible,DESC); insta_of(AL,location,L); state_of(AL,DESC,retracted); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),in(OBJ),L,true,t) :- holds(AL,in(ROBO),L,(t-1)); OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,in(OBJ),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),in(ROBO),L,true,t) :- holds(AL,in(OBJ),L,(t-1)); OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,in(OBJ),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),grasping(DESC),nothing,true) :- OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ_1),on(OBJ_2),OBJ_1,false) :- OBJ_1 != OBJ_2; OBJ_1 != nothing; action(AL,_,ROBO,grasp(DESC,OBJ_1)); fluent(AL,inertial,on(OBJ_2),OBJ_1); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ_1); insta_of(AL,surface,OBJ_1); insta_of(AL,placeable,OBJ_2); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),configuration(DESC),extended,true) :- OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,configuration(DESC),extended); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,extensible,DESC); insta_of(AL,graspable,OBJ); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(DESC_1,OBJ),configuration(DESC_2),extended,true) :- OBJ != nothing; action(AL,_,ROBO,grasp(DESC_1,OBJ)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC_1); not insta_of(AL,extensible,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,graspable,OBJ); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(END,OBJ),configuration(END),aligned_with(OBJ),true) :- OBJ != nothing; action(AL,_,ROBO,grasp(END,OBJ)); fluent(AL,inertial,configuration(END),aligned_with(OBJ)); desce_of(AL,ROBO,END); insta_of(AL,armed_robot,ROBO); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); state_of(AL,END,aligned_with(OBJ)); AL < reduc; pl(AL).
precond(AL,ROBO,release(DESC,OBJ),grasping(DESC),OBJ,true) :- OBJ != nothing; action(AL,_,ROBO,release(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); pl(AL).
precond(AL,ROBO,release(DESC,OBJ),configuration(DESC),extended,true) :- OBJ != nothing; action(AL,_,ROBO,release(DESC,OBJ)); fluent(AL,inertial,configuration(DESC),extended); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); state_of(AL,DESC,extended); pl(AL); t > 0.
precond(AL,ROBO,release(DESC_1,OBJ),configuration(DESC_2),extended,true) :- OBJ != nothing; action(AL,_,ROBO,release(DESC_1,OBJ)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC_1); not insta_of(AL,extensible,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,graspable,OBJ); pl(AL).
precond(AL,ROBO,configure(DESC_1,STATE),configuration(DESC_2),extended,true) :- action(AL,_,ROBO,configure(DESC_1,STATE)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); desce_of(AL,ROBO,ARM); child_of(AL,ARM,DESC_1); child_of(AL,ARM,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,configurable,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,manipulator_arm,ARM); state_of(AL,DESC_1,STATE); AL < reduc; pl(AL).
precond(AL,ROBO,configure(DESC,aligned_with(OBJ)),grasping(DESC),nothing,true) :- action(AL,_,ROBO,configure(DESC,aligned_with(OBJ))); fluent(AL,inertial,grasping(DESC),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,manipulator_end,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; state_of(AL,DESC,aligned_with(OBJ)); AL < reduc; pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),in(SURFACE),L,true,t) :- holds(AL,in(ROBO),L,(t-1)); action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,in(SURFACE),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),in(ROBO),L,true,t) :- holds(AL,in(SURFACE),L,(t-1)); action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,in(SURFACE),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,put(DESC,OBJ_1,BLOCK),on(OBJ_2),BLOCK,false) :- OBJ_1 != OBJ_2; action(AL,_,ROBO,put(DESC,OBJ_1,SURFACE)); fluent(AL,inertial,on(OBJ_2),BLOCK); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ_1); insta_of(AL,placeable,OBJ_2); insta_of(AL,block,BLOCK); pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),grasping(DESC),OBJ,true) :- OBJ != SURFACE; OBJ != nothing; SURFACE != nothing; action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); pl(AL).
precond(AL,ROBO_1,put(DESC_1,OBJ_1,OBJ_2),grasping(DESC_2),OBJ_2,false) :- OBJ_1 != OBJ_2; DESC_1 != DESC_2; action(AL,_,ROBO,put(DESC_1,OBJ_1,OBJ_2)); fluent(AL,inertial,grasping(DESC_2),OBJ_2); desce_of(AL,ROBO_1,DESC_1); desce_of(AL,ROBO_2,DESC_2); insta_of(AL,armed_robot,ROBO_1); insta_of(AL,armed_robot,ROBO_2); insta_of(AL,grasper,DESC_1); insta_of(AL,grasper,DESC_2); insta_of(AL,placeable,OBJ_1); insta_of(AL,surface,OBJ_2); insta_of(AL,graspable,OBJ_2); pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),configuration(DESC),extended,true) :- action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,configuration(DESC),extended); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,extensible,DESC); insta_of(AL,graspable,OBJ); insta_of(AL,surface,SURFACE); AL < reduc; pl(AL).
precond(AL,ROBO,put(DESC_1,OBJ,SURFACE),configuration(DESC_2),extended,true) :- action(AL,_,ROBO,put(DESC_1,OBJ,SURFACE)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC_1); not insta_of(AL,extensible,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,graspable,OBJ); insta_of(AL,surface,SURFACE); AL < reduc; pl(AL).
precond(AL,ROBO,lift(DESC,OBJ_1),on(OBJ_2),OBJ_1,false) :- OBJ_1 != OBJ_2; action(AL,_,ROBO,lift(DESC,OBJ_1)); fluent(AL,inertial,on(OBJ_2),OBJ_1); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ_1); insta_of(AL,surface,OBJ_1); insta_of(AL,placeable,OBJ_2); pl(AL).
precond(AL,ROBO,lift(DESC,OBJ),grasping(DESC),OBJ,true) :- OBJ != SURFACE; action(AL,_,ROBO,lift(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,surface,SURFACE); pl(AL).
#program variable_relations(t).
#false :- holds(AL,grasping(DESC),OBJ,t); holds(AL,in(ROBO),L,t); not holds(AL,in(OBJ),L,t): not insta_of(AL,grounded,OBJ), fluent(AL,inertial,in(OBJ),L); not is(AL,in(OBJ,L)): insta_of(AL,grounded,OBJ), static(AL,in(OBJ,L)); fluent(AL,inertial,grasping(DESC),OBJ); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,location,L); sl(AL).
#false :- holds(AL,configuration(END),aligned_with(OBJ),t); holds(AL,in(ROBO),L,t); not holds(AL,in(OBJ),L,t): not insta_of(AL,grounded,OBJ), fluent(AL,inertial,in(OBJ),L); not is(AL,in(OBJ,L)): insta_of(AL,grounded,OBJ), static(AL,in(OBJ,L)); fluent(AL,inertial,configuration(END),aligned_with(OBJ)); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,END); insta_of(AL,robot,ROBO); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,location,L); state_of(AL,END,aligned_with(OBJ)); sl(AL).
#false :- holds(AL,grasping(END),OBJ,t); not holds(AL,configuration(END),aligned_with(OBJ),t); fluent(AL,inertial,grasping(END),OBJ); fluent(AL,inertial,configuration(END),aligned_with(OBJ)); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); OBJ != nothing; state_of(AL,END,aligned_with(OBJ)); sl(AL).
#false :- holds(AL,grasping(DESC),OBJ_1,t); holds(AL,on(OBJ_2),OBJ_1,t); fluent(AL,inertial,grasping(DESC),OBJ_1); fluent(AL,inertial,on(OBJ_2),OBJ_1); desce_of(AL,ROBO,DESC); insta_of(AL,robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ_1); OBJ_1 != nothing; insta_of(AL,surface,OBJ_1); insta_of(AL,placeable,OBJ_2); sl(AL).
#false :- holds(AL,on(OBJ),SURFACE,t); holds(AL,in(SURFACE),L,t); not holds(AL,in(OBJ),L,t); fluent(AL,inertial,on(OBJ),SURFACE); fluent(AL,inertial,in(SURFACE),L); fluent(AL,inertial,in(OBJ),L); insta_of(AL,location,L); insta_of(AL,location,L); insta_of(AL,surface,SURFACE); insta_of(AL,object,OBJ); sl(AL).
#false :- holds(AL,on(BLOCK_1),BLOCK_2,t); holds(AL,on(BLOCK_2),nothing,t); fluent(AL,inertial,on(BLOCK_1),BLOCK_2); fluent(AL,inertial,on(BLOCK_2),nothing); insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); sl(AL).
#false :- holds(AL,on(BLOCK_1),BLOCK_3,t); holds(AL,on(BLOCK_2),BLOCK_3,t); fluent(AL,inertial,on(BLOCK_1),BLOCK_3); fluent(AL,inertial,on(BLOCK_2),BLOCK_3); BLOCK_1 != BLOCK_2; insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); insta_of(AL,block,BLOCK_3); sl(AL).
holds(AL,tower_base(BASE),true,t) :- holds(AL,on(BASE),TABLE,t); fluent(AL,defined,tower_base(BASE),true); fluent(AL,inertial,on(BASE),TABLE); insta_of(AL,block,BASE); insta_of(AL,table,TABLE); sl(AL).
holds(AL,tower_base(BASE),true,t) :- holds(AL,on(BASE),SURFACE,t); fluent(AL,defined,tower_base(BASE),true); fluent(AL,inertial,on(BASE),SURFACE); desce_of(AL,TABLE,SURFACE); insta_of(AL,block,BASE); insta_of(AL,surface,SURFACE); insta_of(AL,table,TABLE); sl(AL).
holds(AL,in_tower(BASE,BASE),true,t) :- holds(AL,tower_base(BASE),true,t); fluent(AL,defined,in_tower(BASE,BASE),true); fluent(AL,defined,tower_base(BASE),true); insta_of(AL,block,BASE); sl(AL).
holds(AL,in_tower(BLOCK_1,BLOCK_2),true,t) :- holds(AL,on(BLOCK_2),BLOCK_3,t); holds(AL,in_tower(BLOCK_1,BLOCK_3),true,t); fluent(AL,defined,in_tower(BLOCK_1,BLOCK_2),true); fluent(AL,defined,in_tower(BLOCK_1,BLOCK_3),true); fluent(AL,inertial,on(BLOCK_2),BLOCK_3); BLOCK_1 != BLOCK_2; insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); insta_of(AL,block,BLOCK_3); sl(AL).
holds(AL,unordered_tower(BASE),true,t) :- holds(AL,on(BLOCK_1),BLOCK_2,t); holds(AL,in_tower(BASE,BLOCK_1),true,t); holds(AL,in_tower(BASE,BLOCK_2),true,t); holds(AL,tower_base(BASE),true,t); fluent(AL,defined,unordered_tower(BASE),true); fluent(AL,defined,in_tower(BASE,BLOCK_1),true); fluent(AL,defined,in_tower(BASE,BLOCK_2),true); fluent(AL,defined,tower_base(BASE),true); fluent(AL,inertial,on(BLOCK_1),BLOCK_2); BLOCK_1 = (block,N_1); number(N_1); BLOCK_2 = (block,N_2); number(N_2); BLOCK_1 != BLOCK_2; N_1 > N_2; insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); insta_of(AL,block,BASE); sl(AL).
holds(AL,complete(COLOUR),true,t) :- N = #count { BLOCK: holds(AL,in_tower(BASE,BLOCK),true,t), is(AL,colour_of(BLOCK,COLOUR)), fluent(AL,defined,in_tower(BASE,BLOCK),true), static(AL,colour_of(BLOCK,COLOUR)), insta_of(AL,block,BLOCK) }; N = #count { BLOCK: is(AL,colour_of(BLOCK,COLOUR)), static(AL,colour_of(BLOCK,COLOUR)), insta_of(AL,block,BLOCK) }; holds(AL,unordered_tower(BASE),false,t); holds(AL,tower_base(BASE),true,t); fluent(AL,defined,unordered_tower(BASE),true); fluent(AL,defined,tower_base(BASE),true); is(AL,colour_of(BASE,COLOUR)); static(AL,colour_of(BASE,COLOUR)); insta_of(AL,colour,COLOUR); insta_of(AL,block,BASE); sl(AL).
#program abstraction_mappings(t).
is(AL_1,connected(L_1,L_2)) :- is(AL_2,connected(L_1_C,L_2_C)); static(AL_1,connected(L_1,L_2)); static(AL_2,connected(L_1_C,L_2_C)); L_1 != L_2; desce_of(AL_2,L_1,L_1_C); desce_of(AL_2,L_2,L_2_C); insta_of(AL_1,location,L_1); insta_of(AL_1,location,L_2); insta_of(AL_2,location,L_1_C); insta_of(AL_2,location,L_2_C); al(AL_1); al(AL_2); AL_1 >= AL_2.
is(AL_1,connected(L_1,L_2)) :- is(AL_2,connected(L_1,L_2)); static(AL_1,connected(L_1,L_2)); static(AL_2,connected(L_1,L_2)); L_1 != L_2; insta_of(AL_1,location,L_1); insta_of(AL_1,location,L_2); insta_of(AL_2,location,L_1); insta_of(AL_2,location,L_2); al(AL_1); al(AL_2); AL_1 >= AL_2.
is(AL_1,connected_by_door(D,L_1,L_2)) :- is(AL_2,connected_by_door(D,L_1_C,L_2_C)); static(AL_1,connected_by_door(D,L_1,L_2)); static(AL_2,connected_by_door(D,L_1_C,L_2_C)); L_1 != L_2; desce_of(AL_2,L_1,L_1_C); desce_of(AL_2,L_2,L_2_C); insta_of(AL_1,door,D); insta_of(AL_2,door,D); insta_of(AL_1,location,L_1); insta_of(AL_1,location,L_2); insta_of(AL_2,location,L_1_C); insta_of(AL_2,location,L_2_C); al(AL_1); al(AL_2); AL_1 >= AL_2.
is(AL_1,in(OBJ,L_1)) :- is(AL_2,in(OBJ,L_2)); static(AL_1,in(OBJ,L_1)); static(AL_2,in(OBJ,L_2)); desce_of(AL_2,L_1,L_2); insta_of(AL_1,location,L_1); insta_of(AL_1,object,OBJ); insta_of(AL_1,grounded,OBJ); insta_of(AL_1,location,L_1); insta_of(AL_2,location,L_2); al(AL_1); al(AL_2); AL_1 >= AL_2.
holds(AL_1,in(OBJ),L_1,t) :- holds(AL_2,in(OBJ),L_2,t); fluent(AL_1,inertial,in(OBJ),L_1); fluent(AL_2,inertial,in(OBJ),L_2); desce_of(AL_2,L_1,L_2); insta_of(AL_1,location,L_1); insta_of(AL_2,location,L_2); insta_of(AL_3,object,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
holds(AL_1,in(OBJ),L,t) :- holds(AL_2,in(OBJ),L,t); fluent(AL_1,inertial,in(OBJ),L); fluent(AL_2,inertial,in(OBJ),L); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,object,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
holds(AL_1,in(DESC),L,t) :- holds(AL_2,in(OBJ),L,t); fluent(AL_1,inertial,in(DESC),L); fluent(AL_2,inertial,in(OBJ),L); desce_of(AL_2,OBJ,DESC); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,object,OBJ); insta_of(AL_4,_,DESC); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_2; sl(AL_4); AL_4 >= AL_1.
holds(AL_1,in(OBJ),L,t) :- holds(AL_2,in(DESC),L,t); fluent(AL_1,inertial,in(OBJ),L); fluent(AL_2,inertial,in(DESC),L); desce_of(AL_2,OBJ,DESC); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,object,OBJ); insta_of(AL_4,_,DESC); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_2.
holds(AL_1,in(OBJ),L,t) :- holds(AL_2,in(ROBO),L,t); holds(AL_3,grasping(DESC),OBJ,t); fluent(AL_1,inertial,in(OBJ),L); fluent(AL_2,inertial,in(ROBO),L); fluent(AL_3,inertial,grasping(DESC),OBJ); desce_of(AL_2,ROBO,DESC); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,graspable,OBJ); OBJ != nothing; insta_of(AL_4,grasper,DESC); insta_of(AL_5,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_3; sl(AL_5); AL_5 >= AL_3.
holds(AL_1,grasping(DESC),OBJ_1,t) :- holds(AL_2,grasping(DESC),OBJ_2,t); fluent(AL_1,inertial,grasping(DESC),OBJ_1); fluent(AL_2,inertial,grasping(DESC),OBJ_2); desce_of(AL_2,ROBO,DESC); desce_of(AL_2,OBJ_1,OBJ_2); insta_of(AL_1,graspable,OBJ_1); insta_of(AL_2,graspable,OBJ_2); insta_of(AL_3,grasper,DESC); insta_of(AL_4,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_1.
holds(AL_1,grasping(DESC_1),OBJ,t) :- holds(AL_2,grasping(DESC_2),OBJ,t); fluent(AL_1,inertial,grasping(DESC_1),OBJ); fluent(AL_2,inertial,grasping(DESC_2),OBJ); desce_of(AL_2,ROBO,DESC_1); desce_of(AL_2,ROBO,DESC_2); desce_of(AL_2,DESC_1,DESC_2); insta_of(AL_1,graspable,OBJ); insta_of(AL_2,graspable,OBJ); insta_of(AL_3,grasper,DESC_1); insta_of(AL_4,grasper,DESC_2); insta_of(AL_5,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_2; sl(AL_5); AL_5 >= AL_1.
holds(AL_1,grasping(DESC),OBJ,t) :- holds(AL_2,grasping(DESC),OBJ,t); fluent(AL_1,inertial,grasping(DESC),OBJ); fluent(AL_2,inertial,grasping(DESC),OBJ); desce_of(AL_2,ROBO,DESC); insta_of(AL_1,graspable,OBJ); insta_of(AL_2,graspable,OBJ); insta_of(AL_3,grasper,DESC); insta_of(AL_4,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_1; boolean(B).
holds(AL_1,configuration(DESC_1),STATE,t) :- holds(AL_2,configuration(DESC_2),STATE,t); fluent(AL_1,inertial,configuration(DESC_1),STATE); fluent(AL_2,inertial,configuration(DESC_2),STATE); desce_of(AL_2,DESC_1,DESC_2); state_of(AL_1,DESC_1,STATE); state_of(AL_2,DESC_2,STATE); insta_of(AL_1,configurable,DESC_1); insta_of(AL_2,configurable,DESC_2); sl(AL_1); sl(AL_2); AL_1 >= AL_2.
holds(AL_1,configuration(DESC),STATE,t) :- holds(AL_2,configuration(DESC),STATE,t); fluent(AL_1,inertial,configuration(DESC),STATE); fluent(AL_2,inertial,configuration(DESC),STATE); state_of(AL_1,DESC,STATE); state_of(AL_2,DESC,STATE); insta_of(AL_1,configurable,DESC); insta_of(AL_2,configurable,DESC); sl(AL_1); sl(AL_2); AL_1 >= AL_2.
holds(AL_1,on(OBJ),SURFACE_1,t) :- holds(AL_2,on(OBJ),SURFACE_2,t); fluent(AL_1,inertial,on(OBJ),SURFACE_1); fluent(AL_2,inertial,on(OBJ),SURFACE_2); desce_of(AL_2,SURFACE_1,SURFACE_2); insta_of(AL_1,surface,SURFACE_1); insta_of(AL_2,surface,SURFACE_2); insta_of(AL_3,placeable,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
holds(AL_1,on(OBJ),SURFACE,t) :- holds(AL_2,on(OBJ),SURFACE,t); fluent(AL_1,inertial,on(OBJ),SURFACE); fluent(AL_2,inertial,on(OBJ),SURFACE); insta_of(AL_1,surface,SURFACE); insta_of(AL_2,surface,SURFACE); insta_of(AL_3,placeable,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
#program static_state.
is(1,connected((starting_room,1),(hallway,1))).
is(1,connected((store_room,1),(hallway,0))).
is(1,connected((hallway,2),(puzzle_room,0))).
is(1,connected_by_door(store_room_door,(store_room,1),(hallway,0))).
is(1,connected_by_door(puzzle_room_door,(hallway,2),(puzzle_room,0))).
is(1,in(store_room_door_handle_inner,(store_room,1))).
is(1,in(store_room_door_handle_outer,(hallway,0))).
is(1,in(starting_room_door_handle_inner,(starting_room,1))).
is(1,in(starting_room_door_handle_outer,(hallway,1))).
is(1,in(puzzle_room_door_handle_inner,(puzzle_room,0))).
is(1,in(puzzle_room_door_handle_outer,(hallway,2))).
is(AL,colour_of((BLOCK,N),red)) :- static(AL,colour_of((BLOCK,N),red)); insta_of(AL,block,(BLOCK,N)); N <= 3; al(AL).
is(AL,colour_of((BLOCK,N),blue)) :- static(AL,colour_of((BLOCK,N),blue)); insta_of(AL,block,(BLOCK,N)); N > 3; N <= 6; al(AL).
is(1,connected((A,X_1),(A,X_2))) :- insta_of(1,cell,(A,X_1)); insta_of(1,cell,(A,X_2)); X_2 = (X_1+1).
is(1,connected(C_1,C_2)) :- is(1,connected(C_2,C_1)); insta_of(1,cell,C_1); insta_of(1,cell,C_2).
is(1,connected_by_door(D,C_1,C_2)) :- is(1,connected_by_door(D,C_2,C_1)); insta_of(1,door,D); insta_of(1,cell,C_1); insta_of(1,cell,C_2).
#program initial_state.
holds(1,in(talos),(starting_room,0),0).
holds(AL,grasping(DESC),nothing,0) :- fluent(AL,inertial,grasping(DESC),nothing); insta_of(AL,grasper,DESC); al(AL).
holds(AL,configuration(DESC),retracted,0) :- fluent(AL,inertial,configuration(DESC),retracted); insta_of(AL,extensible,DESC); sl(AL).
holds(1,configuration(END),aligned_with(nothing),0) :- fluent(AL,inertial,configuration(END),aligned_with(nothing)); insta_of(AL,manipulator_end,END); state_of(AL,END,aligned_with(nothing)); sl(AL).
holds(1,configuration(DOOR),closed,0) :- fluent(AL,inertial,configuration(DOOR),closed); insta_of(AL,door,DOOR); state_of(AL,DOOR,closed); sl(AL).
holds(1,in(puzzle_room_table),(puzzle_room,1),0).
holds(1,on((block,1)),puzzle_room_table_left,0).
holds(1,on((block,2)),puzzle_room_table_right,0).
holds(1,on((block,3)),(block,1),0).
holds(1,in((block,4)),(store_room,0),0).
holds(1,in((block,5)),(store_room,0),0).
holds(1,in((block,6)),(store_room,0),0).
holds(1,on((block,4)),nothing,0).
holds(1,on((block,5)),nothing,0).
holds(1,on((block,6)),nothing,0).
#program goal_state.
goal_fluent(AL,complete(COLOUR)) :- insta_of(AL,colour,COLOUR); al(AL).
goal_fluent(AL,on((block,3))) :- al(AL).
goal_fluent(AL,on((block,6))) :- al(AL).
final_goal(AL,complete(COLOUR),true,true) :- insta_of(AL,colour,COLOUR); al(AL).
final_goal(1,on((block,3)),puzzle_room_table_left,true).
final_goal(1,on((block,6)),puzzle_room_table_right,true).
#program entities.
entity(armed_robot,talos).
entity(manipulator_arm,manipulator_arm_1).
entity(manipulator_limb,manipulator_limb_1).
entity(manipulator_end,manipulator_end_1).
entity(manipulator_arm,manipulator_arm_2).
entity(manipulator_limb,manipulator_limb_2).
entity(manipulator_end,manipulator_end_2).
number((1..6)).
entity(block,(block,N)) :- number(N).
entity(room,starting_room).
entity(room,store_room).
entity(room,puzzle_room).
entity(room,hallway).
x((0..3)).
size(starting_room,2).
size(store_room,2).
size(hallway,3).
size(puzzle_room,2).
entity(cell,(ROOM,X)) :- entity(room,ROOM); size(ROOM,MAX); X < MAX; x(X).
entity(door,store_room_door).
entity(door,starting_room_door).
entity(door,puzzle_room_door).
entity(handle,store_room_door_handle_inner).
entity(handle,store_room_door_handle_outer).
entity(handle,starting_room_door_handle_inner).
entity(handle,starting_room_door_handle_outer).
entity(handle,puzzle_room_door_handle_inner).
entity(handle,puzzle_room_door_handle_outer).
entity(table,puzzle_room_table).
entity(side,puzzle_room_table_left).
entity(side,puzzle_room_table_right).
entity(colour,red).
entity(colour,blue).
entity(surface,nothing).
entity(graspable,nothing).
ancestry_relation(talos,manipulator_arm_1).
ancestry_relation(talos,manipulator_arm_2).
ancestry_relation(manipulator_arm_1,manipulator_limb_1).
ancestry_relation(manipulator_arm_2,manipulator_limb_2).
ancestry_relation(manipulator_arm_1,manipulator_end_1).
ancestry_relation(manipulator_arm_2,manipulator_end_2).
ancestry_relation(ROOM,(ROOM,X)) :- entity(room,ROOM); entity(cell,(ROOM,X)); x(X).
ancestry_relation(store_room_door,store_room_door_handle_inner).
ancestry_relation(store_room_door,store_room_door_handle_outer).
ancestry_relation(starting_room_door,starting_room_door_handle_inner).
ancestry_relation(starting_room_door,starting_room_door_handle_outer).
ancestry_relation(puzzle_room_door,puzzle_room_door_handle_inner).
ancestry_relation(puzzle_room_door,puzzle_room_door_handle_outer).
ancestry_relation(puzzle_room_table,puzzle_room_table_left).
ancestry_relation(puzzle_room_table,puzzle_room_table_right)., ASH #1)

[15-09-2021_15-49-16] INFO :: ASH Planner Main #1 >> Attempting to initialise hierarchical planning problem...

[15-09-2021_15-49-16] INFO :: ASH Planner Main #1 >> Generating initial states...

[15-09-2021_15-49-16] DEBUG :: Logic Program ASH #1 >> Creating copy of self: rename = Main #1 || Generate Initial States

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Instantiating logic program...

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Setting input storing variables:
	solver_options = []
	assumptions = []
	context = None
	incrementor = None
	base_parts = []
	inc_parts = []

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Output storing variables reset.

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Logic program instantiated.

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Entering new one-shot solve call:
('self', LogicProgram(#program base.
#program abstraction_levels(planning_level, mode).
al((1..abstraction_max)).
pl(AL) :- AL = planning_level; al(AL).
sl(AL) :- AL = planning_level; mode = classical; al(AL).
sl(AL) :- AL >= planning_level; AL <= (planning_level+1); mode = refinement; al(AL).
sl(AL) :- AL >= planning_level; AL <= abstraction_max; mode = hierarchical; al(AL).
#program instance_module.
boolean(true;false).
insta_of(AL,CLS,EN) :- entity(CLS,EN); class(AL,CLS); al(AL).
insta_of(AL_3,CLS_1,EN) :- insta_of(AL_2,CLS_2,EN); super_class(CLS_1,CLS_2); entity(CLS_3,EN); class(AL_3,CLS_3); class(AL_1,CLS_1); AL_1 >= AL_2; al(AL_1); al(AL_2); al(AL_3).
insta_of((AL-1),CLS,EN) :- insta_of(AL,CLS,EN); not overridden((AL-1),CLS,EN); class(_,CLS); al(AL); al((AL-1)).
overridden((AL-1),CLS,EN_1) :- overridden_by((AL-1),CLS,EN_1,EN_2); insta_of(AL,CLS,EN_1); insta_of((AL-1),CLS,EN_2); class(_,CLS); al(AL); al((AL-1)).
overridden_by((AL-1),CLS_3,EN_1,EN_2) :- insta_of(AL,CLS_1,EN_1); insta_of((AL-1),CLS_2,EN_2); insta_of(AL,CLS_3,EN_1); insta_of((AL-1),CLS_3,EN_2); desce_of((AL-1),EN_1,EN_2); override_class(CLS_1,CLS_2,CLS_3); class(_,CLS_1); class(_,CLS_2); class(_,CLS_3); al(AL); al((AL-1)).
state_of(AL,EN,S) :- state(AL,CLS,S); insta_of(AL,CLS,EN); al(AL).
child_of(AL,EN,DESCE) :- ancestry_relation(EN,DESCE); insta_of(AL,_,EN); insta_of(AL,_,DESCE); al(AL).
desce_of(AL,EN,DESCE) :- child_of(AL,EN,DESCE); insta_of(AL,_,EN); insta_of(AL,_,DESCE); al(AL).
desce_of(AL,EN,DESCE_1) :- desce_of(AL,DESCE_2,DESCE_1); desce_of(AL,EN,DESCE_2); insta_of(AL,_,EN); insta_of(AL,_,DESCE_1); insta_of(AL,_,DESCE_2); al(AL).
has_desce(AL,EN) :- desce_of(AL,EN,DESCE); insta_of(AL,_,EN); insta_of(AL,_,DESCE); al(AL).
has_desce(AL,EN,CLS) :- desce_of(AL,EN,DESCE); insta_of(AL,_,EN); insta_of(AL,CLS,DESCE); al(AL).
siblings(AL,DESCE_1,DESCE_2) :- child_of(AL,EN,DESCE_1); child_of(AL,EN,DESCE_2); DESCE_1 != DESCE_2; insta_of(AL,_,EN); insta_of(AL,_,DESCE_1); insta_of(AL,_,DESCE_2); al(AL).
siblings(AL,DESCE_2,DESCE_1) :- siblings(AL,DESCE_1,DESCE_2); insta_of(AL,_,DESCE_1); insta_of(AL,_,DESCE_2); al(AL).
#program state_module(step, start).
{ holds(AL,F,V,step) } :- fluent(AL,inertial,F,V); sl(AL); step = start.
#false :- not 1 = { holds(AL,F,V,step): fluent(AL,_,F,V) }; fluent(AL,_,F,_); sl(AL).
holds(AL,F,V,step) :- holds(AL,F,V,(step-1)); not not holds(AL,F,V,step); fluent(AL,inertial,F,V); sl(AL); step > start.
holds(AL,F,false,step) :- not holds(AL,F,true,step); fluent(AL,defined,F,B); boolean(B); sl(AL).
#program plan_module(step, start, concurrency, achieve_fgoals).
{ occurs(AL,ROBOT,A,step): action(AL,_,ROBOT,A) } :- incomplete_plan((step-1)); pl(AL); step > start.
occurs(AL,ROBOT,step) :- occurs(AL,ROBOT,A,step); action(AL,_,ROBOT,A); pl(AL); step > start.
occurs(AL,step) :- occurs(AL,ROBOT,step); insta_of(AL,robot,ROBOT); pl(AL); step > start.
holds(AL,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V,step); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
holds(AL,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,true,step); not holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,true); not holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,false,step); holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,false); holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- not 1 = { occurs(AL,R,A,step): action(AL,_,ROBOT,A) }; incomplete_plan((step-1)); pl(AL); step > start; concurrency = false.
#false :- not 1 <= { occurs(AL,R,A,step): action(AL,_,ROBOT,A) }; incomplete_plan((step-1)); pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT,A_1,step); occurs(AL,ROBOT,A_2,step); A_1 != A_2; action(AL,_,ROBOT,A_1); action(AL,_,ROBOT,A_2); pl(AL); step > start; concurrency = false.
#false :- occurs(AL,ROBOT,A_1,step); occurs(AL,ROBOT,A_2,step); A_1 != A_2; action(AL,sequential,ROBOT,A_1); action(AL,_,ROBOT,A_2); pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); effect(AL,ROBOT_2,A_2,F,V_2,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; ROBOT_1 != ROBOT_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); effect(AL,ROBOT_2,A_2,F,V_2); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; ROBOT_1 != ROBOT_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1); effect(AL,ROBOT_2,A_2,F,V_2); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; ROBOT_1 != ROBOT_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); precond(AL,ROBOT_2,A_2,F,V_2,true,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); precond(AL,ROBOT_2,A_2,F,V_2,true); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V,step); precond(AL,ROBOT_2,A_2,F,V,false,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V,step); precond(AL,ROBOT_2,A_2,F,V,false); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1); precond(AL,ROBOT_2,A_2,F,V_2,true,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1); precond(AL,ROBOT_2,A_2,F,V_2,true); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V); precond(AL,ROBOT_2,A_2,F,V,false,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V); precond(AL,ROBOT_2,A_2,F,V,false); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#external seq_achieve_fgoals(step). [false]
enforce_achieve_fgoals(step) :- achieve_fgoals = true.
enforce_achieve_fgoals(step) :- 0 <= S; S <= step; seq_achieve_fgoals(S).
goal_satisfied(AL,F,V,true,step) :- final_goal(AL,F,V,true); holds(AL,F,V,step); fluent(AL,_,F,V); pl(AL); enforce_achieve_fgoals(step).
goal_satisfied(AL,F,V,false,step) :- final_goal(AL,F,V,false); not holds(AL,F,V,step); fluent(AL,_,F,V); pl(AL); enforce_achieve_fgoals(step).
incomplete_plan(step) :- final_goal(AL,F,V,B); not goal_satisfied(AL,F,V,B,step); fluent(AL,_,F,V); pl(AL); boolean(B); enforce_achieve_fgoals(step).
sub_goal(AL,ROBOT,A,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V,step); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); AL != 1; step > start.
sub_goal(AL,ROBOT,A,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); AL != 1; step > start.
#program optimisation_module(step, start, minimise_length, minimise_actions, minimise_cost, preempt_pos_fgoals, preempt_neg_fgoals, order_fgoals_achievement).
:~ occurs(AL,step); incomplete_plan((step-1)); pl(AL); step > start; minimise_length = true. [1@3,step]
:~ occurs(AL,ROBOT,A,step); action(AL,_,ROBOT,A); incomplete_plan((step-1)); pl(AL); step > start; minimise_actions = true. [1@2,ROBOT,A,step]
#heuristic occurs(AL,ROBOT,A,step) : action(AL,_,ROBOT,A); effect(AL,ROBOT,A,F,V); fluent(AL,inertial,F,V); final_goal(AL,F,V,true); pl(AL); step > start; preempt_pos_fgoals = true. [10@1,true]
#heuristic occurs(AL,ROBOT,A,step) : action(AL,_,ROBOT,A); effect(AL,ROBOT,A,F,V); fluent(AL,inertial,F,V); final_goal(AL,F,V,false); pl(AL); step > start; preempt_neg_fgoals = true. [10@0,false]
#program check(step).
#external query(step). [false]
#false :- incomplete_plan(step); query(step).
#program conformance_module(step, start, first, last, type, yield).
#external current_last_sgoals(I,step) : sgoals_index(I); yield = true. [false]
include_sgoals(I,step) :- I <= I_L; S <= step; current_last_sgoals(I_L,S); sgoals_index(I).
include_sgoals(I,step) :- sgoals_index(I); yield = false.
sgoals_index((first..last)).
current_sub_goal((AL+1),ROBOT,A,F,V,first,start) :- sub_goal((AL+1),ROBOT,A,F,V,first); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
sub_goal_satisfied((AL+1),ROBOT,A,F,V,I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,(step-1)); holds((AL+1),F,V,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,(step-1)); not sub_goal_satisfied((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); type = sequential; pl(AL).
unachieved_sgoals((AL+1),I_SG,step) :- current_sub_goal_index((AL+1),I_SG,(step-1)); sub_goal((AL+1),ROBOT,A,F,V,I_SG); not sub_goal_satisfied((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,(step-1)); unachieved_sgoals((AL+1),I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); type = simultaneous; pl(AL).
current_sub_goal((AL+1),ROBOT_1,A_1,F_1,V_1,(I_SG+1),step) :- include_sgoals((I_SG+1),step); sub_goal((AL+1),ROBOT_1,A_1,F_1,V_1,(I_SG+1)); current_sub_goal_index((AL+1),I_SG,(step-1)); not current_sub_goal_index((AL+1),I_SG,step); action((AL+1),_,ROBOT_1,A_1); fluent((AL+1),inertial,F_1,V_1); pl(AL).
sgoals_ach_at((AL+1),I_SG,step) :- current_sub_goal_index((AL+1),I_SG,(step-1)); not current_sub_goal_index((AL+1),I_SG,step); pl(AL).
current_sub_goal_index((AL+1),I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
incomplete_plan(step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
#program goal_abstraction_module.
holds(AL,F,V,0) :- final_goal(AL,F,V,true); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
not holds(AL,F,V,0) :- final_goal(AL,F,V,false); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
final_goal(AL,F,V,true) :- holds(AL,F,V,0); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
final_goal(AL,F,V,false) :- not holds(AL,F,V,0); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
{ holds(AL,F,V,0) } :- goal_fluent(AL,F); fluent(AL,inertial,F,V); al(AL).
#false :- not 1 = { holds(AL,F,V,0): fluent(AL,_,F,V) }; goal_fluent(AL,F); fluent(AL,_,F,_); al(AL).
holds(AL,F,false,0) :- not holds(AL,F,true,0); goal_fluent(AL,F); fluent(AL,defined,F,B); boolean(B); al(AL).
#program domain_sorts.
#const abstraction_max = 3.
#const reduc = 3.
#const conde = 2.
#const groun = 1.
class(3,robot).
class(3,armed_robot).
class(3,location).
class(3,room).
class(3,object).
class(3,grounded).
class(3,graspable).
class(3,placeable).
class(3,block).
class(3,surface).
class(3,table).
class(3,colour).
class(3,manipulator_arm).
class(3,grasper).
class(2,door).
class(2,handle).
class(2,configurable).
class(2,extensible).
class(1,cell).
class(1,manipulator_limb).
class(1,manipulator_end).
class(1,side).
super_class(robot,armed_robot).
super_class(location,room).
super_class(location,cell).
super_class(object,robot).
super_class(object,manipulator_arm).
super_class(object,manipulator_limb).
super_class(object,manipulator_end).
super_class(object,table).
super_class(object,side).
super_class(object,block).
super_class(object,grounded).
super_class(grounded,handle).
super_class(configurable,extensible).
super_class(configurable,grasper).
super_class(configurable,door).
super_class(extensible,manipulator_arm).
super_class(extensible,manipulator_limb).
super_class(grasper,manipulator_arm).
super_class(grasper,manipulator_end).
super_class(graspable,block).
super_class(graspable,handle).
super_class(placeable,block).
super_class(surface,table).
super_class(surface,side).
super_class(surface,block).
override_class(manipulator_arm,manipulator_end,grasper).
override_class(manipulator_arm,manipulator_limb,extensible).
override_class(room,cell,location).
override_class(table,side,surface).
state(AL,extensible,extended) :- AL < reduc; al(AL).
state(AL,extensible,retracted) :- AL < reduc; al(AL).
state(AL,manipulator_end,aligned_with(OBJ)) :- insta_of(AL,graspable,OBJ); class(AL,manipulator_end); AL < reduc; al(AL).
state(AL,manipulator_end,aligned_with(nothing)) :- AL < reduc; al(AL).
state(AL,door,open) :- AL < reduc; al(AL).
state(AL,door,closed) :- AL < reduc; al(AL).
static(AL,connected(L_1,L_2)) :- insta_of(AL,location,L_1); insta_of(AL,location,L_2); al(AL).
static(AL,connected_by_door(D,L_1,L_2)) :- insta_of(AL,door,D); insta_of(AL,location,L_1); insta_of(AL,location,L_2); AL < reduc; al(AL).
static(AL,in(OBJ,L)) :- insta_of(AL,object,OBJ); insta_of(AL,grounded,OBJ); insta_of(AL,location,L); AL < reduc; al(AL).
static(AL,colour_of(BLOCK,COLOUR)) :- insta_of(AL,block,BLOCK); insta_of(AL,colour,COLOUR); al(AL).
fluent(AL_1,inertial,in(OBJ),L) :- insta_of(AL_1,location,L); insta_of(AL_2,object,OBJ); OBJ != nothing; not insta_of(AL_2,grounded,OBJ); sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,on(OBJ),SURFACE) :- OBJ != SURFACE; insta_of(AL_1,surface,SURFACE); insta_of(AL_2,placeable,OBJ); sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,grasping(DESC),OBJ) :- insta_of(AL_1,graspable,OBJ); insta_of(AL_2,grasper,DESC); sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,configuration(DESC),STATE) :- state_of(AL_1,DESC,STATE); insta_of(AL_2,configurable,DESC); AL_1 < reduc; AL_2 < reduc; sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,configuration(D),STATE) :- state_of(AL_1,D,STATE); insta_of(AL_2,door,D); AL_1 < reduc; AL_2 < reduc; sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL,defined,tower_base(BASE),B) :- insta_of(AL,block,BASE); sl(AL); boolean(B).
fluent(AL,defined,in_tower(BASE,BLOCK),B) :- insta_of(AL,block,BASE); insta_of(AL,block,BLOCK); sl(AL); boolean(B).
fluent(AL,defined,unordered_tower(BASE),B) :- insta_of(AL,block,BASE); sl(AL); boolean(B).
fluent(AL,defined,complete(COLOUR),B) :- insta_of(AL,colour,COLOUR); sl(AL); boolean(B).
action(AL,sequential,ROBO,move(L)) :- insta_of(AL,robot,ROBO); insta_of(AL,location,L); sl(AL).
action(AL,concurrent,ROBO,grasp(DESC,OBJ)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; sl(AL).
action(AL,concurrent,ROBO,release(DESC,OBJ)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; sl(AL).
action(AL,concurrent,ROBO,configure(DESC,STATE)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,configurable,DESC); state_of(AL,DESC,STATE); AL < reduc; sl(AL).
action(AL,concurrent,ROBO,put(DESC,OBJ,SURFACE)) :- OBJ != SURFACE; SURFACE != nothing; desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); sl(AL).
action(AL,concurrent,ROBO,lift(DESC,OBJ)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); sl(AL).
action(AL,sequential,ROBO,actuate(DESC,D)) :- insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,door,D); AL < reduc; sl(AL).
#program action_effects(t).
effect(AL,ROBO,move(L),in(ROBO),L) :- action(AL,_,ROBO,move(L)); fluent(AL,inertial,in(ROBO),L); insta_of(AL,robot,ROBO); insta_of(AL,location,L); pl(AL).
effect(AL,ROBO,grasp(DESC,OBJ),grasping(DESC),OBJ) :- action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; pl(AL).
effect(AL,ROBO,release(DESC,OBJ),grasping(DESC),nothing) :- action(AL,_,ROBO,release(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); pl(AL).
effect(AL,ROBO,release(END,OBJ),configuration(END),aligned_with(nothing)) :- action(AL,_,ROBO,release(END,OBJ)); fluent(AL,inertial,configuration(END),aligned_with(nothing)); desce_of(AL,ROBO,END); insta_of(AL,armed_robot,ROBO); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); state_of(AL,END,aligned_with(nothing)); AL < reduc; pl(AL).
effect(AL,ROBO,configure(DESC,STATE),configuration(DESC),STATE) :- action(AL,_,ROBO,configure(DESC,STATE)); fluent(AL,inertial,configuration(DESC),STATE); desce_of(AL,ROBO,DESC); insta_of(AL,robot,ROBO); insta_of(AL,configurable,DESC); state_of(AL,DESC,STATE); AL < reduc; pl(AL).
effect(AL,ROBO,configure(ARM,retracted),configuration(END),aligned_with(nothing),t) :- holds(AL,grasping(END),nothing,(t-1)); action(AL,_,ROBO,configure(ARM,retracted)); fluent(AL,inertial,configuration(END),aligned_with(nothing)); desce_of(AL,ROBO,ARM); desce_of(AL,ROBO,END); siblings(AL,ARM,END); insta_of(AL,armed_robot,ROBO); insta_of(AL,extensible,ARM); insta_of(AL,manipulator_end,END); state_of(AL,END,aligned_with(nothing)); AL < reduc; pl(AL).
effect(AL,ROBO,put(DESC,OBJ,SURFACE),on(OBJ),SURFACE) :- action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,on(OBJ),SURFACE); OBJ != SURFACE; SURFACE != nothing; desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); pl(AL).
effect(AL,ROBO,lift(DESC,OBJ),on(OBJ),nothing) :- action(AL,_,ROBO,lift(DESC,OBJ)); fluent(AL,inertial,on(OBJ),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); pl(AL).
effect(AL,ROBO,actuate(DESC,D),configuration(D),STATE_1,t) :- holds(AL,configuration(D),STATE_2,(t-1)); fluent(AL,inertial,configuration(D),STATE_1); fluent(AL,inertial,configuration(D),STATE_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,door,D); state_of(AL,D,STATE_1); state_of(AL,D,STATE_2); STATE_1 != STATE_2; AL < reduc; pl(AL).
#program action_preconditions(t).
1 = { precond(AL,ROBO,move(P_2),in(ROBO),P_1,true,t): is(AL,connected(P_1,P_2)), fluent(AL,inertial,in(ROBO),P_1), static(AL,connected(P_1,P_2)), P_1 != P_2, insta_of(AL,location,P_1) } :- action(AL,_,ROBO,move(P_2)); insta_of(AL,robot,ROBO); insta_of(AL,location,P_2); AL < reduc; pl(AL).
precond(AL,ROBO,move(L_2),configuration(D),open,true,t) :- holds(AL,in(ROBO),L_1,(t-1)); is(AL,connected_by_door(D,L_1,L_2)); L_1 != L_2; action(AL,_,ROBO,move(L_2)); fluent(AL,inertial,configuration(D),open); fluent(AL,_,in(ROBO),L_1); static(AL,connected_by_door(D,L_1,L_2)); insta_of(AL,robot,ROBO); insta_of(AL,location,L_1); insta_of(AL,location,L_2); insta_of(AL,door,D); AL < reduc; pl(AL).
1 = { precond(AL,ROBO,actuate(COMP,D),grasping(COMP),H,true,t): desce_of(AL,D,H), insta_of(AL,handle,H), action(AL,_,ROBO,actuate(COMP,D)), fluent(AL,inertial,grasping(COMP),H) } :- desce_of(AL,ROBO,COMP); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,COMP); insta_of(AL,door,D); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),in(ROBO),L,true) :- is(AL,in(OBJ,L)); action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,in(ROBO),L); static(AL,in(OBJ,L)); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,grounded,OBJ); insta_of(AL,location,L); AL < reduc; pl(AL).
precond(AL,ROBO,move(L),configuration(DESC),retracted,true) :- action(AL,_,ROBO,move(L)); fluent(AL,inertial,configuration(DESC),retracted); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,extensible,DESC); insta_of(AL,location,L); state_of(AL,DESC,retracted); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),in(OBJ),L,true,t) :- holds(AL,in(ROBO),L,(t-1)); OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,in(OBJ),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),in(ROBO),L,true,t) :- holds(AL,in(OBJ),L,(t-1)); OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,in(OBJ),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),grasping(DESC),nothing,true) :- OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ_1),on(OBJ_2),OBJ_1,false) :- OBJ_1 != OBJ_2; OBJ_1 != nothing; action(AL,_,ROBO,grasp(DESC,OBJ_1)); fluent(AL,inertial,on(OBJ_2),OBJ_1); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ_1); insta_of(AL,surface,OBJ_1); insta_of(AL,placeable,OBJ_2); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),configuration(DESC),extended,true) :- OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,configuration(DESC),extended); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,extensible,DESC); insta_of(AL,graspable,OBJ); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(DESC_1,OBJ),configuration(DESC_2),extended,true) :- OBJ != nothing; action(AL,_,ROBO,grasp(DESC_1,OBJ)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC_1); not insta_of(AL,extensible,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,graspable,OBJ); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(END,OBJ),configuration(END),aligned_with(OBJ),true) :- OBJ != nothing; action(AL,_,ROBO,grasp(END,OBJ)); fluent(AL,inertial,configuration(END),aligned_with(OBJ)); desce_of(AL,ROBO,END); insta_of(AL,armed_robot,ROBO); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); state_of(AL,END,aligned_with(OBJ)); AL < reduc; pl(AL).
precond(AL,ROBO,release(DESC,OBJ),grasping(DESC),OBJ,true) :- OBJ != nothing; action(AL,_,ROBO,release(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); pl(AL).
precond(AL,ROBO,release(DESC,OBJ),configuration(DESC),extended,true) :- OBJ != nothing; action(AL,_,ROBO,release(DESC,OBJ)); fluent(AL,inertial,configuration(DESC),extended); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); state_of(AL,DESC,extended); pl(AL); t > 0.
precond(AL,ROBO,release(DESC_1,OBJ),configuration(DESC_2),extended,true) :- OBJ != nothing; action(AL,_,ROBO,release(DESC_1,OBJ)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC_1); not insta_of(AL,extensible,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,graspable,OBJ); pl(AL).
precond(AL,ROBO,configure(DESC_1,STATE),configuration(DESC_2),extended,true) :- action(AL,_,ROBO,configure(DESC_1,STATE)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); desce_of(AL,ROBO,ARM); child_of(AL,ARM,DESC_1); child_of(AL,ARM,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,configurable,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,manipulator_arm,ARM); state_of(AL,DESC_1,STATE); AL < reduc; pl(AL).
precond(AL,ROBO,configure(DESC,aligned_with(OBJ)),grasping(DESC),nothing,true) :- action(AL,_,ROBO,configure(DESC,aligned_with(OBJ))); fluent(AL,inertial,grasping(DESC),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,manipulator_end,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; state_of(AL,DESC,aligned_with(OBJ)); AL < reduc; pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),in(SURFACE),L,true,t) :- holds(AL,in(ROBO),L,(t-1)); action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,in(SURFACE),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),in(ROBO),L,true,t) :- holds(AL,in(SURFACE),L,(t-1)); action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,in(SURFACE),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,put(DESC,OBJ_1,BLOCK),on(OBJ_2),BLOCK,false) :- OBJ_1 != OBJ_2; action(AL,_,ROBO,put(DESC,OBJ_1,SURFACE)); fluent(AL,inertial,on(OBJ_2),BLOCK); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ_1); insta_of(AL,placeable,OBJ_2); insta_of(AL,block,BLOCK); pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),grasping(DESC),OBJ,true) :- OBJ != SURFACE; OBJ != nothing; SURFACE != nothing; action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); pl(AL).
precond(AL,ROBO_1,put(DESC_1,OBJ_1,OBJ_2),grasping(DESC_2),OBJ_2,false) :- OBJ_1 != OBJ_2; DESC_1 != DESC_2; action(AL,_,ROBO,put(DESC_1,OBJ_1,OBJ_2)); fluent(AL,inertial,grasping(DESC_2),OBJ_2); desce_of(AL,ROBO_1,DESC_1); desce_of(AL,ROBO_2,DESC_2); insta_of(AL,armed_robot,ROBO_1); insta_of(AL,armed_robot,ROBO_2); insta_of(AL,grasper,DESC_1); insta_of(AL,grasper,DESC_2); insta_of(AL,placeable,OBJ_1); insta_of(AL,surface,OBJ_2); insta_of(AL,graspable,OBJ_2); pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),configuration(DESC),extended,true) :- action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,configuration(DESC),extended); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,extensible,DESC); insta_of(AL,graspable,OBJ); insta_of(AL,surface,SURFACE); AL < reduc; pl(AL).
precond(AL,ROBO,put(DESC_1,OBJ,SURFACE),configuration(DESC_2),extended,true) :- action(AL,_,ROBO,put(DESC_1,OBJ,SURFACE)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC_1); not insta_of(AL,extensible,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,graspable,OBJ); insta_of(AL,surface,SURFACE); AL < reduc; pl(AL).
precond(AL,ROBO,lift(DESC,OBJ_1),on(OBJ_2),OBJ_1,false) :- OBJ_1 != OBJ_2; action(AL,_,ROBO,lift(DESC,OBJ_1)); fluent(AL,inertial,on(OBJ_2),OBJ_1); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ_1); insta_of(AL,surface,OBJ_1); insta_of(AL,placeable,OBJ_2); pl(AL).
precond(AL,ROBO,lift(DESC,OBJ),grasping(DESC),OBJ,true) :- OBJ != SURFACE; action(AL,_,ROBO,lift(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,surface,SURFACE); pl(AL).
#program variable_relations(t).
#false :- holds(AL,grasping(DESC),OBJ,t); holds(AL,in(ROBO),L,t); not holds(AL,in(OBJ),L,t): not insta_of(AL,grounded,OBJ), fluent(AL,inertial,in(OBJ),L); not is(AL,in(OBJ,L)): insta_of(AL,grounded,OBJ), static(AL,in(OBJ,L)); fluent(AL,inertial,grasping(DESC),OBJ); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,location,L); sl(AL).
#false :- holds(AL,configuration(END),aligned_with(OBJ),t); holds(AL,in(ROBO),L,t); not holds(AL,in(OBJ),L,t): not insta_of(AL,grounded,OBJ), fluent(AL,inertial,in(OBJ),L); not is(AL,in(OBJ,L)): insta_of(AL,grounded,OBJ), static(AL,in(OBJ,L)); fluent(AL,inertial,configuration(END),aligned_with(OBJ)); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,END); insta_of(AL,robot,ROBO); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,location,L); state_of(AL,END,aligned_with(OBJ)); sl(AL).
#false :- holds(AL,grasping(END),OBJ,t); not holds(AL,configuration(END),aligned_with(OBJ),t); fluent(AL,inertial,grasping(END),OBJ); fluent(AL,inertial,configuration(END),aligned_with(OBJ)); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); OBJ != nothing; state_of(AL,END,aligned_with(OBJ)); sl(AL).
#false :- holds(AL,grasping(DESC),OBJ_1,t); holds(AL,on(OBJ_2),OBJ_1,t); fluent(AL,inertial,grasping(DESC),OBJ_1); fluent(AL,inertial,on(OBJ_2),OBJ_1); desce_of(AL,ROBO,DESC); insta_of(AL,robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ_1); OBJ_1 != nothing; insta_of(AL,surface,OBJ_1); insta_of(AL,placeable,OBJ_2); sl(AL).
#false :- holds(AL,on(OBJ),SURFACE,t); holds(AL,in(SURFACE),L,t); not holds(AL,in(OBJ),L,t); fluent(AL,inertial,on(OBJ),SURFACE); fluent(AL,inertial,in(SURFACE),L); fluent(AL,inertial,in(OBJ),L); insta_of(AL,location,L); insta_of(AL,location,L); insta_of(AL,surface,SURFACE); insta_of(AL,object,OBJ); sl(AL).
#false :- holds(AL,on(BLOCK_1),BLOCK_2,t); holds(AL,on(BLOCK_2),nothing,t); fluent(AL,inertial,on(BLOCK_1),BLOCK_2); fluent(AL,inertial,on(BLOCK_2),nothing); insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); sl(AL).
#false :- holds(AL,on(BLOCK_1),BLOCK_3,t); holds(AL,on(BLOCK_2),BLOCK_3,t); fluent(AL,inertial,on(BLOCK_1),BLOCK_3); fluent(AL,inertial,on(BLOCK_2),BLOCK_3); BLOCK_1 != BLOCK_2; insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); insta_of(AL,block,BLOCK_3); sl(AL).
holds(AL,tower_base(BASE),true,t) :- holds(AL,on(BASE),TABLE,t); fluent(AL,defined,tower_base(BASE),true); fluent(AL,inertial,on(BASE),TABLE); insta_of(AL,block,BASE); insta_of(AL,table,TABLE); sl(AL).
holds(AL,tower_base(BASE),true,t) :- holds(AL,on(BASE),SURFACE,t); fluent(AL,defined,tower_base(BASE),true); fluent(AL,inertial,on(BASE),SURFACE); desce_of(AL,TABLE,SURFACE); insta_of(AL,block,BASE); insta_of(AL,surface,SURFACE); insta_of(AL,table,TABLE); sl(AL).
holds(AL,in_tower(BASE,BASE),true,t) :- holds(AL,tower_base(BASE),true,t); fluent(AL,defined,in_tower(BASE,BASE),true); fluent(AL,defined,tower_base(BASE),true); insta_of(AL,block,BASE); sl(AL).
holds(AL,in_tower(BLOCK_1,BLOCK_2),true,t) :- holds(AL,on(BLOCK_2),BLOCK_3,t); holds(AL,in_tower(BLOCK_1,BLOCK_3),true,t); fluent(AL,defined,in_tower(BLOCK_1,BLOCK_2),true); fluent(AL,defined,in_tower(BLOCK_1,BLOCK_3),true); fluent(AL,inertial,on(BLOCK_2),BLOCK_3); BLOCK_1 != BLOCK_2; insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); insta_of(AL,block,BLOCK_3); sl(AL).
holds(AL,unordered_tower(BASE),true,t) :- holds(AL,on(BLOCK_1),BLOCK_2,t); holds(AL,in_tower(BASE,BLOCK_1),true,t); holds(AL,in_tower(BASE,BLOCK_2),true,t); holds(AL,tower_base(BASE),true,t); fluent(AL,defined,unordered_tower(BASE),true); fluent(AL,defined,in_tower(BASE,BLOCK_1),true); fluent(AL,defined,in_tower(BASE,BLOCK_2),true); fluent(AL,defined,tower_base(BASE),true); fluent(AL,inertial,on(BLOCK_1),BLOCK_2); BLOCK_1 = (block,N_1); number(N_1); BLOCK_2 = (block,N_2); number(N_2); BLOCK_1 != BLOCK_2; N_1 > N_2; insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); insta_of(AL,block,BASE); sl(AL).
holds(AL,complete(COLOUR),true,t) :- N = #count { BLOCK: holds(AL,in_tower(BASE,BLOCK),true,t), is(AL,colour_of(BLOCK,COLOUR)), fluent(AL,defined,in_tower(BASE,BLOCK),true), static(AL,colour_of(BLOCK,COLOUR)), insta_of(AL,block,BLOCK) }; N = #count { BLOCK: is(AL,colour_of(BLOCK,COLOUR)), static(AL,colour_of(BLOCK,COLOUR)), insta_of(AL,block,BLOCK) }; holds(AL,unordered_tower(BASE),false,t); holds(AL,tower_base(BASE),true,t); fluent(AL,defined,unordered_tower(BASE),true); fluent(AL,defined,tower_base(BASE),true); is(AL,colour_of(BASE,COLOUR)); static(AL,colour_of(BASE,COLOUR)); insta_of(AL,colour,COLOUR); insta_of(AL,block,BASE); sl(AL).
#program abstraction_mappings(t).
is(AL_1,connected(L_1,L_2)) :- is(AL_2,connected(L_1_C,L_2_C)); static(AL_1,connected(L_1,L_2)); static(AL_2,connected(L_1_C,L_2_C)); L_1 != L_2; desce_of(AL_2,L_1,L_1_C); desce_of(AL_2,L_2,L_2_C); insta_of(AL_1,location,L_1); insta_of(AL_1,location,L_2); insta_of(AL_2,location,L_1_C); insta_of(AL_2,location,L_2_C); al(AL_1); al(AL_2); AL_1 >= AL_2.
is(AL_1,connected(L_1,L_2)) :- is(AL_2,connected(L_1,L_2)); static(AL_1,connected(L_1,L_2)); static(AL_2,connected(L_1,L_2)); L_1 != L_2; insta_of(AL_1,location,L_1); insta_of(AL_1,location,L_2); insta_of(AL_2,location,L_1); insta_of(AL_2,location,L_2); al(AL_1); al(AL_2); AL_1 >= AL_2.
is(AL_1,connected_by_door(D,L_1,L_2)) :- is(AL_2,connected_by_door(D,L_1_C,L_2_C)); static(AL_1,connected_by_door(D,L_1,L_2)); static(AL_2,connected_by_door(D,L_1_C,L_2_C)); L_1 != L_2; desce_of(AL_2,L_1,L_1_C); desce_of(AL_2,L_2,L_2_C); insta_of(AL_1,door,D); insta_of(AL_2,door,D); insta_of(AL_1,location,L_1); insta_of(AL_1,location,L_2); insta_of(AL_2,location,L_1_C); insta_of(AL_2,location,L_2_C); al(AL_1); al(AL_2); AL_1 >= AL_2.
is(AL_1,in(OBJ,L_1)) :- is(AL_2,in(OBJ,L_2)); static(AL_1,in(OBJ,L_1)); static(AL_2,in(OBJ,L_2)); desce_of(AL_2,L_1,L_2); insta_of(AL_1,location,L_1); insta_of(AL_1,object,OBJ); insta_of(AL_1,grounded,OBJ); insta_of(AL_1,location,L_1); insta_of(AL_2,location,L_2); al(AL_1); al(AL_2); AL_1 >= AL_2.
holds(AL_1,in(OBJ),L_1,t) :- holds(AL_2,in(OBJ),L_2,t); fluent(AL_1,inertial,in(OBJ),L_1); fluent(AL_2,inertial,in(OBJ),L_2); desce_of(AL_2,L_1,L_2); insta_of(AL_1,location,L_1); insta_of(AL_2,location,L_2); insta_of(AL_3,object,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
holds(AL_1,in(OBJ),L,t) :- holds(AL_2,in(OBJ),L,t); fluent(AL_1,inertial,in(OBJ),L); fluent(AL_2,inertial,in(OBJ),L); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,object,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
holds(AL_1,in(DESC),L,t) :- holds(AL_2,in(OBJ),L,t); fluent(AL_1,inertial,in(DESC),L); fluent(AL_2,inertial,in(OBJ),L); desce_of(AL_2,OBJ,DESC); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,object,OBJ); insta_of(AL_4,_,DESC); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_2; sl(AL_4); AL_4 >= AL_1.
holds(AL_1,in(OBJ),L,t) :- holds(AL_2,in(DESC),L,t); fluent(AL_1,inertial,in(OBJ),L); fluent(AL_2,inertial,in(DESC),L); desce_of(AL_2,OBJ,DESC); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,object,OBJ); insta_of(AL_4,_,DESC); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_2.
holds(AL_1,in(OBJ),L,t) :- holds(AL_2,in(ROBO),L,t); holds(AL_3,grasping(DESC),OBJ,t); fluent(AL_1,inertial,in(OBJ),L); fluent(AL_2,inertial,in(ROBO),L); fluent(AL_3,inertial,grasping(DESC),OBJ); desce_of(AL_2,ROBO,DESC); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,graspable,OBJ); OBJ != nothing; insta_of(AL_4,grasper,DESC); insta_of(AL_5,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_3; sl(AL_5); AL_5 >= AL_3.
holds(AL_1,grasping(DESC),OBJ_1,t) :- holds(AL_2,grasping(DESC),OBJ_2,t); fluent(AL_1,inertial,grasping(DESC),OBJ_1); fluent(AL_2,inertial,grasping(DESC),OBJ_2); desce_of(AL_2,ROBO,DESC); desce_of(AL_2,OBJ_1,OBJ_2); insta_of(AL_1,graspable,OBJ_1); insta_of(AL_2,graspable,OBJ_2); insta_of(AL_3,grasper,DESC); insta_of(AL_4,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_1.
holds(AL_1,grasping(DESC_1),OBJ,t) :- holds(AL_2,grasping(DESC_2),OBJ,t); fluent(AL_1,inertial,grasping(DESC_1),OBJ); fluent(AL_2,inertial,grasping(DESC_2),OBJ); desce_of(AL_2,ROBO,DESC_1); desce_of(AL_2,ROBO,DESC_2); desce_of(AL_2,DESC_1,DESC_2); insta_of(AL_1,graspable,OBJ); insta_of(AL_2,graspable,OBJ); insta_of(AL_3,grasper,DESC_1); insta_of(AL_4,grasper,DESC_2); insta_of(AL_5,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_2; sl(AL_5); AL_5 >= AL_1.
holds(AL_1,grasping(DESC),OBJ,t) :- holds(AL_2,grasping(DESC),OBJ,t); fluent(AL_1,inertial,grasping(DESC),OBJ); fluent(AL_2,inertial,grasping(DESC),OBJ); desce_of(AL_2,ROBO,DESC); insta_of(AL_1,graspable,OBJ); insta_of(AL_2,graspable,OBJ); insta_of(AL_3,grasper,DESC); insta_of(AL_4,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_1; boolean(B).
holds(AL_1,configuration(DESC_1),STATE,t) :- holds(AL_2,configuration(DESC_2),STATE,t); fluent(AL_1,inertial,configuration(DESC_1),STATE); fluent(AL_2,inertial,configuration(DESC_2),STATE); desce_of(AL_2,DESC_1,DESC_2); state_of(AL_1,DESC_1,STATE); state_of(AL_2,DESC_2,STATE); insta_of(AL_1,configurable,DESC_1); insta_of(AL_2,configurable,DESC_2); sl(AL_1); sl(AL_2); AL_1 >= AL_2.
holds(AL_1,configuration(DESC),STATE,t) :- holds(AL_2,configuration(DESC),STATE,t); fluent(AL_1,inertial,configuration(DESC),STATE); fluent(AL_2,inertial,configuration(DESC),STATE); state_of(AL_1,DESC,STATE); state_of(AL_2,DESC,STATE); insta_of(AL_1,configurable,DESC); insta_of(AL_2,configurable,DESC); sl(AL_1); sl(AL_2); AL_1 >= AL_2.
holds(AL_1,on(OBJ),SURFACE_1,t) :- holds(AL_2,on(OBJ),SURFACE_2,t); fluent(AL_1,inertial,on(OBJ),SURFACE_1); fluent(AL_2,inertial,on(OBJ),SURFACE_2); desce_of(AL_2,SURFACE_1,SURFACE_2); insta_of(AL_1,surface,SURFACE_1); insta_of(AL_2,surface,SURFACE_2); insta_of(AL_3,placeable,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
holds(AL_1,on(OBJ),SURFACE,t) :- holds(AL_2,on(OBJ),SURFACE,t); fluent(AL_1,inertial,on(OBJ),SURFACE); fluent(AL_2,inertial,on(OBJ),SURFACE); insta_of(AL_1,surface,SURFACE); insta_of(AL_2,surface,SURFACE); insta_of(AL_3,placeable,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
#program static_state.
is(1,connected((starting_room,1),(hallway,1))).
is(1,connected((store_room,1),(hallway,0))).
is(1,connected((hallway,2),(puzzle_room,0))).
is(1,connected_by_door(store_room_door,(store_room,1),(hallway,0))).
is(1,connected_by_door(puzzle_room_door,(hallway,2),(puzzle_room,0))).
is(1,in(store_room_door_handle_inner,(store_room,1))).
is(1,in(store_room_door_handle_outer,(hallway,0))).
is(1,in(starting_room_door_handle_inner,(starting_room,1))).
is(1,in(starting_room_door_handle_outer,(hallway,1))).
is(1,in(puzzle_room_door_handle_inner,(puzzle_room,0))).
is(1,in(puzzle_room_door_handle_outer,(hallway,2))).
is(AL,colour_of((BLOCK,N),red)) :- static(AL,colour_of((BLOCK,N),red)); insta_of(AL,block,(BLOCK,N)); N <= 3; al(AL).
is(AL,colour_of((BLOCK,N),blue)) :- static(AL,colour_of((BLOCK,N),blue)); insta_of(AL,block,(BLOCK,N)); N > 3; N <= 6; al(AL).
is(1,connected((A,X_1),(A,X_2))) :- insta_of(1,cell,(A,X_1)); insta_of(1,cell,(A,X_2)); X_2 = (X_1+1).
is(1,connected(C_1,C_2)) :- is(1,connected(C_2,C_1)); insta_of(1,cell,C_1); insta_of(1,cell,C_2).
is(1,connected_by_door(D,C_1,C_2)) :- is(1,connected_by_door(D,C_2,C_1)); insta_of(1,door,D); insta_of(1,cell,C_1); insta_of(1,cell,C_2).
#program initial_state.
holds(1,in(talos),(starting_room,0),0).
holds(AL,grasping(DESC),nothing,0) :- fluent(AL,inertial,grasping(DESC),nothing); insta_of(AL,grasper,DESC); al(AL).
holds(AL,configuration(DESC),retracted,0) :- fluent(AL,inertial,configuration(DESC),retracted); insta_of(AL,extensible,DESC); sl(AL).
holds(1,configuration(END),aligned_with(nothing),0) :- fluent(AL,inertial,configuration(END),aligned_with(nothing)); insta_of(AL,manipulator_end,END); state_of(AL,END,aligned_with(nothing)); sl(AL).
holds(1,configuration(DOOR),closed,0) :- fluent(AL,inertial,configuration(DOOR),closed); insta_of(AL,door,DOOR); state_of(AL,DOOR,closed); sl(AL).
holds(1,in(puzzle_room_table),(puzzle_room,1),0).
holds(1,on((block,1)),puzzle_room_table_left,0).
holds(1,on((block,2)),puzzle_room_table_right,0).
holds(1,on((block,3)),(block,1),0).
holds(1,in((block,4)),(store_room,0),0).
holds(1,in((block,5)),(store_room,0),0).
holds(1,in((block,6)),(store_room,0),0).
holds(1,on((block,4)),nothing,0).
holds(1,on((block,5)),nothing,0).
holds(1,on((block,6)),nothing,0).
#program goal_state.
goal_fluent(AL,complete(COLOUR)) :- insta_of(AL,colour,COLOUR); al(AL).
goal_fluent(AL,on((block,3))) :- al(AL).
goal_fluent(AL,on((block,6))) :- al(AL).
final_goal(AL,complete(COLOUR),true,true) :- insta_of(AL,colour,COLOUR); al(AL).
final_goal(1,on((block,3)),puzzle_room_table_left,true).
final_goal(1,on((block,6)),puzzle_room_table_right,true).
#program entities.
entity(armed_robot,talos).
entity(manipulator_arm,manipulator_arm_1).
entity(manipulator_limb,manipulator_limb_1).
entity(manipulator_end,manipulator_end_1).
entity(manipulator_arm,manipulator_arm_2).
entity(manipulator_limb,manipulator_limb_2).
entity(manipulator_end,manipulator_end_2).
number((1..6)).
entity(block,(block,N)) :- number(N).
entity(room,starting_room).
entity(room,store_room).
entity(room,puzzle_room).
entity(room,hallway).
x((0..3)).
size(starting_room,2).
size(store_room,2).
size(hallway,3).
size(puzzle_room,2).
entity(cell,(ROOM,X)) :- entity(room,ROOM); size(ROOM,MAX); X < MAX; x(X).
entity(door,store_room_door).
entity(door,starting_room_door).
entity(door,puzzle_room_door).
entity(handle,store_room_door_handle_inner).
entity(handle,store_room_door_handle_outer).
entity(handle,starting_room_door_handle_inner).
entity(handle,starting_room_door_handle_outer).
entity(handle,puzzle_room_door_handle_inner).
entity(handle,puzzle_room_door_handle_outer).
entity(table,puzzle_room_table).
entity(side,puzzle_room_table_left).
entity(side,puzzle_room_table_right).
entity(colour,red).
entity(colour,blue).
entity(surface,nothing).
entity(graspable,nothing).
ancestry_relation(talos,manipulator_arm_1).
ancestry_relation(talos,manipulator_arm_2).
ancestry_relation(manipulator_arm_1,manipulator_limb_1).
ancestry_relation(manipulator_arm_2,manipulator_limb_2).
ancestry_relation(manipulator_arm_1,manipulator_end_1).
ancestry_relation(manipulator_arm_2,manipulator_end_2).
ancestry_relation(ROOM,(ROOM,X)) :- entity(room,ROOM); entity(cell,(ROOM,X)); x(X).
ancestry_relation(store_room_door,store_room_door_handle_inner).
ancestry_relation(store_room_door,store_room_door_handle_outer).
ancestry_relation(starting_room_door,starting_room_door_handle_inner).
ancestry_relation(starting_room_door,starting_room_door_handle_outer).
ancestry_relation(puzzle_room_door,puzzle_room_door_handle_inner).
ancestry_relation(puzzle_room_door,puzzle_room_door_handle_outer).
ancestry_relation(puzzle_room_table,puzzle_room_table_left).
ancestry_relation(puzzle_room_table,puzzle_room_table_right)., Main #1 || Generate Initial States #1))
	('solver_options', ['--models=2', '--parallel-mode=8,compete', '--warn=none', '--enum-mode=auto'])
	('assumptions', [])
	('context', None)
	('solve_incrementor', None)
	('base_parts', [('entities', []), ('static_state', []), ('initial_state', []), ('abstraction_levels', [1, 'hierarchical']), ('instance_module', []), ('state_module', [0, 0]), ('domain_sorts', []), ('variable_relations', [0]), ('abstraction_mappings', [0])])
	('inc_parts', [IncPart(name='step', args=['#inc'], range_=None)])
	('incremental', False)

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Setting input storing variables:
	solver_options = ['--models=2', '--parallel-mode=8,compete', '--warn=none', '--enum-mode=auto']
	assumptions = []
	context = None
	incrementor = None
	base_parts = [('entities', []), ('static_state', []), ('initial_state', []), ('abstraction_levels', [1, 'hierarchical']), ('instance_module', []), ('state_module', [0, 0]), ('domain_sorts', []), ('variable_relations', [0]), ('abstraction_mappings', [0])]
	inc_parts = [IncPart(name='step', args=['#inc'], range_=None)]

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Output storing variables reset.

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Program building started :: Processing 331 rules

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Program building completed in 0.003701200000000071s

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Running one-shot ground and solve of program parts:
[BasePart(name='entities', args=[]), BasePart(name='static_state', args=[]), BasePart(name='initial_state', args=[]), BasePart(name='abstraction_levels', args=[1, 'hierarchical']), BasePart(name='instance_module', args=[]), BasePart(name='state_module', args=[0, 0]), BasePart(name='domain_sorts', args=[]), BasePart(name='variable_relations', args=[0]), BasePart(name='abstraction_mappings', args=[0])]

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Grounding program parts:
[('entities', []), ('static_state', []), ('initial_state', []), ('abstraction_levels', [Number(1), Function('hierarchical', [], True)]), ('instance_module', []), ('state_module', [Number(0), Number(0)]), ('domain_sorts', []), ('variable_relations', [Number(0)]), ('abstraction_mappings', [Number(0)])]

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Grounding completed in 0.148960s.

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Solving program.

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Model found:
Model :: Total atoms = 2731, Cost = (), Optimality proven = False, Number = 1, Thread ID = 7, Model type = ModelType.StableModel

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Solving completed in 0.023425s with result Satisfiable.

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Freeing held grounding...

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Setting input storing variables:
	solver_options = []
	assumptions = []
	context = None
	incrementor = None
	base_parts = []
	inc_parts = []

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Held grounding freed.

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Returning from standard solve call:
Result :: SATISFIABLE : SEARCH EXHAUSTED : Total models = 1
Statistics :: Grounding = 0.148960s, Solving = 0.023425s, Total = 0.172386s, Memory = (RSS = 90.000000b, VMS = 79.000000b)
Final Model :: Total atoms = 2731, Cost = (), Optimality proven = False, Number = 1, Thread ID = 7, Model type = ModelType.StableModel

[15-09-2021_15-49-16] INFO :: ASH Planner Main #1 >> Initial states generated successfully:
Result :: SATISFIABLE : SEARCH EXHAUSTED : Total models = 1
Statistics :: Grounding = 0.148960s, Solving = 0.023425s, Total = 0.172386s, Memory = (RSS = 90.000000b, VMS = 79.000000b)
Final Model :: Total atoms = 2731, Cost = (), Optimality proven = False, Number = 1, Thread ID = 7, Model type = ModelType.StableModel

[15-09-2021_15-49-16] DEBUG :: ASH Planner Main #1 >> 

          ========================================          
            Initial state at abstraction level 3            
          ========================================          

holds(3, complete(blue), false, 0)
holds(3, complete(red), false, 0)
holds(3, grasping(manipulator_arm_1), nothing, 0)
holds(3, grasping(manipulator_arm_2), nothing, 0)
holds(3, in((block,1)), puzzle_room, 0)
holds(3, in((block,2)), puzzle_room, 0)
holds(3, in((block,3)), puzzle_room, 0)
holds(3, in((block,4)), store_room, 0)
holds(3, in((block,5)), store_room, 0)
holds(3, in((block,6)), store_room, 0)
holds(3, in(manipulator_arm_1), starting_room, 0)
holds(3, in(manipulator_arm_2), starting_room, 0)
holds(3, in(puzzle_room_table), puzzle_room, 0)
holds(3, in(talos), starting_room, 0)
holds(3, in_tower((block,1),(block,1)), true, 0)
holds(3, in_tower((block,1),(block,2)), false, 0)
holds(3, in_tower((block,1),(block,3)), true, 0)
holds(3, in_tower((block,1),(block,4)), false, 0)
holds(3, in_tower((block,1),(block,5)), false, 0)
holds(3, in_tower((block,1),(block,6)), false, 0)
holds(3, in_tower((block,2),(block,1)), false, 0)
holds(3, in_tower((block,2),(block,2)), true, 0)
holds(3, in_tower((block,2),(block,3)), false, 0)
holds(3, in_tower((block,2),(block,4)), false, 0)
holds(3, in_tower((block,2),(block,5)), false, 0)
holds(3, in_tower((block,2),(block,6)), false, 0)
holds(3, in_tower((block,3),(block,1)), false, 0)
holds(3, in_tower((block,3),(block,2)), false, 0)
holds(3, in_tower((block,3),(block,3)), false, 0)
holds(3, in_tower((block,3),(block,4)), false, 0)
holds(3, in_tower((block,3),(block,5)), false, 0)
holds(3, in_tower((block,3),(block,6)), false, 0)
holds(3, in_tower((block,4),(block,1)), false, 0)
holds(3, in_tower((block,4),(block,2)), false, 0)
holds(3, in_tower((block,4),(block,3)), false, 0)
holds(3, in_tower((block,4),(block,4)), false, 0)
holds(3, in_tower((block,4),(block,5)), false, 0)
holds(3, in_tower((block,4),(block,6)), false, 0)
holds(3, in_tower((block,5),(block,1)), false, 0)
holds(3, in_tower((block,5),(block,2)), false, 0)
holds(3, in_tower((block,5),(block,3)), false, 0)
holds(3, in_tower((block,5),(block,4)), false, 0)
holds(3, in_tower((block,5),(block,5)), false, 0)
holds(3, in_tower((block,5),(block,6)), false, 0)
holds(3, in_tower((block,6),(block,1)), false, 0)
holds(3, in_tower((block,6),(block,2)), false, 0)
holds(3, in_tower((block,6),(block,3)), false, 0)
holds(3, in_tower((block,6),(block,4)), false, 0)
holds(3, in_tower((block,6),(block,5)), false, 0)
holds(3, in_tower((block,6),(block,6)), false, 0)
holds(3, on((block,1)), puzzle_room_table, 0)
holds(3, on((block,2)), puzzle_room_table, 0)
holds(3, on((block,3)), (block,1), 0)
holds(3, on((block,4)), nothing, 0)
holds(3, on((block,5)), nothing, 0)
holds(3, on((block,6)), nothing, 0)
holds(3, tower_base((block,1)), true, 0)
holds(3, tower_base((block,2)), true, 0)
holds(3, tower_base((block,3)), false, 0)
holds(3, tower_base((block,4)), false, 0)
holds(3, tower_base((block,5)), false, 0)
holds(3, tower_base((block,6)), false, 0)
holds(3, unordered_tower((block,1)), true, 0)
holds(3, unordered_tower((block,2)), false, 0)
holds(3, unordered_tower((block,3)), false, 0)
holds(3, unordered_tower((block,4)), false, 0)
holds(3, unordered_tower((block,5)), false, 0)
holds(3, unordered_tower((block,6)), false, 0)

[15-09-2021_15-49-16] DEBUG :: ASH Planner Main #1 >> 

          ========================================          
            Initial state at abstraction level 2            
          ========================================          

holds(2, complete(blue), false, 0)
holds(2, complete(red), false, 0)
holds(2, configuration(manipulator_arm_1), retracted, 0)
holds(2, configuration(manipulator_arm_2), retracted, 0)
holds(2, configuration(puzzle_room_door), closed, 0)
holds(2, configuration(starting_room_door), closed, 0)
holds(2, configuration(store_room_door), closed, 0)
holds(2, grasping(manipulator_arm_1), nothing, 0)
holds(2, grasping(manipulator_arm_2), nothing, 0)
holds(2, in((block,1)), puzzle_room, 0)
holds(2, in((block,2)), puzzle_room, 0)
holds(2, in((block,3)), puzzle_room, 0)
holds(2, in((block,4)), store_room, 0)
holds(2, in((block,5)), store_room, 0)
holds(2, in((block,6)), store_room, 0)
holds(2, in(manipulator_arm_1), starting_room, 0)
holds(2, in(manipulator_arm_2), starting_room, 0)
holds(2, in(puzzle_room_table), puzzle_room, 0)
holds(2, in(talos), starting_room, 0)
holds(2, in_tower((block,1),(block,1)), true, 0)
holds(2, in_tower((block,1),(block,2)), false, 0)
holds(2, in_tower((block,1),(block,3)), true, 0)
holds(2, in_tower((block,1),(block,4)), false, 0)
holds(2, in_tower((block,1),(block,5)), false, 0)
holds(2, in_tower((block,1),(block,6)), false, 0)
holds(2, in_tower((block,2),(block,1)), false, 0)
holds(2, in_tower((block,2),(block,2)), true, 0)
holds(2, in_tower((block,2),(block,3)), false, 0)
holds(2, in_tower((block,2),(block,4)), false, 0)
holds(2, in_tower((block,2),(block,5)), false, 0)
holds(2, in_tower((block,2),(block,6)), false, 0)
holds(2, in_tower((block,3),(block,1)), false, 0)
holds(2, in_tower((block,3),(block,2)), false, 0)
holds(2, in_tower((block,3),(block,3)), false, 0)
holds(2, in_tower((block,3),(block,4)), false, 0)
holds(2, in_tower((block,3),(block,5)), false, 0)
holds(2, in_tower((block,3),(block,6)), false, 0)
holds(2, in_tower((block,4),(block,1)), false, 0)
holds(2, in_tower((block,4),(block,2)), false, 0)
holds(2, in_tower((block,4),(block,3)), false, 0)
holds(2, in_tower((block,4),(block,4)), false, 0)
holds(2, in_tower((block,4),(block,5)), false, 0)
holds(2, in_tower((block,4),(block,6)), false, 0)
holds(2, in_tower((block,5),(block,1)), false, 0)
holds(2, in_tower((block,5),(block,2)), false, 0)
holds(2, in_tower((block,5),(block,3)), false, 0)
holds(2, in_tower((block,5),(block,4)), false, 0)
holds(2, in_tower((block,5),(block,5)), false, 0)
holds(2, in_tower((block,5),(block,6)), false, 0)
holds(2, in_tower((block,6),(block,1)), false, 0)
holds(2, in_tower((block,6),(block,2)), false, 0)
holds(2, in_tower((block,6),(block,3)), false, 0)
holds(2, in_tower((block,6),(block,4)), false, 0)
holds(2, in_tower((block,6),(block,5)), false, 0)
holds(2, in_tower((block,6),(block,6)), false, 0)
holds(2, on((block,1)), puzzle_room_table, 0)
holds(2, on((block,2)), puzzle_room_table, 0)
holds(2, on((block,3)), (block,1), 0)
holds(2, on((block,4)), nothing, 0)
holds(2, on((block,5)), nothing, 0)
holds(2, on((block,6)), nothing, 0)
holds(2, tower_base((block,1)), true, 0)
holds(2, tower_base((block,2)), true, 0)
holds(2, tower_base((block,3)), false, 0)
holds(2, tower_base((block,4)), false, 0)
holds(2, tower_base((block,5)), false, 0)
holds(2, tower_base((block,6)), false, 0)
holds(2, unordered_tower((block,1)), true, 0)
holds(2, unordered_tower((block,2)), false, 0)
holds(2, unordered_tower((block,3)), false, 0)
holds(2, unordered_tower((block,4)), false, 0)
holds(2, unordered_tower((block,5)), false, 0)
holds(2, unordered_tower((block,6)), false, 0)

[15-09-2021_15-49-16] DEBUG :: ASH Planner Main #1 >> 

          ========================================          
            Initial state at abstraction level 1            
          ========================================          

holds(1, complete(blue), false, 0)
holds(1, complete(red), false, 0)
holds(1, configuration(manipulator_end_1), aligned_with(nothing), 0)
holds(1, configuration(manipulator_end_2), aligned_with(nothing), 0)
holds(1, configuration(manipulator_limb_1), retracted, 0)
holds(1, configuration(manipulator_limb_2), retracted, 0)
holds(1, configuration(puzzle_room_door), closed, 0)
holds(1, configuration(starting_room_door), closed, 0)
holds(1, configuration(store_room_door), closed, 0)
holds(1, grasping(manipulator_arm_1), nothing, 0)
holds(1, grasping(manipulator_arm_2), nothing, 0)
holds(1, grasping(manipulator_end_1), nothing, 0)
holds(1, grasping(manipulator_end_2), nothing, 0)
holds(1, in((block,1)), (puzzle_room,1), 0)
holds(1, in((block,2)), (puzzle_room,1), 0)
holds(1, in((block,3)), (puzzle_room,1), 0)
holds(1, in((block,4)), (store_room,0), 0)
holds(1, in((block,5)), (store_room,0), 0)
holds(1, in((block,6)), (store_room,0), 0)
holds(1, in(manipulator_arm_1), (starting_room,0), 0)
holds(1, in(manipulator_arm_2), (starting_room,0), 0)
holds(1, in(manipulator_end_1), (starting_room,0), 0)
holds(1, in(manipulator_end_2), (starting_room,0), 0)
holds(1, in(manipulator_limb_1), (starting_room,0), 0)
holds(1, in(manipulator_limb_2), (starting_room,0), 0)
holds(1, in(puzzle_room_table), (puzzle_room,1), 0)
holds(1, in(puzzle_room_table_left), (puzzle_room,1), 0)
holds(1, in(puzzle_room_table_right), (puzzle_room,1), 0)
holds(1, in(talos), (starting_room,0), 0)
holds(1, in_tower((block,1),(block,1)), true, 0)
holds(1, in_tower((block,1),(block,2)), false, 0)
holds(1, in_tower((block,1),(block,3)), true, 0)
holds(1, in_tower((block,1),(block,4)), false, 0)
holds(1, in_tower((block,1),(block,5)), false, 0)
holds(1, in_tower((block,1),(block,6)), false, 0)
holds(1, in_tower((block,2),(block,1)), false, 0)
holds(1, in_tower((block,2),(block,2)), true, 0)
holds(1, in_tower((block,2),(block,3)), false, 0)
holds(1, in_tower((block,2),(block,4)), false, 0)
holds(1, in_tower((block,2),(block,5)), false, 0)
holds(1, in_tower((block,2),(block,6)), false, 0)
holds(1, in_tower((block,3),(block,1)), false, 0)
holds(1, in_tower((block,3),(block,2)), false, 0)
holds(1, in_tower((block,3),(block,3)), false, 0)
holds(1, in_tower((block,3),(block,4)), false, 0)
holds(1, in_tower((block,3),(block,5)), false, 0)
holds(1, in_tower((block,3),(block,6)), false, 0)
holds(1, in_tower((block,4),(block,1)), false, 0)
holds(1, in_tower((block,4),(block,2)), false, 0)
holds(1, in_tower((block,4),(block,3)), false, 0)
holds(1, in_tower((block,4),(block,4)), false, 0)
holds(1, in_tower((block,4),(block,5)), false, 0)
holds(1, in_tower((block,4),(block,6)), false, 0)
holds(1, in_tower((block,5),(block,1)), false, 0)
holds(1, in_tower((block,5),(block,2)), false, 0)
holds(1, in_tower((block,5),(block,3)), false, 0)
holds(1, in_tower((block,5),(block,4)), false, 0)
holds(1, in_tower((block,5),(block,5)), false, 0)
holds(1, in_tower((block,5),(block,6)), false, 0)
holds(1, in_tower((block,6),(block,1)), false, 0)
holds(1, in_tower((block,6),(block,2)), false, 0)
holds(1, in_tower((block,6),(block,3)), false, 0)
holds(1, in_tower((block,6),(block,4)), false, 0)
holds(1, in_tower((block,6),(block,5)), false, 0)
holds(1, in_tower((block,6),(block,6)), false, 0)
holds(1, on((block,1)), puzzle_room_table_left, 0)
holds(1, on((block,2)), puzzle_room_table_right, 0)
holds(1, on((block,3)), (block,1), 0)
holds(1, on((block,4)), nothing, 0)
holds(1, on((block,5)), nothing, 0)
holds(1, on((block,6)), nothing, 0)
holds(1, tower_base((block,1)), true, 0)
holds(1, tower_base((block,2)), true, 0)
holds(1, tower_base((block,3)), false, 0)
holds(1, tower_base((block,4)), false, 0)
holds(1, tower_base((block,5)), false, 0)
holds(1, tower_base((block,6)), false, 0)
holds(1, unordered_tower((block,1)), true, 0)
holds(1, unordered_tower((block,2)), false, 0)
holds(1, unordered_tower((block,3)), false, 0)
holds(1, unordered_tower((block,4)), false, 0)
holds(1, unordered_tower((block,5)), false, 0)
holds(1, unordered_tower((block,6)), false, 0)

[15-09-2021_15-49-16] DEBUG :: ASH Planner Main #1 >> The given partial initial state has a unique interpretation (only one stable model exists).

[15-09-2021_15-49-16] INFO :: ASH Planner Main #1 >> Generating final goals.

[15-09-2021_15-49-16] DEBUG :: Logic Program ASH #1 >> Creating copy of self: rename = Main #1 || Generate Final Goals

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Instantiating logic program...

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Setting input storing variables:
	solver_options = []
	assumptions = []
	context = None
	incrementor = None
	base_parts = []
	inc_parts = []

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Output storing variables reset.

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Logic program instantiated.

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Entering new one-shot solve call:
('self', LogicProgram(#program base.
#program abstraction_levels(planning_level, mode).
al((1..abstraction_max)).
pl(AL) :- AL = planning_level; al(AL).
sl(AL) :- AL = planning_level; mode = classical; al(AL).
sl(AL) :- AL >= planning_level; AL <= (planning_level+1); mode = refinement; al(AL).
sl(AL) :- AL >= planning_level; AL <= abstraction_max; mode = hierarchical; al(AL).
#program instance_module.
boolean(true;false).
insta_of(AL,CLS,EN) :- entity(CLS,EN); class(AL,CLS); al(AL).
insta_of(AL_3,CLS_1,EN) :- insta_of(AL_2,CLS_2,EN); super_class(CLS_1,CLS_2); entity(CLS_3,EN); class(AL_3,CLS_3); class(AL_1,CLS_1); AL_1 >= AL_2; al(AL_1); al(AL_2); al(AL_3).
insta_of((AL-1),CLS,EN) :- insta_of(AL,CLS,EN); not overridden((AL-1),CLS,EN); class(_,CLS); al(AL); al((AL-1)).
overridden((AL-1),CLS,EN_1) :- overridden_by((AL-1),CLS,EN_1,EN_2); insta_of(AL,CLS,EN_1); insta_of((AL-1),CLS,EN_2); class(_,CLS); al(AL); al((AL-1)).
overridden_by((AL-1),CLS_3,EN_1,EN_2) :- insta_of(AL,CLS_1,EN_1); insta_of((AL-1),CLS_2,EN_2); insta_of(AL,CLS_3,EN_1); insta_of((AL-1),CLS_3,EN_2); desce_of((AL-1),EN_1,EN_2); override_class(CLS_1,CLS_2,CLS_3); class(_,CLS_1); class(_,CLS_2); class(_,CLS_3); al(AL); al((AL-1)).
state_of(AL,EN,S) :- state(AL,CLS,S); insta_of(AL,CLS,EN); al(AL).
child_of(AL,EN,DESCE) :- ancestry_relation(EN,DESCE); insta_of(AL,_,EN); insta_of(AL,_,DESCE); al(AL).
desce_of(AL,EN,DESCE) :- child_of(AL,EN,DESCE); insta_of(AL,_,EN); insta_of(AL,_,DESCE); al(AL).
desce_of(AL,EN,DESCE_1) :- desce_of(AL,DESCE_2,DESCE_1); desce_of(AL,EN,DESCE_2); insta_of(AL,_,EN); insta_of(AL,_,DESCE_1); insta_of(AL,_,DESCE_2); al(AL).
has_desce(AL,EN) :- desce_of(AL,EN,DESCE); insta_of(AL,_,EN); insta_of(AL,_,DESCE); al(AL).
has_desce(AL,EN,CLS) :- desce_of(AL,EN,DESCE); insta_of(AL,_,EN); insta_of(AL,CLS,DESCE); al(AL).
siblings(AL,DESCE_1,DESCE_2) :- child_of(AL,EN,DESCE_1); child_of(AL,EN,DESCE_2); DESCE_1 != DESCE_2; insta_of(AL,_,EN); insta_of(AL,_,DESCE_1); insta_of(AL,_,DESCE_2); al(AL).
siblings(AL,DESCE_2,DESCE_1) :- siblings(AL,DESCE_1,DESCE_2); insta_of(AL,_,DESCE_1); insta_of(AL,_,DESCE_2); al(AL).
#program state_module(step, start).
{ holds(AL,F,V,step) } :- fluent(AL,inertial,F,V); sl(AL); step = start.
#false :- not 1 = { holds(AL,F,V,step): fluent(AL,_,F,V) }; fluent(AL,_,F,_); sl(AL).
holds(AL,F,V,step) :- holds(AL,F,V,(step-1)); not not holds(AL,F,V,step); fluent(AL,inertial,F,V); sl(AL); step > start.
holds(AL,F,false,step) :- not holds(AL,F,true,step); fluent(AL,defined,F,B); boolean(B); sl(AL).
#program plan_module(step, start, concurrency, achieve_fgoals).
{ occurs(AL,ROBOT,A,step): action(AL,_,ROBOT,A) } :- incomplete_plan((step-1)); pl(AL); step > start.
occurs(AL,ROBOT,step) :- occurs(AL,ROBOT,A,step); action(AL,_,ROBOT,A); pl(AL); step > start.
occurs(AL,step) :- occurs(AL,ROBOT,step); insta_of(AL,robot,ROBOT); pl(AL); step > start.
holds(AL,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V,step); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
holds(AL,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,true,step); not holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,true); not holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,false,step); holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,false); holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- not 1 = { occurs(AL,R,A,step): action(AL,_,ROBOT,A) }; incomplete_plan((step-1)); pl(AL); step > start; concurrency = false.
#false :- not 1 <= { occurs(AL,R,A,step): action(AL,_,ROBOT,A) }; incomplete_plan((step-1)); pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT,A_1,step); occurs(AL,ROBOT,A_2,step); A_1 != A_2; action(AL,_,ROBOT,A_1); action(AL,_,ROBOT,A_2); pl(AL); step > start; concurrency = false.
#false :- occurs(AL,ROBOT,A_1,step); occurs(AL,ROBOT,A_2,step); A_1 != A_2; action(AL,sequential,ROBOT,A_1); action(AL,_,ROBOT,A_2); pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); effect(AL,ROBOT_2,A_2,F,V_2,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; ROBOT_1 != ROBOT_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); effect(AL,ROBOT_2,A_2,F,V_2); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; ROBOT_1 != ROBOT_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1); effect(AL,ROBOT_2,A_2,F,V_2); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; ROBOT_1 != ROBOT_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); precond(AL,ROBOT_2,A_2,F,V_2,true,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); precond(AL,ROBOT_2,A_2,F,V_2,true); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V,step); precond(AL,ROBOT_2,A_2,F,V,false,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V,step); precond(AL,ROBOT_2,A_2,F,V,false); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1); precond(AL,ROBOT_2,A_2,F,V_2,true,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1); precond(AL,ROBOT_2,A_2,F,V_2,true); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V); precond(AL,ROBOT_2,A_2,F,V,false,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V); precond(AL,ROBOT_2,A_2,F,V,false); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#external seq_achieve_fgoals(step). [false]
enforce_achieve_fgoals(step) :- achieve_fgoals = true.
enforce_achieve_fgoals(step) :- 0 <= S; S <= step; seq_achieve_fgoals(S).
goal_satisfied(AL,F,V,true,step) :- final_goal(AL,F,V,true); holds(AL,F,V,step); fluent(AL,_,F,V); pl(AL); enforce_achieve_fgoals(step).
goal_satisfied(AL,F,V,false,step) :- final_goal(AL,F,V,false); not holds(AL,F,V,step); fluent(AL,_,F,V); pl(AL); enforce_achieve_fgoals(step).
incomplete_plan(step) :- final_goal(AL,F,V,B); not goal_satisfied(AL,F,V,B,step); fluent(AL,_,F,V); pl(AL); boolean(B); enforce_achieve_fgoals(step).
sub_goal(AL,ROBOT,A,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V,step); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); AL != 1; step > start.
sub_goal(AL,ROBOT,A,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); AL != 1; step > start.
#program optimisation_module(step, start, minimise_length, minimise_actions, minimise_cost, preempt_pos_fgoals, preempt_neg_fgoals, order_fgoals_achievement).
:~ occurs(AL,step); incomplete_plan((step-1)); pl(AL); step > start; minimise_length = true. [1@3,step]
:~ occurs(AL,ROBOT,A,step); action(AL,_,ROBOT,A); incomplete_plan((step-1)); pl(AL); step > start; minimise_actions = true. [1@2,ROBOT,A,step]
#heuristic occurs(AL,ROBOT,A,step) : action(AL,_,ROBOT,A); effect(AL,ROBOT,A,F,V); fluent(AL,inertial,F,V); final_goal(AL,F,V,true); pl(AL); step > start; preempt_pos_fgoals = true. [10@1,true]
#heuristic occurs(AL,ROBOT,A,step) : action(AL,_,ROBOT,A); effect(AL,ROBOT,A,F,V); fluent(AL,inertial,F,V); final_goal(AL,F,V,false); pl(AL); step > start; preempt_neg_fgoals = true. [10@0,false]
#program check(step).
#external query(step). [false]
#false :- incomplete_plan(step); query(step).
#program conformance_module(step, start, first, last, type, yield).
#external current_last_sgoals(I,step) : sgoals_index(I); yield = true. [false]
include_sgoals(I,step) :- I <= I_L; S <= step; current_last_sgoals(I_L,S); sgoals_index(I).
include_sgoals(I,step) :- sgoals_index(I); yield = false.
sgoals_index((first..last)).
current_sub_goal((AL+1),ROBOT,A,F,V,first,start) :- sub_goal((AL+1),ROBOT,A,F,V,first); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
sub_goal_satisfied((AL+1),ROBOT,A,F,V,I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,(step-1)); holds((AL+1),F,V,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,(step-1)); not sub_goal_satisfied((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); type = sequential; pl(AL).
unachieved_sgoals((AL+1),I_SG,step) :- current_sub_goal_index((AL+1),I_SG,(step-1)); sub_goal((AL+1),ROBOT,A,F,V,I_SG); not sub_goal_satisfied((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,(step-1)); unachieved_sgoals((AL+1),I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); type = simultaneous; pl(AL).
current_sub_goal((AL+1),ROBOT_1,A_1,F_1,V_1,(I_SG+1),step) :- include_sgoals((I_SG+1),step); sub_goal((AL+1),ROBOT_1,A_1,F_1,V_1,(I_SG+1)); current_sub_goal_index((AL+1),I_SG,(step-1)); not current_sub_goal_index((AL+1),I_SG,step); action((AL+1),_,ROBOT_1,A_1); fluent((AL+1),inertial,F_1,V_1); pl(AL).
sgoals_ach_at((AL+1),I_SG,step) :- current_sub_goal_index((AL+1),I_SG,(step-1)); not current_sub_goal_index((AL+1),I_SG,step); pl(AL).
current_sub_goal_index((AL+1),I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
incomplete_plan(step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
#program goal_abstraction_module.
holds(AL,F,V,0) :- final_goal(AL,F,V,true); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
not holds(AL,F,V,0) :- final_goal(AL,F,V,false); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
final_goal(AL,F,V,true) :- holds(AL,F,V,0); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
final_goal(AL,F,V,false) :- not holds(AL,F,V,0); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
{ holds(AL,F,V,0) } :- goal_fluent(AL,F); fluent(AL,inertial,F,V); al(AL).
#false :- not 1 = { holds(AL,F,V,0): fluent(AL,_,F,V) }; goal_fluent(AL,F); fluent(AL,_,F,_); al(AL).
holds(AL,F,false,0) :- not holds(AL,F,true,0); goal_fluent(AL,F); fluent(AL,defined,F,B); boolean(B); al(AL).
#program domain_sorts.
#const abstraction_max = 3.
#const reduc = 3.
#const conde = 2.
#const groun = 1.
class(3,robot).
class(3,armed_robot).
class(3,location).
class(3,room).
class(3,object).
class(3,grounded).
class(3,graspable).
class(3,placeable).
class(3,block).
class(3,surface).
class(3,table).
class(3,colour).
class(3,manipulator_arm).
class(3,grasper).
class(2,door).
class(2,handle).
class(2,configurable).
class(2,extensible).
class(1,cell).
class(1,manipulator_limb).
class(1,manipulator_end).
class(1,side).
super_class(robot,armed_robot).
super_class(location,room).
super_class(location,cell).
super_class(object,robot).
super_class(object,manipulator_arm).
super_class(object,manipulator_limb).
super_class(object,manipulator_end).
super_class(object,table).
super_class(object,side).
super_class(object,block).
super_class(object,grounded).
super_class(grounded,handle).
super_class(configurable,extensible).
super_class(configurable,grasper).
super_class(configurable,door).
super_class(extensible,manipulator_arm).
super_class(extensible,manipulator_limb).
super_class(grasper,manipulator_arm).
super_class(grasper,manipulator_end).
super_class(graspable,block).
super_class(graspable,handle).
super_class(placeable,block).
super_class(surface,table).
super_class(surface,side).
super_class(surface,block).
override_class(manipulator_arm,manipulator_end,grasper).
override_class(manipulator_arm,manipulator_limb,extensible).
override_class(room,cell,location).
override_class(table,side,surface).
state(AL,extensible,extended) :- AL < reduc; al(AL).
state(AL,extensible,retracted) :- AL < reduc; al(AL).
state(AL,manipulator_end,aligned_with(OBJ)) :- insta_of(AL,graspable,OBJ); class(AL,manipulator_end); AL < reduc; al(AL).
state(AL,manipulator_end,aligned_with(nothing)) :- AL < reduc; al(AL).
state(AL,door,open) :- AL < reduc; al(AL).
state(AL,door,closed) :- AL < reduc; al(AL).
static(AL,connected(L_1,L_2)) :- insta_of(AL,location,L_1); insta_of(AL,location,L_2); al(AL).
static(AL,connected_by_door(D,L_1,L_2)) :- insta_of(AL,door,D); insta_of(AL,location,L_1); insta_of(AL,location,L_2); AL < reduc; al(AL).
static(AL,in(OBJ,L)) :- insta_of(AL,object,OBJ); insta_of(AL,grounded,OBJ); insta_of(AL,location,L); AL < reduc; al(AL).
static(AL,colour_of(BLOCK,COLOUR)) :- insta_of(AL,block,BLOCK); insta_of(AL,colour,COLOUR); al(AL).
fluent(AL_1,inertial,in(OBJ),L) :- insta_of(AL_1,location,L); insta_of(AL_2,object,OBJ); OBJ != nothing; not insta_of(AL_2,grounded,OBJ); sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,on(OBJ),SURFACE) :- OBJ != SURFACE; insta_of(AL_1,surface,SURFACE); insta_of(AL_2,placeable,OBJ); sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,grasping(DESC),OBJ) :- insta_of(AL_1,graspable,OBJ); insta_of(AL_2,grasper,DESC); sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,configuration(DESC),STATE) :- state_of(AL_1,DESC,STATE); insta_of(AL_2,configurable,DESC); AL_1 < reduc; AL_2 < reduc; sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,configuration(D),STATE) :- state_of(AL_1,D,STATE); insta_of(AL_2,door,D); AL_1 < reduc; AL_2 < reduc; sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL,defined,tower_base(BASE),B) :- insta_of(AL,block,BASE); sl(AL); boolean(B).
fluent(AL,defined,in_tower(BASE,BLOCK),B) :- insta_of(AL,block,BASE); insta_of(AL,block,BLOCK); sl(AL); boolean(B).
fluent(AL,defined,unordered_tower(BASE),B) :- insta_of(AL,block,BASE); sl(AL); boolean(B).
fluent(AL,defined,complete(COLOUR),B) :- insta_of(AL,colour,COLOUR); sl(AL); boolean(B).
action(AL,sequential,ROBO,move(L)) :- insta_of(AL,robot,ROBO); insta_of(AL,location,L); sl(AL).
action(AL,concurrent,ROBO,grasp(DESC,OBJ)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; sl(AL).
action(AL,concurrent,ROBO,release(DESC,OBJ)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; sl(AL).
action(AL,concurrent,ROBO,configure(DESC,STATE)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,configurable,DESC); state_of(AL,DESC,STATE); AL < reduc; sl(AL).
action(AL,concurrent,ROBO,put(DESC,OBJ,SURFACE)) :- OBJ != SURFACE; SURFACE != nothing; desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); sl(AL).
action(AL,concurrent,ROBO,lift(DESC,OBJ)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); sl(AL).
action(AL,sequential,ROBO,actuate(DESC,D)) :- insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,door,D); AL < reduc; sl(AL).
#program action_effects(t).
effect(AL,ROBO,move(L),in(ROBO),L) :- action(AL,_,ROBO,move(L)); fluent(AL,inertial,in(ROBO),L); insta_of(AL,robot,ROBO); insta_of(AL,location,L); pl(AL).
effect(AL,ROBO,grasp(DESC,OBJ),grasping(DESC),OBJ) :- action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; pl(AL).
effect(AL,ROBO,release(DESC,OBJ),grasping(DESC),nothing) :- action(AL,_,ROBO,release(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); pl(AL).
effect(AL,ROBO,release(END,OBJ),configuration(END),aligned_with(nothing)) :- action(AL,_,ROBO,release(END,OBJ)); fluent(AL,inertial,configuration(END),aligned_with(nothing)); desce_of(AL,ROBO,END); insta_of(AL,armed_robot,ROBO); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); state_of(AL,END,aligned_with(nothing)); AL < reduc; pl(AL).
effect(AL,ROBO,configure(DESC,STATE),configuration(DESC),STATE) :- action(AL,_,ROBO,configure(DESC,STATE)); fluent(AL,inertial,configuration(DESC),STATE); desce_of(AL,ROBO,DESC); insta_of(AL,robot,ROBO); insta_of(AL,configurable,DESC); state_of(AL,DESC,STATE); AL < reduc; pl(AL).
effect(AL,ROBO,configure(ARM,retracted),configuration(END),aligned_with(nothing),t) :- holds(AL,grasping(END),nothing,(t-1)); action(AL,_,ROBO,configure(ARM,retracted)); fluent(AL,inertial,configuration(END),aligned_with(nothing)); desce_of(AL,ROBO,ARM); desce_of(AL,ROBO,END); siblings(AL,ARM,END); insta_of(AL,armed_robot,ROBO); insta_of(AL,extensible,ARM); insta_of(AL,manipulator_end,END); state_of(AL,END,aligned_with(nothing)); AL < reduc; pl(AL).
effect(AL,ROBO,put(DESC,OBJ,SURFACE),on(OBJ),SURFACE) :- action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,on(OBJ),SURFACE); OBJ != SURFACE; SURFACE != nothing; desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); pl(AL).
effect(AL,ROBO,lift(DESC,OBJ),on(OBJ),nothing) :- action(AL,_,ROBO,lift(DESC,OBJ)); fluent(AL,inertial,on(OBJ),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); pl(AL).
effect(AL,ROBO,actuate(DESC,D),configuration(D),STATE_1,t) :- holds(AL,configuration(D),STATE_2,(t-1)); fluent(AL,inertial,configuration(D),STATE_1); fluent(AL,inertial,configuration(D),STATE_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,door,D); state_of(AL,D,STATE_1); state_of(AL,D,STATE_2); STATE_1 != STATE_2; AL < reduc; pl(AL).
#program action_preconditions(t).
1 = { precond(AL,ROBO,move(P_2),in(ROBO),P_1,true,t): is(AL,connected(P_1,P_2)), fluent(AL,inertial,in(ROBO),P_1), static(AL,connected(P_1,P_2)), P_1 != P_2, insta_of(AL,location,P_1) } :- action(AL,_,ROBO,move(P_2)); insta_of(AL,robot,ROBO); insta_of(AL,location,P_2); AL < reduc; pl(AL).
precond(AL,ROBO,move(L_2),configuration(D),open,true,t) :- holds(AL,in(ROBO),L_1,(t-1)); is(AL,connected_by_door(D,L_1,L_2)); L_1 != L_2; action(AL,_,ROBO,move(L_2)); fluent(AL,inertial,configuration(D),open); fluent(AL,_,in(ROBO),L_1); static(AL,connected_by_door(D,L_1,L_2)); insta_of(AL,robot,ROBO); insta_of(AL,location,L_1); insta_of(AL,location,L_2); insta_of(AL,door,D); AL < reduc; pl(AL).
1 = { precond(AL,ROBO,actuate(COMP,D),grasping(COMP),H,true,t): desce_of(AL,D,H), insta_of(AL,handle,H), action(AL,_,ROBO,actuate(COMP,D)), fluent(AL,inertial,grasping(COMP),H) } :- desce_of(AL,ROBO,COMP); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,COMP); insta_of(AL,door,D); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),in(ROBO),L,true) :- is(AL,in(OBJ,L)); action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,in(ROBO),L); static(AL,in(OBJ,L)); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,grounded,OBJ); insta_of(AL,location,L); AL < reduc; pl(AL).
precond(AL,ROBO,move(L),configuration(DESC),retracted,true) :- action(AL,_,ROBO,move(L)); fluent(AL,inertial,configuration(DESC),retracted); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,extensible,DESC); insta_of(AL,location,L); state_of(AL,DESC,retracted); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),in(OBJ),L,true,t) :- holds(AL,in(ROBO),L,(t-1)); OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,in(OBJ),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),in(ROBO),L,true,t) :- holds(AL,in(OBJ),L,(t-1)); OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,in(OBJ),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),grasping(DESC),nothing,true) :- OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ_1),on(OBJ_2),OBJ_1,false) :- OBJ_1 != OBJ_2; OBJ_1 != nothing; action(AL,_,ROBO,grasp(DESC,OBJ_1)); fluent(AL,inertial,on(OBJ_2),OBJ_1); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ_1); insta_of(AL,surface,OBJ_1); insta_of(AL,placeable,OBJ_2); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),configuration(DESC),extended,true) :- OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,configuration(DESC),extended); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,extensible,DESC); insta_of(AL,graspable,OBJ); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(DESC_1,OBJ),configuration(DESC_2),extended,true) :- OBJ != nothing; action(AL,_,ROBO,grasp(DESC_1,OBJ)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC_1); not insta_of(AL,extensible,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,graspable,OBJ); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(END,OBJ),configuration(END),aligned_with(OBJ),true) :- OBJ != nothing; action(AL,_,ROBO,grasp(END,OBJ)); fluent(AL,inertial,configuration(END),aligned_with(OBJ)); desce_of(AL,ROBO,END); insta_of(AL,armed_robot,ROBO); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); state_of(AL,END,aligned_with(OBJ)); AL < reduc; pl(AL).
precond(AL,ROBO,release(DESC,OBJ),grasping(DESC),OBJ,true) :- OBJ != nothing; action(AL,_,ROBO,release(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); pl(AL).
precond(AL,ROBO,release(DESC,OBJ),configuration(DESC),extended,true) :- OBJ != nothing; action(AL,_,ROBO,release(DESC,OBJ)); fluent(AL,inertial,configuration(DESC),extended); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); state_of(AL,DESC,extended); pl(AL); t > 0.
precond(AL,ROBO,release(DESC_1,OBJ),configuration(DESC_2),extended,true) :- OBJ != nothing; action(AL,_,ROBO,release(DESC_1,OBJ)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC_1); not insta_of(AL,extensible,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,graspable,OBJ); pl(AL).
precond(AL,ROBO,configure(DESC_1,STATE),configuration(DESC_2),extended,true) :- action(AL,_,ROBO,configure(DESC_1,STATE)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); desce_of(AL,ROBO,ARM); child_of(AL,ARM,DESC_1); child_of(AL,ARM,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,configurable,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,manipulator_arm,ARM); state_of(AL,DESC_1,STATE); AL < reduc; pl(AL).
precond(AL,ROBO,configure(DESC,aligned_with(OBJ)),grasping(DESC),nothing,true) :- action(AL,_,ROBO,configure(DESC,aligned_with(OBJ))); fluent(AL,inertial,grasping(DESC),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,manipulator_end,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; state_of(AL,DESC,aligned_with(OBJ)); AL < reduc; pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),in(SURFACE),L,true,t) :- holds(AL,in(ROBO),L,(t-1)); action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,in(SURFACE),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),in(ROBO),L,true,t) :- holds(AL,in(SURFACE),L,(t-1)); action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,in(SURFACE),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,put(DESC,OBJ_1,BLOCK),on(OBJ_2),BLOCK,false) :- OBJ_1 != OBJ_2; action(AL,_,ROBO,put(DESC,OBJ_1,SURFACE)); fluent(AL,inertial,on(OBJ_2),BLOCK); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ_1); insta_of(AL,placeable,OBJ_2); insta_of(AL,block,BLOCK); pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),grasping(DESC),OBJ,true) :- OBJ != SURFACE; OBJ != nothing; SURFACE != nothing; action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); pl(AL).
precond(AL,ROBO_1,put(DESC_1,OBJ_1,OBJ_2),grasping(DESC_2),OBJ_2,false) :- OBJ_1 != OBJ_2; DESC_1 != DESC_2; action(AL,_,ROBO,put(DESC_1,OBJ_1,OBJ_2)); fluent(AL,inertial,grasping(DESC_2),OBJ_2); desce_of(AL,ROBO_1,DESC_1); desce_of(AL,ROBO_2,DESC_2); insta_of(AL,armed_robot,ROBO_1); insta_of(AL,armed_robot,ROBO_2); insta_of(AL,grasper,DESC_1); insta_of(AL,grasper,DESC_2); insta_of(AL,placeable,OBJ_1); insta_of(AL,surface,OBJ_2); insta_of(AL,graspable,OBJ_2); pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),configuration(DESC),extended,true) :- action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,configuration(DESC),extended); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,extensible,DESC); insta_of(AL,graspable,OBJ); insta_of(AL,surface,SURFACE); AL < reduc; pl(AL).
precond(AL,ROBO,put(DESC_1,OBJ,SURFACE),configuration(DESC_2),extended,true) :- action(AL,_,ROBO,put(DESC_1,OBJ,SURFACE)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC_1); not insta_of(AL,extensible,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,graspable,OBJ); insta_of(AL,surface,SURFACE); AL < reduc; pl(AL).
precond(AL,ROBO,lift(DESC,OBJ_1),on(OBJ_2),OBJ_1,false) :- OBJ_1 != OBJ_2; action(AL,_,ROBO,lift(DESC,OBJ_1)); fluent(AL,inertial,on(OBJ_2),OBJ_1); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ_1); insta_of(AL,surface,OBJ_1); insta_of(AL,placeable,OBJ_2); pl(AL).
precond(AL,ROBO,lift(DESC,OBJ),grasping(DESC),OBJ,true) :- OBJ != SURFACE; action(AL,_,ROBO,lift(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,surface,SURFACE); pl(AL).
#program variable_relations(t).
#false :- holds(AL,grasping(DESC),OBJ,t); holds(AL,in(ROBO),L,t); not holds(AL,in(OBJ),L,t): not insta_of(AL,grounded,OBJ), fluent(AL,inertial,in(OBJ),L); not is(AL,in(OBJ,L)): insta_of(AL,grounded,OBJ), static(AL,in(OBJ,L)); fluent(AL,inertial,grasping(DESC),OBJ); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,location,L); sl(AL).
#false :- holds(AL,configuration(END),aligned_with(OBJ),t); holds(AL,in(ROBO),L,t); not holds(AL,in(OBJ),L,t): not insta_of(AL,grounded,OBJ), fluent(AL,inertial,in(OBJ),L); not is(AL,in(OBJ,L)): insta_of(AL,grounded,OBJ), static(AL,in(OBJ,L)); fluent(AL,inertial,configuration(END),aligned_with(OBJ)); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,END); insta_of(AL,robot,ROBO); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,location,L); state_of(AL,END,aligned_with(OBJ)); sl(AL).
#false :- holds(AL,grasping(END),OBJ,t); not holds(AL,configuration(END),aligned_with(OBJ),t); fluent(AL,inertial,grasping(END),OBJ); fluent(AL,inertial,configuration(END),aligned_with(OBJ)); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); OBJ != nothing; state_of(AL,END,aligned_with(OBJ)); sl(AL).
#false :- holds(AL,grasping(DESC),OBJ_1,t); holds(AL,on(OBJ_2),OBJ_1,t); fluent(AL,inertial,grasping(DESC),OBJ_1); fluent(AL,inertial,on(OBJ_2),OBJ_1); desce_of(AL,ROBO,DESC); insta_of(AL,robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ_1); OBJ_1 != nothing; insta_of(AL,surface,OBJ_1); insta_of(AL,placeable,OBJ_2); sl(AL).
#false :- holds(AL,on(OBJ),SURFACE,t); holds(AL,in(SURFACE),L,t); not holds(AL,in(OBJ),L,t); fluent(AL,inertial,on(OBJ),SURFACE); fluent(AL,inertial,in(SURFACE),L); fluent(AL,inertial,in(OBJ),L); insta_of(AL,location,L); insta_of(AL,location,L); insta_of(AL,surface,SURFACE); insta_of(AL,object,OBJ); sl(AL).
#false :- holds(AL,on(BLOCK_1),BLOCK_2,t); holds(AL,on(BLOCK_2),nothing,t); fluent(AL,inertial,on(BLOCK_1),BLOCK_2); fluent(AL,inertial,on(BLOCK_2),nothing); insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); sl(AL).
#false :- holds(AL,on(BLOCK_1),BLOCK_3,t); holds(AL,on(BLOCK_2),BLOCK_3,t); fluent(AL,inertial,on(BLOCK_1),BLOCK_3); fluent(AL,inertial,on(BLOCK_2),BLOCK_3); BLOCK_1 != BLOCK_2; insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); insta_of(AL,block,BLOCK_3); sl(AL).
holds(AL,tower_base(BASE),true,t) :- holds(AL,on(BASE),TABLE,t); fluent(AL,defined,tower_base(BASE),true); fluent(AL,inertial,on(BASE),TABLE); insta_of(AL,block,BASE); insta_of(AL,table,TABLE); sl(AL).
holds(AL,tower_base(BASE),true,t) :- holds(AL,on(BASE),SURFACE,t); fluent(AL,defined,tower_base(BASE),true); fluent(AL,inertial,on(BASE),SURFACE); desce_of(AL,TABLE,SURFACE); insta_of(AL,block,BASE); insta_of(AL,surface,SURFACE); insta_of(AL,table,TABLE); sl(AL).
holds(AL,in_tower(BASE,BASE),true,t) :- holds(AL,tower_base(BASE),true,t); fluent(AL,defined,in_tower(BASE,BASE),true); fluent(AL,defined,tower_base(BASE),true); insta_of(AL,block,BASE); sl(AL).
holds(AL,in_tower(BLOCK_1,BLOCK_2),true,t) :- holds(AL,on(BLOCK_2),BLOCK_3,t); holds(AL,in_tower(BLOCK_1,BLOCK_3),true,t); fluent(AL,defined,in_tower(BLOCK_1,BLOCK_2),true); fluent(AL,defined,in_tower(BLOCK_1,BLOCK_3),true); fluent(AL,inertial,on(BLOCK_2),BLOCK_3); BLOCK_1 != BLOCK_2; insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); insta_of(AL,block,BLOCK_3); sl(AL).
holds(AL,unordered_tower(BASE),true,t) :- holds(AL,on(BLOCK_1),BLOCK_2,t); holds(AL,in_tower(BASE,BLOCK_1),true,t); holds(AL,in_tower(BASE,BLOCK_2),true,t); holds(AL,tower_base(BASE),true,t); fluent(AL,defined,unordered_tower(BASE),true); fluent(AL,defined,in_tower(BASE,BLOCK_1),true); fluent(AL,defined,in_tower(BASE,BLOCK_2),true); fluent(AL,defined,tower_base(BASE),true); fluent(AL,inertial,on(BLOCK_1),BLOCK_2); BLOCK_1 = (block,N_1); number(N_1); BLOCK_2 = (block,N_2); number(N_2); BLOCK_1 != BLOCK_2; N_1 > N_2; insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); insta_of(AL,block,BASE); sl(AL).
holds(AL,complete(COLOUR),true,t) :- N = #count { BLOCK: holds(AL,in_tower(BASE,BLOCK),true,t), is(AL,colour_of(BLOCK,COLOUR)), fluent(AL,defined,in_tower(BASE,BLOCK),true), static(AL,colour_of(BLOCK,COLOUR)), insta_of(AL,block,BLOCK) }; N = #count { BLOCK: is(AL,colour_of(BLOCK,COLOUR)), static(AL,colour_of(BLOCK,COLOUR)), insta_of(AL,block,BLOCK) }; holds(AL,unordered_tower(BASE),false,t); holds(AL,tower_base(BASE),true,t); fluent(AL,defined,unordered_tower(BASE),true); fluent(AL,defined,tower_base(BASE),true); is(AL,colour_of(BASE,COLOUR)); static(AL,colour_of(BASE,COLOUR)); insta_of(AL,colour,COLOUR); insta_of(AL,block,BASE); sl(AL).
#program abstraction_mappings(t).
is(AL_1,connected(L_1,L_2)) :- is(AL_2,connected(L_1_C,L_2_C)); static(AL_1,connected(L_1,L_2)); static(AL_2,connected(L_1_C,L_2_C)); L_1 != L_2; desce_of(AL_2,L_1,L_1_C); desce_of(AL_2,L_2,L_2_C); insta_of(AL_1,location,L_1); insta_of(AL_1,location,L_2); insta_of(AL_2,location,L_1_C); insta_of(AL_2,location,L_2_C); al(AL_1); al(AL_2); AL_1 >= AL_2.
is(AL_1,connected(L_1,L_2)) :- is(AL_2,connected(L_1,L_2)); static(AL_1,connected(L_1,L_2)); static(AL_2,connected(L_1,L_2)); L_1 != L_2; insta_of(AL_1,location,L_1); insta_of(AL_1,location,L_2); insta_of(AL_2,location,L_1); insta_of(AL_2,location,L_2); al(AL_1); al(AL_2); AL_1 >= AL_2.
is(AL_1,connected_by_door(D,L_1,L_2)) :- is(AL_2,connected_by_door(D,L_1_C,L_2_C)); static(AL_1,connected_by_door(D,L_1,L_2)); static(AL_2,connected_by_door(D,L_1_C,L_2_C)); L_1 != L_2; desce_of(AL_2,L_1,L_1_C); desce_of(AL_2,L_2,L_2_C); insta_of(AL_1,door,D); insta_of(AL_2,door,D); insta_of(AL_1,location,L_1); insta_of(AL_1,location,L_2); insta_of(AL_2,location,L_1_C); insta_of(AL_2,location,L_2_C); al(AL_1); al(AL_2); AL_1 >= AL_2.
is(AL_1,in(OBJ,L_1)) :- is(AL_2,in(OBJ,L_2)); static(AL_1,in(OBJ,L_1)); static(AL_2,in(OBJ,L_2)); desce_of(AL_2,L_1,L_2); insta_of(AL_1,location,L_1); insta_of(AL_1,object,OBJ); insta_of(AL_1,grounded,OBJ); insta_of(AL_1,location,L_1); insta_of(AL_2,location,L_2); al(AL_1); al(AL_2); AL_1 >= AL_2.
holds(AL_1,in(OBJ),L_1,t) :- holds(AL_2,in(OBJ),L_2,t); fluent(AL_1,inertial,in(OBJ),L_1); fluent(AL_2,inertial,in(OBJ),L_2); desce_of(AL_2,L_1,L_2); insta_of(AL_1,location,L_1); insta_of(AL_2,location,L_2); insta_of(AL_3,object,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
holds(AL_1,in(OBJ),L,t) :- holds(AL_2,in(OBJ),L,t); fluent(AL_1,inertial,in(OBJ),L); fluent(AL_2,inertial,in(OBJ),L); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,object,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
holds(AL_1,in(DESC),L,t) :- holds(AL_2,in(OBJ),L,t); fluent(AL_1,inertial,in(DESC),L); fluent(AL_2,inertial,in(OBJ),L); desce_of(AL_2,OBJ,DESC); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,object,OBJ); insta_of(AL_4,_,DESC); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_2; sl(AL_4); AL_4 >= AL_1.
holds(AL_1,in(OBJ),L,t) :- holds(AL_2,in(DESC),L,t); fluent(AL_1,inertial,in(OBJ),L); fluent(AL_2,inertial,in(DESC),L); desce_of(AL_2,OBJ,DESC); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,object,OBJ); insta_of(AL_4,_,DESC); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_2.
holds(AL_1,in(OBJ),L,t) :- holds(AL_2,in(ROBO),L,t); holds(AL_3,grasping(DESC),OBJ,t); fluent(AL_1,inertial,in(OBJ),L); fluent(AL_2,inertial,in(ROBO),L); fluent(AL_3,inertial,grasping(DESC),OBJ); desce_of(AL_2,ROBO,DESC); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,graspable,OBJ); OBJ != nothing; insta_of(AL_4,grasper,DESC); insta_of(AL_5,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_3; sl(AL_5); AL_5 >= AL_3.
holds(AL_1,grasping(DESC),OBJ_1,t) :- holds(AL_2,grasping(DESC),OBJ_2,t); fluent(AL_1,inertial,grasping(DESC),OBJ_1); fluent(AL_2,inertial,grasping(DESC),OBJ_2); desce_of(AL_2,ROBO,DESC); desce_of(AL_2,OBJ_1,OBJ_2); insta_of(AL_1,graspable,OBJ_1); insta_of(AL_2,graspable,OBJ_2); insta_of(AL_3,grasper,DESC); insta_of(AL_4,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_1.
holds(AL_1,grasping(DESC_1),OBJ,t) :- holds(AL_2,grasping(DESC_2),OBJ,t); fluent(AL_1,inertial,grasping(DESC_1),OBJ); fluent(AL_2,inertial,grasping(DESC_2),OBJ); desce_of(AL_2,ROBO,DESC_1); desce_of(AL_2,ROBO,DESC_2); desce_of(AL_2,DESC_1,DESC_2); insta_of(AL_1,graspable,OBJ); insta_of(AL_2,graspable,OBJ); insta_of(AL_3,grasper,DESC_1); insta_of(AL_4,grasper,DESC_2); insta_of(AL_5,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_2; sl(AL_5); AL_5 >= AL_1.
holds(AL_1,grasping(DESC),OBJ,t) :- holds(AL_2,grasping(DESC),OBJ,t); fluent(AL_1,inertial,grasping(DESC),OBJ); fluent(AL_2,inertial,grasping(DESC),OBJ); desce_of(AL_2,ROBO,DESC); insta_of(AL_1,graspable,OBJ); insta_of(AL_2,graspable,OBJ); insta_of(AL_3,grasper,DESC); insta_of(AL_4,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_1; boolean(B).
holds(AL_1,configuration(DESC_1),STATE,t) :- holds(AL_2,configuration(DESC_2),STATE,t); fluent(AL_1,inertial,configuration(DESC_1),STATE); fluent(AL_2,inertial,configuration(DESC_2),STATE); desce_of(AL_2,DESC_1,DESC_2); state_of(AL_1,DESC_1,STATE); state_of(AL_2,DESC_2,STATE); insta_of(AL_1,configurable,DESC_1); insta_of(AL_2,configurable,DESC_2); sl(AL_1); sl(AL_2); AL_1 >= AL_2.
holds(AL_1,configuration(DESC),STATE,t) :- holds(AL_2,configuration(DESC),STATE,t); fluent(AL_1,inertial,configuration(DESC),STATE); fluent(AL_2,inertial,configuration(DESC),STATE); state_of(AL_1,DESC,STATE); state_of(AL_2,DESC,STATE); insta_of(AL_1,configurable,DESC); insta_of(AL_2,configurable,DESC); sl(AL_1); sl(AL_2); AL_1 >= AL_2.
holds(AL_1,on(OBJ),SURFACE_1,t) :- holds(AL_2,on(OBJ),SURFACE_2,t); fluent(AL_1,inertial,on(OBJ),SURFACE_1); fluent(AL_2,inertial,on(OBJ),SURFACE_2); desce_of(AL_2,SURFACE_1,SURFACE_2); insta_of(AL_1,surface,SURFACE_1); insta_of(AL_2,surface,SURFACE_2); insta_of(AL_3,placeable,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
holds(AL_1,on(OBJ),SURFACE,t) :- holds(AL_2,on(OBJ),SURFACE,t); fluent(AL_1,inertial,on(OBJ),SURFACE); fluent(AL_2,inertial,on(OBJ),SURFACE); insta_of(AL_1,surface,SURFACE); insta_of(AL_2,surface,SURFACE); insta_of(AL_3,placeable,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
#program static_state.
is(1,connected((starting_room,1),(hallway,1))).
is(1,connected((store_room,1),(hallway,0))).
is(1,connected((hallway,2),(puzzle_room,0))).
is(1,connected_by_door(store_room_door,(store_room,1),(hallway,0))).
is(1,connected_by_door(puzzle_room_door,(hallway,2),(puzzle_room,0))).
is(1,in(store_room_door_handle_inner,(store_room,1))).
is(1,in(store_room_door_handle_outer,(hallway,0))).
is(1,in(starting_room_door_handle_inner,(starting_room,1))).
is(1,in(starting_room_door_handle_outer,(hallway,1))).
is(1,in(puzzle_room_door_handle_inner,(puzzle_room,0))).
is(1,in(puzzle_room_door_handle_outer,(hallway,2))).
is(AL,colour_of((BLOCK,N),red)) :- static(AL,colour_of((BLOCK,N),red)); insta_of(AL,block,(BLOCK,N)); N <= 3; al(AL).
is(AL,colour_of((BLOCK,N),blue)) :- static(AL,colour_of((BLOCK,N),blue)); insta_of(AL,block,(BLOCK,N)); N > 3; N <= 6; al(AL).
is(1,connected((A,X_1),(A,X_2))) :- insta_of(1,cell,(A,X_1)); insta_of(1,cell,(A,X_2)); X_2 = (X_1+1).
is(1,connected(C_1,C_2)) :- is(1,connected(C_2,C_1)); insta_of(1,cell,C_1); insta_of(1,cell,C_2).
is(1,connected_by_door(D,C_1,C_2)) :- is(1,connected_by_door(D,C_2,C_1)); insta_of(1,door,D); insta_of(1,cell,C_1); insta_of(1,cell,C_2).
#program initial_state.
holds(1,in(talos),(starting_room,0),0).
holds(AL,grasping(DESC),nothing,0) :- fluent(AL,inertial,grasping(DESC),nothing); insta_of(AL,grasper,DESC); al(AL).
holds(AL,configuration(DESC),retracted,0) :- fluent(AL,inertial,configuration(DESC),retracted); insta_of(AL,extensible,DESC); sl(AL).
holds(1,configuration(END),aligned_with(nothing),0) :- fluent(AL,inertial,configuration(END),aligned_with(nothing)); insta_of(AL,manipulator_end,END); state_of(AL,END,aligned_with(nothing)); sl(AL).
holds(1,configuration(DOOR),closed,0) :- fluent(AL,inertial,configuration(DOOR),closed); insta_of(AL,door,DOOR); state_of(AL,DOOR,closed); sl(AL).
holds(1,in(puzzle_room_table),(puzzle_room,1),0).
holds(1,on((block,1)),puzzle_room_table_left,0).
holds(1,on((block,2)),puzzle_room_table_right,0).
holds(1,on((block,3)),(block,1),0).
holds(1,in((block,4)),(store_room,0),0).
holds(1,in((block,5)),(store_room,0),0).
holds(1,in((block,6)),(store_room,0),0).
holds(1,on((block,4)),nothing,0).
holds(1,on((block,5)),nothing,0).
holds(1,on((block,6)),nothing,0).
#program goal_state.
goal_fluent(AL,complete(COLOUR)) :- insta_of(AL,colour,COLOUR); al(AL).
goal_fluent(AL,on((block,3))) :- al(AL).
goal_fluent(AL,on((block,6))) :- al(AL).
final_goal(AL,complete(COLOUR),true,true) :- insta_of(AL,colour,COLOUR); al(AL).
final_goal(1,on((block,3)),puzzle_room_table_left,true).
final_goal(1,on((block,6)),puzzle_room_table_right,true).
#program entities.
entity(armed_robot,talos).
entity(manipulator_arm,manipulator_arm_1).
entity(manipulator_limb,manipulator_limb_1).
entity(manipulator_end,manipulator_end_1).
entity(manipulator_arm,manipulator_arm_2).
entity(manipulator_limb,manipulator_limb_2).
entity(manipulator_end,manipulator_end_2).
number((1..6)).
entity(block,(block,N)) :- number(N).
entity(room,starting_room).
entity(room,store_room).
entity(room,puzzle_room).
entity(room,hallway).
x((0..3)).
size(starting_room,2).
size(store_room,2).
size(hallway,3).
size(puzzle_room,2).
entity(cell,(ROOM,X)) :- entity(room,ROOM); size(ROOM,MAX); X < MAX; x(X).
entity(door,store_room_door).
entity(door,starting_room_door).
entity(door,puzzle_room_door).
entity(handle,store_room_door_handle_inner).
entity(handle,store_room_door_handle_outer).
entity(handle,starting_room_door_handle_inner).
entity(handle,starting_room_door_handle_outer).
entity(handle,puzzle_room_door_handle_inner).
entity(handle,puzzle_room_door_handle_outer).
entity(table,puzzle_room_table).
entity(side,puzzle_room_table_left).
entity(side,puzzle_room_table_right).
entity(colour,red).
entity(colour,blue).
entity(surface,nothing).
entity(graspable,nothing).
ancestry_relation(talos,manipulator_arm_1).
ancestry_relation(talos,manipulator_arm_2).
ancestry_relation(manipulator_arm_1,manipulator_limb_1).
ancestry_relation(manipulator_arm_2,manipulator_limb_2).
ancestry_relation(manipulator_arm_1,manipulator_end_1).
ancestry_relation(manipulator_arm_2,manipulator_end_2).
ancestry_relation(ROOM,(ROOM,X)) :- entity(room,ROOM); entity(cell,(ROOM,X)); x(X).
ancestry_relation(store_room_door,store_room_door_handle_inner).
ancestry_relation(store_room_door,store_room_door_handle_outer).
ancestry_relation(starting_room_door,starting_room_door_handle_inner).
ancestry_relation(starting_room_door,starting_room_door_handle_outer).
ancestry_relation(puzzle_room_door,puzzle_room_door_handle_inner).
ancestry_relation(puzzle_room_door,puzzle_room_door_handle_outer).
ancestry_relation(puzzle_room_table,puzzle_room_table_left).
ancestry_relation(puzzle_room_table,puzzle_room_table_right)., Main #1 || Generate Final Goals #1))
	('solver_options', ['--models=2', '--parallel-mode=8,compete', '--warn=none'])
	('assumptions', [])
	('context', None)
	('solve_incrementor', None)
	('base_parts', [('entities', []), ('static_state', []), ('goal_state', []), ('abstraction_levels', [1, 'hierarchical']), ('instance_module', []), ('goal_abstraction_module', []), ('domain_sorts', []), ('variable_relations', [0]), ('abstraction_mappings', [0])])
	('inc_parts', [IncPart(name='step', args=['#inc'], range_=None)])
	('incremental', False)

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Setting input storing variables:
	solver_options = ['--models=2', '--parallel-mode=8,compete', '--warn=none']
	assumptions = []
	context = None
	incrementor = None
	base_parts = [('entities', []), ('static_state', []), ('goal_state', []), ('abstraction_levels', [1, 'hierarchical']), ('instance_module', []), ('goal_abstraction_module', []), ('domain_sorts', []), ('variable_relations', [0]), ('abstraction_mappings', [0])]
	inc_parts = [IncPart(name='step', args=['#inc'], range_=None)]

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Output storing variables reset.

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Program building started :: Processing 331 rules

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Program building completed in 0.003894799999999865s

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Running one-shot ground and solve of program parts:
[BasePart(name='entities', args=[]), BasePart(name='static_state', args=[]), BasePart(name='goal_state', args=[]), BasePart(name='abstraction_levels', args=[1, 'hierarchical']), BasePart(name='instance_module', args=[]), BasePart(name='goal_abstraction_module', args=[]), BasePart(name='domain_sorts', args=[]), BasePart(name='variable_relations', args=[0]), BasePart(name='abstraction_mappings', args=[0])]

[15-09-2021_15-49-16] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Grounding program parts:
[('entities', []), ('static_state', []), ('goal_state', []), ('abstraction_levels', [Number(1), Function('hierarchical', [], True)]), ('instance_module', []), ('goal_abstraction_module', []), ('domain_sorts', []), ('variable_relations', [Number(0)]), ('abstraction_mappings', [Number(0)])]

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Grounding completed in 0.056513s.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Solving program.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Model found:
Model :: Total atoms = 2599, Cost = (), Optimality proven = False, Number = 1, Thread ID = 2, Model type = ModelType.StableModel

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Solving completed in 0.007674s with result Satisfiable.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Freeing held grounding...

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Setting input storing variables:
	solver_options = []
	assumptions = []
	context = None
	incrementor = None
	base_parts = []
	inc_parts = []

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Held grounding freed.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Returning from standard solve call:
Result :: SATISFIABLE : SEARCH EXHAUSTED : Total models = 1
Statistics :: Grounding = 0.056513s, Solving = 0.007674s, Total = 0.064186s, Memory = (RSS = 86.000000b, VMS = 76.000000b)
Final Model :: Total atoms = 2599, Cost = (), Optimality proven = False, Number = 1, Thread ID = 2, Model type = ModelType.StableModel

[15-09-2021_15-49-17] INFO :: ASH Planner Main #1 >> Final goals generated successfully:
Result :: SATISFIABLE : SEARCH EXHAUSTED
Statistics :: Grounding = 0.056513s, Solving = 0.007674s, Total = 0.064186s, Memory = (RSS = 86.000000b, VMS = 76.000000b)
Model :: Total atoms = 2599, Cost = (), Optimality proven = False, Number = 1, Thread ID = 2, Model type = ModelType.StableModel

[15-09-2021_15-49-17] DEBUG :: ASH Planner Main #1 >> The given partial final goal has a unique complete interpretation (only one stable model exists).

[15-09-2021_15-49-17] DEBUG :: ASH Planner Main #1 >> 

          ========================================          
             Final goal at abstraction level 3              
          ========================================          

final_goal(3, complete(blue), false, false)
final_goal(3, complete(blue), true, true)
final_goal(3, complete(red), false, false)
final_goal(3, complete(red), true, true)
final_goal(3, on((block,3)), (block,1), false)
final_goal(3, on((block,3)), (block,2), false)
final_goal(3, on((block,3)), (block,4), false)
final_goal(3, on((block,3)), (block,5), false)
final_goal(3, on((block,3)), (block,6), false)
final_goal(3, on((block,3)), nothing, false)
final_goal(3, on((block,3)), puzzle_room_table, true)
final_goal(3, on((block,6)), (block,1), false)
final_goal(3, on((block,6)), (block,2), false)
final_goal(3, on((block,6)), (block,3), false)
final_goal(3, on((block,6)), (block,4), false)
final_goal(3, on((block,6)), (block,5), false)
final_goal(3, on((block,6)), nothing, false)
final_goal(3, on((block,6)), puzzle_room_table, true)

[15-09-2021_15-49-17] DEBUG :: ASH Planner Main #1 >> 

          ========================================          
             Final goal at abstraction level 2              
          ========================================          

final_goal(2, complete(blue), false, false)
final_goal(2, complete(blue), true, true)
final_goal(2, complete(red), false, false)
final_goal(2, complete(red), true, true)
final_goal(2, on((block,3)), (block,1), false)
final_goal(2, on((block,3)), (block,2), false)
final_goal(2, on((block,3)), (block,4), false)
final_goal(2, on((block,3)), (block,5), false)
final_goal(2, on((block,3)), (block,6), false)
final_goal(2, on((block,3)), nothing, false)
final_goal(2, on((block,3)), puzzle_room_table, true)
final_goal(2, on((block,6)), (block,1), false)
final_goal(2, on((block,6)), (block,2), false)
final_goal(2, on((block,6)), (block,3), false)
final_goal(2, on((block,6)), (block,4), false)
final_goal(2, on((block,6)), (block,5), false)
final_goal(2, on((block,6)), nothing, false)
final_goal(2, on((block,6)), puzzle_room_table, true)

[15-09-2021_15-49-17] DEBUG :: ASH Planner Main #1 >> 

          ========================================          
             Final goal at abstraction level 1              
          ========================================          

final_goal(1, complete(blue), false, false)
final_goal(1, complete(blue), true, true)
final_goal(1, complete(red), false, false)
final_goal(1, complete(red), true, true)
final_goal(1, on((block,3)), (block,1), false)
final_goal(1, on((block,3)), (block,2), false)
final_goal(1, on((block,3)), (block,4), false)
final_goal(1, on((block,3)), (block,5), false)
final_goal(1, on((block,3)), (block,6), false)
final_goal(1, on((block,3)), nothing, false)
final_goal(1, on((block,3)), puzzle_room_table_left, true)
final_goal(1, on((block,3)), puzzle_room_table_right, false)
final_goal(1, on((block,6)), (block,1), false)
final_goal(1, on((block,6)), (block,2), false)
final_goal(1, on((block,6)), (block,3), false)
final_goal(1, on((block,6)), (block,4), false)
final_goal(1, on((block,6)), (block,5), false)
final_goal(1, on((block,6)), nothing, false)
final_goal(1, on((block,6)), puzzle_room_table_left, false)
final_goal(1, on((block,6)), puzzle_room_table_right, true)

[15-09-2021_15-49-17] INFO :: ASH Planner Main #1 >> Hierarchical planning problem successfully initialised:
Initial State is UNIQUE, Final-Goal is UNIQUE

[15-09-2021_15-49-17] INFO :: ASH Planner Main #1 >> Generating hierarchical plan : LEVELS [1-3] : OFFLINE MODE

[15-09-2021_15-49-17] DEBUG :: ASH Planner Main #1 >> Arguments:
	('bottom_level', 1)
	('top_level', None)
	('concurrency', False)
	('conformance', True)
	('conformance_type', <ConformanceType.SequentialAchievement: 'sequential'>)
	('sequential_yield', True)
	('division_strategy', None)
	('online_method', <OnlineMethod.GroundFirst: 'ground-first'>)
	('save_grounding', False)
	('use_minimum_search_length_bound', False)
	('avoid_refining_sgoals_marked_for_blending', True)
	('make_observable', False)
	('preempt_pos_fgoals', None)
	('preempt_neg_fgoals', None)
	('order_fgoals_achievement', None)
	('minimise_actions', None)
	('detect_interleaving', False)
	('detect_dependencies', False)
	('generate_search_space', False)
	('generate_solution_space', False)
	('time_limit', 3600)
	('length_limit', {1: 150, 2: 100, 3: 50})
	('pause_on_level_change', False)
	('pause_on_increment_change', False)
	('level_range', range(1, 4))
	('online', False)
	('self', HierarchicalPlanner(PlanningDomain(['./test_problems/blocks_world_plus/BWP_system_laws.lp', './test_problems/blocks_world_plus/BWP_problem_small_3.lp'], Anon #1), Main #1, 8, Verbosity.Standard, True))

[15-09-2021_15-49-17] DEBUG :: ASH Planner Main #1 >> Current refinement diagram progress:
Level 3 : Total sgoals 0 : Achieved sgoals 0 : Unachieved sgoals 0
Level 2 : Total sgoals 0 : Achieved sgoals 0 : Unachieved sgoals 0
Level 1 : Total sgoals 0 : Achieved sgoals 0 : Unachieved sgoals 0

[15-09-2021_15-49-17] INFO :: ASH Planner Main #1 >> Current planning increment level range: [1-3]

[15-09-2021_15-49-17] DEBUG :: ASH Planner Main #1 >> Starting top-level classical planning: level = 3

[15-09-2021_15-49-17] DEBUG :: ASH Planner Main #1 >> Starting monolevel planning with input arguments
	('concurrency', False)
	('conformance', False)
	('conformance_type', <ConformanceType.SequentialAchievement: 'sequential'>)
	('first_sgoals', None)
	('last_sgoals', None)
	('sequential_yield', True)
	('reactive_callback', None)
	('save_grounding', False)
	('use_saved_grounding', False)
	('use_minimum_search_length_bound', False)
	('make_observable', False)
	('minimise_actions', None)
	('preempt_pos_fgoals', None)
	('preempt_neg_fgoals', None)
	('order_fgoals_achievement', None)
	('detect_interleaving', False)
	('generate_search_space', False)
	('generate_solution_space', False)
	('time_limit', 3600)
	('length_limit', 50)
	('level', 3)
	('self', HierarchicalPlanner(PlanningDomain(['./test_problems/blocks_world_plus/BWP_system_laws.lp', './test_problems/blocks_world_plus/BWP_problem_small_3.lp'], Anon #1), Main #1, 8, Verbosity.Standard, True))

[15-09-2021_15-49-17] DEBUG :: ASH Planner Main #1 >> Problem type obtained: start step = 0, initial = True, final = True, sgoals = [1-1]

[15-09-2021_15-49-17] DEBUG :: ASH Planner Main #1 >> Minimum search length bound: enabled = False, value = 0

[15-09-2021_15-49-17] INFO :: ASH Planner Main #1 >> Generating monolevel plan : Level 3, Problem type = classical , Concurrency = disabled

[15-09-2021_15-49-17] DEBUG :: ASH Planner Main #1 >> Optimisation details:Action minimisation = False
Positive final goal preemptive achievement = False
Negative final goal preemptive achievement = False
Final goal intermediate achievement ordering preferences = False

[15-09-2021_15-49-17] DEBUG :: Logic Program ASH #1 >> Creating copy of self: rename = Main #1 :: Generate monolevel plan

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Instantiating logic program...

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Setting input storing variables:
	solver_options = []
	assumptions = []
	context = None
	incrementor = None
	base_parts = []
	inc_parts = []

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Output storing variables reset.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Logic program instantiated.

[15-09-2021_15-49-17] DEBUG :: ASH Planner Main #1 >> Adding start state as initial state...

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> The logic program was extended with 68 rules into program part ash_initial_state.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> The logic program was extended with 18 rules into program part ash_goal_state.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Starting new incremental solve call.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Setting input storing variables:
	solver_options = ['--models=1', '--heuristic=Domain', '--stats', '--parallel-mode=8,compete', '--warn=none', '--opt-mode=ignore']
	assumptions = []
	context = None
	incrementor = SolveIncrementor(step_start=0, step_increase=1, step_increase_initial=2, step_end_min=None, step_end_max=50, stop_condition=<SolveResult.Satisfiable: 'SAT'>, increment_limit=None, increment_time_limit=None, cumulative_time_limit=3600, preempt=False)
	base_parts = [BasePart(name='base', args=()), BasePart(name='abstraction_levels', args=(3, 'classical')), BasePart(name='entities', args=()), BasePart(name='domain_sorts', args=()), BasePart(name='instance_module', args=()), BasePart(name='static_state', args=()), BasePart(name='ash_initial_state', args=()), BasePart(name='ash_goal_state', args=())]
	inc_parts = [IncPart(name='action_effects', args=('#inc',), range_=None), IncPart(name='action_preconditions', args=('#inc',), range_=None), IncPart(name='variable_relations', args=('#inc',), range_=None), IncPart(name='abstraction_mappings', args=('#inc',), range_=None), IncPart(name='state_module', args=('#inc', 0), range_=None), IncPart(name='plan_module', args=('#inc', 0, 'false', 'true'), range_=None), IncPart(name='optimisation_module', args=('#inc', 0, 'false', 'false', 'false', 'false', 'false', 'false'), range_=None)]

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Output storing variables reset.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Program building started :: Processing 421 rules

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Program building completed in 0.004505300000000156s

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Running one-shot ground and solve of program parts:
[BasePart(name='base', args=()), BasePart(name='abstraction_levels', args=(3, 'classical')), BasePart(name='entities', args=()), BasePart(name='domain_sorts', args=()), BasePart(name='instance_module', args=()), BasePart(name='static_state', args=()), BasePart(name='ash_initial_state', args=()), BasePart(name='ash_goal_state', args=())]

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('base', []), ('abstraction_levels', [Number(3), Function('classical', [], True)]), ('entities', []), ('domain_sorts', []), ('instance_module', []), ('static_state', []), ('ash_initial_state', []), ('ash_goal_state', [])]

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.026026s.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Model found:
Model :: Total atoms = 1636, Cost = (), Optimality proven = False, Number = 1, Thread ID = 0, Model type = ModelType.StableModel

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.006138s with result Satisfiable.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Creating solve signal...

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solve signal created:
<ASP_Parser.SolveSignal object at 0x000001971FDA1220>

[15-09-2021_15-49-17] DEBUG :: ASH Planner Main #1 >> Starting search:
	self
	solve_signal
	level
	start_step
	first_sgoals
	last_sgoals
	finalise
	sequential_yield
	detect_interleaving
	make_observable
	reactive_callback

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Running incremental ground and solve of program parts:
#program action_effects(#inc). %* None *%
#program action_preconditions(#inc). %* None *%
#program variable_relations(#inc). %* None *%
#program abstraction_mappings(#inc). %* None *%
#program state_module(#inc, 0). %* None *%
#program plan_module(#inc, 0, false, true). %* None *%
#program optimisation_module(#inc, 0, false, false, false, false, false, false). %* None *%

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [1]:
Running step bounds   | Previous =     -1 : Current =      1
Incrementor step ends | Minimum  =   None : Maximum =     50

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(1)]), ('action_effects', [Number(0)]), ('action_preconditions', [Number(0)]), ('variable_relations', [Number(0)]), ('abstraction_mappings', [Number(0)]), ('state_module', [Number(0), Number(0)]), ('plan_module', [Number(0), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(0), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('action_effects', [Number(1)]), ('action_preconditions', [Number(1)]), ('variable_relations', [Number(1)]), ('abstraction_mappings', [Number(1)]), ('state_module', [Number(1), Number(0)]), ('plan_module', [Number(1), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(1), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.088594s.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.010530s with result Unsatisfiable.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [1]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.09912450000000006, Incremental time limit = None
Running cumulative time = 0.09912450000000006, Cumulative time limit = 3600
(RSS = 90.000000b, VMS = 79.000000b)

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [2]:
Running step bounds   | Previous =      1 : Current =      2
Incrementor step ends | Minimum  =   None : Maximum =     50

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(2)]), ('action_effects', [Number(2)]), ('action_preconditions', [Number(2)]), ('variable_relations', [Number(2)]), ('abstraction_mappings', [Number(2)]), ('state_module', [Number(2), Number(0)]), ('plan_module', [Number(2), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(2), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.060959s.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.003235s with result Unsatisfiable.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [2]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.06419350000000001, Incremental time limit = None
Running cumulative time = 0.16331800000000007, Cumulative time limit = 3600
(RSS = 91.000000b, VMS = 81.000000b)

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [3]:
Running step bounds   | Previous =      2 : Current =      3
Incrementor step ends | Minimum  =   None : Maximum =     50

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(3)]), ('action_effects', [Number(3)]), ('action_preconditions', [Number(3)]), ('variable_relations', [Number(3)]), ('abstraction_mappings', [Number(3)]), ('state_module', [Number(3), Number(0)]), ('plan_module', [Number(3), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(3), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.078274s.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.008220s with result Unsatisfiable.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [3]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.08649400000000007, Incremental time limit = None
Running cumulative time = 0.24981200000000015, Cumulative time limit = 3600
(RSS = 92.000000b, VMS = 82.000000b)

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [4]:
Running step bounds   | Previous =      3 : Current =      4
Incrementor step ends | Minimum  =   None : Maximum =     50

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(4)]), ('action_effects', [Number(4)]), ('action_preconditions', [Number(4)]), ('variable_relations', [Number(4)]), ('abstraction_mappings', [Number(4)]), ('state_module', [Number(4), Number(0)]), ('plan_module', [Number(4), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(4), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.075983s.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.007781s with result Unsatisfiable.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [4]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.0837642999999999, Incremental time limit = None
Running cumulative time = 0.33357630000000005, Cumulative time limit = 3600
(RSS = 94.000000b, VMS = 84.000000b)

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [5]:
Running step bounds   | Previous =      4 : Current =      5
Incrementor step ends | Minimum  =   None : Maximum =     50

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(5)]), ('action_effects', [Number(5)]), ('action_preconditions', [Number(5)]), ('variable_relations', [Number(5)]), ('abstraction_mappings', [Number(5)]), ('state_module', [Number(5), Number(0)]), ('plan_module', [Number(5), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(5), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.069291s.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.010800s with result Unsatisfiable.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [5]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.08009120000000003, Incremental time limit = None
Running cumulative time = 0.4136675000000001, Cumulative time limit = 3600
(RSS = 96.000000b, VMS = 86.000000b)

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [6]:
Running step bounds   | Previous =      5 : Current =      6
Incrementor step ends | Minimum  =   None : Maximum =     50

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(6)]), ('action_effects', [Number(6)]), ('action_preconditions', [Number(6)]), ('variable_relations', [Number(6)]), ('abstraction_mappings', [Number(6)]), ('state_module', [Number(6), Number(0)]), ('plan_module', [Number(6), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(6), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.077641s.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.009581s with result Unsatisfiable.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [6]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.08722279999999993, Incremental time limit = None
Running cumulative time = 0.5008903, Cumulative time limit = 3600
(RSS = 98.000000b, VMS = 88.000000b)

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [7]:
Running step bounds   | Previous =      6 : Current =      7
Incrementor step ends | Minimum  =   None : Maximum =     50

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(7)]), ('action_effects', [Number(7)]), ('action_preconditions', [Number(7)]), ('variable_relations', [Number(7)]), ('abstraction_mappings', [Number(7)]), ('state_module', [Number(7), Number(0)]), ('plan_module', [Number(7), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(7), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.078084s.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.012185s with result Unsatisfiable.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [7]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.09026939999999994, Incremental time limit = None
Running cumulative time = 0.5911597, Cumulative time limit = 3600
(RSS = 101.000000b, VMS = 92.000000b)

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [8]:
Running step bounds   | Previous =      7 : Current =      8
Incrementor step ends | Minimum  =   None : Maximum =     50

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(8)]), ('action_effects', [Number(8)]), ('action_preconditions', [Number(8)]), ('variable_relations', [Number(8)]), ('abstraction_mappings', [Number(8)]), ('state_module', [Number(8), Number(0)]), ('plan_module', [Number(8), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(8), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.068288s.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.014813s with result Unsatisfiable.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [8]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.08310059999999986, Incremental time limit = None
Running cumulative time = 0.6742602999999998, Cumulative time limit = 3600
(RSS = 103.000000b, VMS = 93.000000b)

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [9]:
Running step bounds   | Previous =      8 : Current =      9
Incrementor step ends | Minimum  =   None : Maximum =     50

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(9)]), ('action_effects', [Number(9)]), ('action_preconditions', [Number(9)]), ('variable_relations', [Number(9)]), ('abstraction_mappings', [Number(9)]), ('state_module', [Number(9), Number(0)]), ('plan_module', [Number(9), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(9), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.066172s.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.014803s with result Unsatisfiable.

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [9]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.08097459999999979, Incremental time limit = None
Running cumulative time = 0.7552348999999996, Cumulative time limit = 3600
(RSS = 107.000000b, VMS = 98.000000b)

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [10]:
Running step bounds   | Previous =      9 : Current =     10
Incrementor step ends | Minimum  =   None : Maximum =     50

[15-09-2021_15-49-17] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(10)]), ('action_effects', [Number(10)]), ('action_preconditions', [Number(10)]), ('variable_relations', [Number(10)]), ('abstraction_mappings', [Number(10)]), ('state_module', [Number(10), Number(0)]), ('plan_module', [Number(10), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(10), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.096779s.

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.018237s with result Unsatisfiable.

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [10]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.11501560000000044, Incremental time limit = None
Running cumulative time = 0.8702505, Cumulative time limit = 3600
(RSS = 109.000000b, VMS = 100.000000b)

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [11]:
Running step bounds   | Previous =     10 : Current =     11
Incrementor step ends | Minimum  =   None : Maximum =     50

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(11)]), ('action_effects', [Number(11)]), ('action_preconditions', [Number(11)]), ('variable_relations', [Number(11)]), ('abstraction_mappings', [Number(11)]), ('state_module', [Number(11), Number(0)]), ('plan_module', [Number(11), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(11), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.113138s.

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.019866s with result Unsatisfiable.

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [11]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.13300420000000024, Incremental time limit = None
Running cumulative time = 1.0032547000000003, Cumulative time limit = 3600
(RSS = 113.000000b, VMS = 103.000000b)

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [12]:
Running step bounds   | Previous =     11 : Current =     12
Incrementor step ends | Minimum  =   None : Maximum =     50

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(12)]), ('action_effects', [Number(12)]), ('action_preconditions', [Number(12)]), ('variable_relations', [Number(12)]), ('abstraction_mappings', [Number(12)]), ('state_module', [Number(12), Number(0)]), ('plan_module', [Number(12), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(12), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.087172s.

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.033142s with result Unsatisfiable.

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [12]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.12031349999999996, Incremental time limit = None
Running cumulative time = 1.1235682000000002, Cumulative time limit = 3600
(RSS = 116.000000b, VMS = 106.000000b)

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [13]:
Running step bounds   | Previous =     12 : Current =     13
Incrementor step ends | Minimum  =   None : Maximum =     50

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(13)]), ('action_effects', [Number(13)]), ('action_preconditions', [Number(13)]), ('variable_relations', [Number(13)]), ('abstraction_mappings', [Number(13)]), ('state_module', [Number(13), Number(0)]), ('plan_module', [Number(13), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(13), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.095791s.

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.031738s with result Unsatisfiable.

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [13]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.12752830000000026, Incremental time limit = None
Running cumulative time = 1.2510965000000005, Cumulative time limit = 3600
(RSS = 121.000000b, VMS = 112.000000b)

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [14]:
Running step bounds   | Previous =     13 : Current =     14
Incrementor step ends | Minimum  =   None : Maximum =     50

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(14)]), ('action_effects', [Number(14)]), ('action_preconditions', [Number(14)]), ('variable_relations', [Number(14)]), ('abstraction_mappings', [Number(14)]), ('state_module', [Number(14), Number(0)]), ('plan_module', [Number(14), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(14), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.078004s.

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.040990s with result Unsatisfiable.

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [14]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.11899349999999975, Incremental time limit = None
Running cumulative time = 1.3700900000000003, Cumulative time limit = 3600
(RSS = 123.000000b, VMS = 114.000000b)

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [15]:
Running step bounds   | Previous =     14 : Current =     15
Incrementor step ends | Minimum  =   None : Maximum =     50

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(15)]), ('action_effects', [Number(15)]), ('action_preconditions', [Number(15)]), ('variable_relations', [Number(15)]), ('abstraction_mappings', [Number(15)]), ('state_module', [Number(15), Number(0)]), ('plan_module', [Number(15), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(15), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.088657s.

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.077419s with result Unsatisfiable.

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [15]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.1660763000000003, Incremental time limit = None
Running cumulative time = 1.5361663000000005, Cumulative time limit = 3600
(RSS = 125.000000b, VMS = 116.000000b)

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [16]:
Running step bounds   | Previous =     15 : Current =     16
Incrementor step ends | Minimum  =   None : Maximum =     50

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(16)]), ('action_effects', [Number(16)]), ('action_preconditions', [Number(16)]), ('variable_relations', [Number(16)]), ('abstraction_mappings', [Number(16)]), ('state_module', [Number(16), Number(0)]), ('plan_module', [Number(16), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(16), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.077974s.

[15-09-2021_15-49-18] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-19] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.163955s with result Unsatisfiable.

[15-09-2021_15-49-19] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [16]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.24192930000000024, Incremental time limit = None
Running cumulative time = 1.7780956000000008, Cumulative time limit = 3600
(RSS = 127.000000b, VMS = 118.000000b)

[15-09-2021_15-49-19] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [17]:
Running step bounds   | Previous =     16 : Current =     17
Incrementor step ends | Minimum  =   None : Maximum =     50

[15-09-2021_15-49-19] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(17)]), ('action_effects', [Number(17)]), ('action_preconditions', [Number(17)]), ('variable_relations', [Number(17)]), ('abstraction_mappings', [Number(17)]), ('state_module', [Number(17), Number(0)]), ('plan_module', [Number(17), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(17), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[15-09-2021_15-49-19] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.089370s.

[15-09-2021_15-49-19] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-19] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.235683s with result Unsatisfiable.

[15-09-2021_15-49-19] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [17]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.32505330000000043, Incremental time limit = None
Running cumulative time = 2.103148900000001, Cumulative time limit = 3600
(RSS = 131.000000b, VMS = 122.000000b)

[15-09-2021_15-49-19] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [18]:
Running step bounds   | Previous =     17 : Current =     18
Incrementor step ends | Minimum  =   None : Maximum =     50

[15-09-2021_15-49-19] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(18)]), ('action_effects', [Number(18)]), ('action_preconditions', [Number(18)]), ('variable_relations', [Number(18)]), ('abstraction_mappings', [Number(18)]), ('state_module', [Number(18), Number(0)]), ('plan_module', [Number(18), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(18), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[15-09-2021_15-49-19] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.088111s.

[15-09-2021_15-49-19] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-19] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.453420s with result Unsatisfiable.

[15-09-2021_15-49-19] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [18]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.5415318000000005, Incremental time limit = None
Running cumulative time = 2.6446807000000017, Cumulative time limit = 3600
(RSS = 137.000000b, VMS = 129.000000b)

[15-09-2021_15-49-19] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [19]:
Running step bounds   | Previous =     18 : Current =     19
Incrementor step ends | Minimum  =   None : Maximum =     50

[15-09-2021_15-49-19] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(19)]), ('action_effects', [Number(19)]), ('action_preconditions', [Number(19)]), ('variable_relations', [Number(19)]), ('abstraction_mappings', [Number(19)]), ('state_module', [Number(19), Number(0)]), ('plan_module', [Number(19), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(19), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[15-09-2021_15-49-20] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.081768s.

[15-09-2021_15-49-20] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-20] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.845293s with result Unsatisfiable.

[15-09-2021_15-49-20] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [19]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.9270605999999999, Incremental time limit = None
Running cumulative time = 3.571741300000002, Cumulative time limit = 3600
(RSS = 144.000000b, VMS = 136.000000b)

[15-09-2021_15-49-20] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [20]:
Running step bounds   | Previous =     19 : Current =     20
Incrementor step ends | Minimum  =   None : Maximum =     50

[15-09-2021_15-49-20] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(20)]), ('action_effects', [Number(20)]), ('action_preconditions', [Number(20)]), ('variable_relations', [Number(20)]), ('abstraction_mappings', [Number(20)]), ('state_module', [Number(20), Number(0)]), ('plan_module', [Number(20), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(20), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[15-09-2021_15-49-20] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.082697s.

[15-09-2021_15-49-20] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Model found:
Model :: Total atoms = 7476, Cost = (), Optimality proven = False, Number = 1, Thread ID = 5, Model type = ModelType.StableModel

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.166621s with result Satisfiable.

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [20]:
Result = SolveResult.Satisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.24931840000000083, Incremental time limit = None
Running cumulative time = 3.821059700000003, Cumulative time limit = 3600
(RSS = 148.000000b, VMS = 141.000000b)

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Incremental solving has found a model, current answer:
Result :: SATISFIABLE : SEARCH INTERRUPTED : Total models = 2
IncrementalStatistics :: Cumulative = (Statistics :: Grounding = 1.642747s, Solving = 2.178313s, Total = 3.821060s, Memory = (RSS = 0.000000b, VMS = 0.000000b)), Calls = 20
Final Model :: Total atoms = 7476, Cost = (), Optimality proven = False, Number = 1, Thread ID = 5, Model type = ModelType.StableModel

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Incremental statistics:
1 : Statistics :: Grounding = 0.088594s, Solving = 0.010530s, Total = 0.099125s, Memory = (RSS = 90.000000b, VMS = 79.000000b)
2 : Statistics :: Grounding = 0.060959s, Solving = 0.003235s, Total = 0.064194s, Memory = (RSS = 91.000000b, VMS = 81.000000b)
3 : Statistics :: Grounding = 0.078274s, Solving = 0.008220s, Total = 0.086494s, Memory = (RSS = 92.000000b, VMS = 82.000000b)
4 : Statistics :: Grounding = 0.075983s, Solving = 0.007781s, Total = 0.083764s, Memory = (RSS = 94.000000b, VMS = 84.000000b)
5 : Statistics :: Grounding = 0.069291s, Solving = 0.010800s, Total = 0.080091s, Memory = (RSS = 96.000000b, VMS = 86.000000b)
6 : Statistics :: Grounding = 0.077641s, Solving = 0.009581s, Total = 0.087223s, Memory = (RSS = 98.000000b, VMS = 88.000000b)
7 : Statistics :: Grounding = 0.078084s, Solving = 0.012185s, Total = 0.090269s, Memory = (RSS = 101.000000b, VMS = 92.000000b)
8 : Statistics :: Grounding = 0.068288s, Solving = 0.014813s, Total = 0.083101s, Memory = (RSS = 103.000000b, VMS = 93.000000b)
9 : Statistics :: Grounding = 0.066172s, Solving = 0.014803s, Total = 0.080975s, Memory = (RSS = 107.000000b, VMS = 98.000000b)
10 : Statistics :: Grounding = 0.096779s, Solving = 0.018237s, Total = 0.115016s, Memory = (RSS = 109.000000b, VMS = 100.000000b)
11 : Statistics :: Grounding = 0.113138s, Solving = 0.019866s, Total = 0.133004s, Memory = (RSS = 113.000000b, VMS = 103.000000b)
12 : Statistics :: Grounding = 0.087172s, Solving = 0.033142s, Total = 0.120313s, Memory = (RSS = 116.000000b, VMS = 106.000000b)
13 : Statistics :: Grounding = 0.095791s, Solving = 0.031738s, Total = 0.127528s, Memory = (RSS = 121.000000b, VMS = 112.000000b)
14 : Statistics :: Grounding = 0.078004s, Solving = 0.040990s, Total = 0.118993s, Memory = (RSS = 123.000000b, VMS = 114.000000b)
15 : Statistics :: Grounding = 0.088657s, Solving = 0.077419s, Total = 0.166076s, Memory = (RSS = 125.000000b, VMS = 116.000000b)
16 : Statistics :: Grounding = 0.077974s, Solving = 0.163955s, Total = 0.241929s, Memory = (RSS = 127.000000b, VMS = 118.000000b)
17 : Statistics :: Grounding = 0.089370s, Solving = 0.235683s, Total = 0.325053s, Memory = (RSS = 131.000000b, VMS = 122.000000b)
18 : Statistics :: Grounding = 0.088111s, Solving = 0.453420s, Total = 0.541532s, Memory = (RSS = 137.000000b, VMS = 129.000000b)
19 : Statistics :: Grounding = 0.081768s, Solving = 0.845293s, Total = 0.927061s, Memory = (RSS = 144.000000b, VMS = 136.000000b)
20 : Statistics :: Grounding = 0.082697s, Solving = 0.166621s, Total = 0.249318s, Memory = (RSS = 148.000000b, VMS = 141.000000b)

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Incremental ground and solve completed in 3.821060s because Stop condition reached.

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Stopping incremental solve call.

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Freeing held grounding...

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Setting input storing variables:
	solver_options = []
	assumptions = []
	context = None
	incrementor = None
	base_parts = []
	inc_parts = []

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Held grounding freed.

[15-09-2021_15-49-21] INFO :: ASH Planner Main #1 >> Search ended :: Last achieved goal index = 1, Last requested goal index = 1 (100.0% solved):
Search finished as expected, the requested partial problem has been solved entirely.

[15-09-2021_15-49-21] INFO :: ASH Planner Main #1 >> Monolevel plan generated successfully:
Result :: SATISFIABLE : SEARCH INTERRUPTED : COMPLETE PLAN OBTAINED
IncrementalStatistics :: Cumulative = (Statistics :: Grounding = 1.642747s, Solving = 2.178313s, Total = 3.821060s, Memory = (RSS = 0.000000b, VMS = 0.000000b)), Calls = 20
Model :: Total atoms = 7476, Cost = (), Optimality proven = False, Number = 1, Thread ID = 5, Model type = ModelType.StableModel

[15-09-2021_15-49-21] INFO :: ASH Planner Main #1 >> 

          ========================================          
                Plan at abstraction level 3                 
          ========================================          
                 Steps = 20 :: Actions = 20                 
                ----------------------------                

(1, [{'L': 3, 'R': 'talos', 'A': 'move(store_room)', 'S': 1}])
(2, [{'L': 3, 'R': 'talos', 'A': 'grasp(manipulator_arm_2,(block,6))', 'S': 2}])
(3, [{'L': 3, 'R': 'talos', 'A': 'move(puzzle_room)', 'S': 3}])
(4, [{'L': 3, 'R': 'talos', 'A': 'put(manipulator_arm_2,(block,6),puzzle_room_table)', 'S': 4}])
(5, [{'L': 3, 'R': 'talos', 'A': 'grasp(manipulator_arm_1,(block,2))', 'S': 5}])
(6, [{'L': 3, 'R': 'talos', 'A': 'release(manipulator_arm_2,(block,6))', 'S': 6}])
(7, [{'L': 3, 'R': 'talos', 'A': 'grasp(manipulator_arm_2,(block,3))', 'S': 7}])
(8, [{'L': 3, 'R': 'talos', 'A': 'put(manipulator_arm_2,(block,3),puzzle_room_table)', 'S': 8}])
(9, [{'L': 3, 'R': 'talos', 'A': 'release(manipulator_arm_2,(block,3))', 'S': 9}])
(10, [{'L': 3, 'R': 'talos', 'A': 'put(manipulator_arm_1,(block,2),(block,3))', 'S': 10}])
(11, [{'L': 3, 'R': 'talos', 'A': 'release(manipulator_arm_1,(block,2))', 'S': 11}])
(12, [{'L': 3, 'R': 'talos', 'A': 'move(store_room)', 'S': 12}])
(13, [{'L': 3, 'R': 'talos', 'A': 'grasp(manipulator_arm_2,(block,5))', 'S': 13}])
(14, [{'L': 3, 'R': 'talos', 'A': 'grasp(manipulator_arm_1,(block,4))', 'S': 14}])
(15, [{'L': 3, 'R': 'talos', 'A': 'move(puzzle_room)', 'S': 15}])
(16, [{'L': 3, 'R': 'talos', 'A': 'put(manipulator_arm_2,(block,5),(block,6))', 'S': 16}])
(17, [{'L': 3, 'R': 'talos', 'A': 'release(manipulator_arm_2,(block,5))', 'S': 17}])
(18, [{'L': 3, 'R': 'talos', 'A': 'grasp(manipulator_arm_2,(block,1))', 'S': 18}])
(19, [{'L': 3, 'R': 'talos', 'A': 'put(manipulator_arm_1,(block,4),(block,5))', 'S': 19}])
(20, [{'L': 3, 'R': 'talos', 'A': 'put(manipulator_arm_2,(block,1),(block,2))', 'S': 20}])

[15-09-2021_15-49-21] DEBUG :: ASH Planner Main #1 >> Starting refinement planning: level = 2, sgoals range = [0-21], problem number = 1, increment number = 1

[15-09-2021_15-49-21] DEBUG :: ASH Planner Main #1 >> Starting monolevel planning with input arguments
	('concurrency', False)
	('conformance', True)
	('conformance_type', <ConformanceType.SequentialAchievement: 'sequential'>)
	('first_sgoals', 0)
	('last_sgoals', 21)
	('sequential_yield', True)
	('reactive_callback', None)
	('save_grounding', False)
	('use_saved_grounding', False)
	('use_minimum_search_length_bound', False)
	('make_observable', False)
	('minimise_actions', None)
	('preempt_pos_fgoals', None)
	('preempt_neg_fgoals', None)
	('order_fgoals_achievement', None)
	('detect_interleaving', False)
	('generate_search_space', False)
	('generate_solution_space', False)
	('time_limit', 3600)
	('length_limit', 100)
	('level', 2)
	('self', HierarchicalPlanner(PlanningDomain(['./test_problems/blocks_world_plus/BWP_system_laws.lp', './test_problems/blocks_world_plus/BWP_problem_small_3.lp'], Anon #1), Main #1, 8, Verbosity.Standard, True))

[15-09-2021_15-49-21] DEBUG :: ASH Planner Main #1 >> Problem type obtained: start step = 0, initial = True, final = True, sgoals = [1-20]

[15-09-2021_15-49-21] DEBUG :: ASH Planner Main #1 >> Minimum search length bound: enabled = False, value = 20

[15-09-2021_15-49-21] INFO :: ASH Planner Main #1 >> Generating monolevel plan : Level 2, Problem type = complete conformance refinement, achievement type = sequential, sgoals range = [1-20], Concurrency = disabled

[15-09-2021_15-49-21] DEBUG :: ASH Planner Main #1 >> Optimisation details:Action minimisation = False
Positive final goal preemptive achievement = False
Negative final goal preemptive achievement = False
Final goal intermediate achievement ordering preferences = False

[15-09-2021_15-49-21] DEBUG :: Logic Program ASH #1 >> Creating copy of self: rename = Main #1 :: Generate monolevel plan

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Instantiating logic program...

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Setting input storing variables:
	solver_options = []
	assumptions = []
	context = None
	incrementor = None
	base_parts = []
	inc_parts = []

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Output storing variables reset.

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Logic program instantiated.

[15-09-2021_15-49-21] DEBUG :: ASH Planner Main #1 >> Adding start state as initial state...

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> The logic program was extended with 141 rules into program part ash_initial_state.

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> The logic program was extended with 36 rules into program part ash_goal_state.

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> The logic program was extended with 20 rules into program part conformance_module(step, start, first, last, type, yield).

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Starting new incremental solve call.

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Setting input storing variables:
	solver_options = ['--models=1', '--heuristic=Domain', '--stats', '--parallel-mode=8,compete', '--warn=none', '--opt-mode=ignore']
	assumptions = []
	context = None
	incrementor = SolveIncrementor(step_start=0, step_increase=1, step_increase_initial=2, step_end_min=None, step_end_max=100, stop_condition=None, increment_limit=None, increment_time_limit=None, cumulative_time_limit=3600, preempt=False)
	base_parts = [BasePart(name='base', args=()), BasePart(name='abstraction_levels', args=(2, 'refinement')), BasePart(name='entities', args=()), BasePart(name='domain_sorts', args=()), BasePart(name='instance_module', args=()), BasePart(name='static_state', args=()), BasePart(name='ash_initial_state', args=()), BasePart(name='ash_goal_state', args=())]
	inc_parts = [IncPart(name='action_effects', args=('#inc',), range_=None), IncPart(name='action_preconditions', args=('#inc',), range_=None), IncPart(name='variable_relations', args=('#inc',), range_=None), IncPart(name='abstraction_mappings', args=('#inc',), range_=None), IncPart(name='state_module', args=('#inc', 0), range_=None), IncPart(name='plan_module', args=('#inc', 0, 'false', 'false'), range_=None), IncPart(name='optimisation_module', args=('#inc', 0, 'false', 'false', 'false', 'false', 'false', 'false'), range_=None), IncPart(name='conformance_module', args=('#inc', 0, 1, 20, 'sequential', 'true'), range_=None)]

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Output storing variables reset.

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Program building started :: Processing 534 rules

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Program building completed in 0.0038786000000001764s

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Running one-shot ground and solve of program parts:
[BasePart(name='base', args=()), BasePart(name='abstraction_levels', args=(2, 'refinement')), BasePart(name='entities', args=()), BasePart(name='domain_sorts', args=()), BasePart(name='instance_module', args=()), BasePart(name='static_state', args=()), BasePart(name='ash_initial_state', args=()), BasePart(name='ash_goal_state', args=())]

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('base', []), ('abstraction_levels', [Number(2), Function('refinement', [], True)]), ('entities', []), ('domain_sorts', []), ('instance_module', []), ('static_state', []), ('ash_initial_state', []), ('ash_goal_state', [])]

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.028407s.

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Model found:
Model :: Total atoms = 2092, Cost = (), Optimality proven = False, Number = 1, Thread ID = 0, Model type = ModelType.StableModel

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.004979s with result Satisfiable.

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Creating solve signal...

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solve signal created:
<ASP_Parser.SolveSignal object at 0x000001971FD724F0>

[15-09-2021_15-49-21] DEBUG :: ASH Planner Main #1 >> Starting search:
	self
	solve_signal
	level
	start_step
	first_sgoals
	last_sgoals
	finalise
	sequential_yield
	detect_interleaving
	make_observable
	reactive_callback

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Queueing external: External(symbol='current_last_sgoals(1, 0)', truth=True, inc_range=IncRange(start=0, end=1, step=1))

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Running incremental ground and solve of program parts:
#program action_effects(#inc). %* None *%
#program action_preconditions(#inc). %* None *%
#program variable_relations(#inc). %* None *%
#program abstraction_mappings(#inc). %* None *%
#program state_module(#inc, 0). %* None *%
#program plan_module(#inc, 0, false, false). %* None *%
#program optimisation_module(#inc, 0, false, false, false, false, false, false). %* None *%
#program conformance_module(#inc, 0, 1, 20, sequential, true). %* None *%

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [1]:
Running step bounds   | Previous =     -1 : Current =      1
Incrementor step ends | Minimum  =   None : Maximum =    100

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(1)]), ('action_effects', [Number(0)]), ('action_preconditions', [Number(0)]), ('variable_relations', [Number(0)]), ('abstraction_mappings', [Number(0)]), ('state_module', [Number(0), Number(0)]), ('plan_module', [Number(0), Number(0), Function('false', [], True), Function('false', [], True)]), ('optimisation_module', [Number(0), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('conformance_module', [Number(0), Number(0), Number(1), Number(20), Function('sequential', [], True), Function('true', [], True)]), ('action_effects', [Number(1)]), ('action_preconditions', [Number(1)]), ('variable_relations', [Number(1)]), ('abstraction_mappings', [Number(1)]), ('state_module', [Number(1), Number(0)]), ('plan_module', [Number(1), Number(0), Function('false', [], True), Function('false', [], True)]), ('optimisation_module', [Number(1), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('conformance_module', [Number(1), Number(0), Number(1), Number(20), Function('sequential', [], True), Function('true', [], True)])]

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.107051s.

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Assigning queued external: original = External(symbol='current_last_sgoals(1, 0)', truth=True, inc_range=IncRange(start=0, end=1, step=1)), conversion = current_last_sgoals(1,0).

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.009158s with result Unsatisfiable.

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [1]:
Result = SolveResult.Unsatisfiable, Stop condition = None
Increment time = 0.11620950000000008, Incremental time limit = None
Running cumulative time = 0.11620950000000008, Cumulative time limit = 3600
(RSS = 105.000000b, VMS = 98.000000b)

[15-09-2021_15-49-21] DEBUG :: ASH Planner Main #1 >> Increment feedback: Feedback(increment=1, start_step=0, end_step=2, solve_result=<SolveResult.Unsatisfiable: 'UNSAT'>, cumulative_statistics=Statistics(grounding_time=0.10705110000000051, solving_time=0.009158399999999567, total_time=0.11620950000000008, memory=Memory(rss=0.0, vms=0.0), step_range=range(0, 2), clingo_stats={}), increment_statistics=Statistics(grounding_time=0.10705110000000051, solving_time=0.009158399999999567, total_time=0.11620950000000008, memory=Memory(rss=105, vms=98), step_range=range(0, 2), clingo_stats={'problem': {'lp': {'atoms': 7667.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 16519.0, 'bodies_tr': 16519.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 231.0, 'count_bodies_tr': 231.0, 'sccs': 20.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 360.0, 'rules': 34266.0, 'rules_normal': 33927.0, 'rules_choice': 339.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 34266.0, 'rules_tr_normal': 33927.0, 'rules_tr_choice': 339.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 12636.0, 'eqs_atom': 3165.0, 'eqs_body': 1057.0, 'eqs_other': 8414.0}, 'lpStep': {'atoms': 3790.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 15343.0, 'bodies_tr': 15343.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 231.0, 'count_bodies_tr': 231.0, 'sccs': 20.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 360.0, 'rules': 30080.0, 'rules_normal': 29741.0, 'rules_choice': 339.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 30080.0, 'rules_tr_normal': 29741.0, 'rules_tr_choice': 339.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 6890.0, 'eqs_atom': 1078.0, 'eqs_body': 292.0, 'eqs_other': 5520.0}, 'generator': {'vars': 1554.0, 'vars_eliminated': 0.0, 'vars_frozen': 1090.0, 'constraints': 52.0, 'constraints_binary': 856.0, 'constraints_ternary': 17.0, 'acyc_edges': 0.0, 'complexity': 943.0}}, 'solving': {'solvers': {'choices': 0.0, 'conflicts': 0.0, 'conflicts_analyzed': 0.0, 'restarts': 0.0, 'restarts_last': 0.0, 'extra': {'domain_choices': 0.0, 'models': 0.0, 'models_level': 0.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 0.0, 'distributed_sum_lbd': 0.0, 'integrated': 0.0, 'lemmas': 4.0, 'lits_learnt': 4.0, 'lemmas_binary': 0.0, 'lemmas_ternary': 0.0, 'cpu_time': 0.0, 'integrated_imps': 0.0, 'integrated_jumps': 0.0, 'guiding_paths_lits': 308.0, 'guiding_paths': 7.0, 'splits': 0.0, 'lemmas_conflict': 0.0, 'lemmas_loop': 4.0, 'lemmas_other': 0.0, 'lits_conflict': 0.0, 'lits_loop': 4.0, 'lits_other': 0.0, 'jumps': {'jumps': 0.0, 'jumps_bounded': 0.0, 'levels': 0.0, 'levels_bounded': 0.0, 'max': 0.0, 'max_executed': 0.0, 'max_bounded': 0.0}}}}, 'summary': {'call': 1.0, 'result': 2.0, 'signal': 0.0, 'exhausted': 1.0, 'costs': [], 'lower': [], 'concurrency': 8.0, 'winner': 0.0, 'times': {'total': 0.11668586730957031, 'cpu': 0.109375, 'solve': 0.0009975433349609375, 'unsat': 0.0009975433349609375, 'sat': 0.0}, 'models': {'enumerated': 0.0, 'optimal': 0.0}}, 'accu': {'times': {'total': 0.15458297729492188, 'cpu': 0.140625, 'solve': 0.00399017333984375, 'unsat': 0.0009975433349609375, 'sat': 0.00099945068359375}, 'models': {'enumerated': 1.0, 'optimal': 0.0}, 'solving': {'solvers': {'choices': 0.0, 'conflicts': 0.0, 'conflicts_analyzed': 0.0, 'restarts': 0.0, 'restarts_last': 0.0, 'extra': {'domain_choices': 0.0, 'models': 1.0, 'models_level': 1.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 0.0, 'distributed_sum_lbd': 0.0, 'integrated': 0.0, 'lemmas': 4.0, 'lits_learnt': 4.0, 'lemmas_binary': 0.0, 'lemmas_ternary': 0.0, 'cpu_time': 0.0, 'integrated_imps': 0.0, 'integrated_jumps': 0.0, 'guiding_paths_lits': 316.0, 'guiding_paths': 15.0, 'splits': 0.0, 'lemmas_conflict': 0.0, 'lemmas_loop': 4.0, 'lemmas_other': 0.0, 'lits_conflict': 0.0, 'lits_loop': 4.0, 'lits_other': 0.0, 'jumps': {'jumps': 0.0, 'jumps_bounded': 0.0, 'levels': 0.0, 'levels_bounded': 0.0, 'max': 0.0, 'max_executed': 0.0, 'max_bounded': 0.0}}}}}, 'user_step': {}, 'user_accu': {}}))

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [2]:
Running step bounds   | Previous =      1 : Current =      2
Incrementor step ends | Minimum  =   None : Maximum =    100

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(2)]), ('action_effects', [Number(2)]), ('action_preconditions', [Number(2)]), ('variable_relations', [Number(2)]), ('abstraction_mappings', [Number(2)]), ('state_module', [Number(2), Number(0)]), ('plan_module', [Number(2), Number(0), Function('false', [], True), Function('false', [], True)]), ('optimisation_module', [Number(2), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('conformance_module', [Number(2), Number(0), Number(1), Number(20), Function('sequential', [], True), Function('true', [], True)])]

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.070769s.

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.004507s with result Unsatisfiable.

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [2]:
Result = SolveResult.Unsatisfiable, Stop condition = None
Increment time = 0.07527559999999944, Incremental time limit = None
Running cumulative time = 0.19148509999999952, Cumulative time limit = 3600
(RSS = 107.000000b, VMS = 101.000000b)

[15-09-2021_15-49-21] DEBUG :: ASH Planner Main #1 >> Increment feedback: Feedback(increment=2, start_step=2, end_step=3, solve_result=<SolveResult.Unsatisfiable: 'UNSAT'>, cumulative_statistics=Statistics(grounding_time=0.1778196999999997, solving_time=0.013665399999999828, total_time=0.19148509999999952, memory=Memory(rss=0.0, vms=0.0), step_range=range(0, 3), clingo_stats={}), increment_statistics=Statistics(grounding_time=0.07076859999999918, solving_time=0.004507000000000261, total_time=0.07527559999999944, memory=Memory(rss=107, vms=101), step_range=range(2, 3), clingo_stats={'problem': {'lp': {'atoms': 9255.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 29634.0, 'bodies_tr': 29634.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 414.0, 'count_bodies_tr': 414.0, 'sccs': 26.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 412.0, 'rules': 60050.0, 'rules_normal': 59555.0, 'rules_choice': 495.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 60050.0, 'rules_tr_normal': 59555.0, 'rules_tr_choice': 495.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 15302.0, 'eqs_atom': 3794.0, 'eqs_body': 1368.0, 'eqs_other': 10140.0}, 'lpStep': {'atoms': 1588.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 13115.0, 'bodies_tr': 13115.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 183.0, 'count_bodies_tr': 183.0, 'sccs': 6.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 52.0, 'rules': 25784.0, 'rules_normal': 25628.0, 'rules_choice': 156.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 25784.0, 'rules_tr_normal': 25628.0, 'rules_tr_choice': 156.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 2666.0, 'eqs_atom': 629.0, 'eqs_body': 311.0, 'eqs_other': 1726.0}, 'generator': {'vars': 1725.0, 'vars_eliminated': 0.0, 'vars_frozen': 1251.0, 'constraints': 110.0, 'constraints_binary': 1971.0, 'constraints_ternary': 68.0, 'acyc_edges': 0.0, 'complexity': 2187.0}}, 'solving': {'solvers': {'choices': 3.0, 'conflicts': 8.0, 'conflicts_analyzed': 0.0, 'restarts': 0.0, 'restarts_last': 0.0, 'extra': {'domain_choices': 0.0, 'models': 0.0, 'models_level': 0.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 2.0, 'distributed_sum_lbd': 4.0, 'integrated': 6.0, 'lemmas': 8.0, 'lits_learnt': 16.0, 'lemmas_binary': 8.0, 'lemmas_ternary': 0.0, 'cpu_time': 0.0, 'integrated_imps': 6.0, 'integrated_jumps': 3.0, 'guiding_paths_lits': 455.0, 'guiding_paths': 7.0, 'splits': 0.0, 'lemmas_conflict': 0.0, 'lemmas_loop': 2.0, 'lemmas_other': 6.0, 'lits_conflict': 0.0, 'lits_loop': 4.0, 'lits_other': 12.0, 'jumps': {'jumps': 0.0, 'jumps_bounded': 0.0, 'levels': 0.0, 'levels_bounded': 0.0, 'max': 0.0, 'max_executed': 0.0, 'max_bounded': 0.0}}}}, 'summary': {'call': 2.0, 'result': 2.0, 'signal': 0.0, 'exhausted': 1.0, 'costs': [], 'lower': [], 'concurrency': 8.0, 'winner': 2.0, 'times': {'total': 0.07679176330566406, 'cpu': 0.078125, 'solve': 0.001995086669921875, 'unsat': 0.001995086669921875, 'sat': 0.0}, 'models': {'enumerated': 0.0, 'optimal': 0.0}}, 'accu': {'times': {'total': 0.23137474060058594, 'cpu': 0.21875, 'solve': 0.005985260009765625, 'unsat': 0.0029926300048828125, 'sat': 0.00099945068359375}, 'models': {'enumerated': 1.0, 'optimal': 0.0}, 'solving': {'solvers': {'choices': 3.0, 'conflicts': 8.0, 'conflicts_analyzed': 0.0, 'restarts': 0.0, 'restarts_last': 0.0, 'extra': {'domain_choices': 0.0, 'models': 1.0, 'models_level': 1.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 2.0, 'distributed_sum_lbd': 4.0, 'integrated': 6.0, 'lemmas': 12.0, 'lits_learnt': 20.0, 'lemmas_binary': 8.0, 'lemmas_ternary': 0.0, 'cpu_time': 0.0, 'integrated_imps': 6.0, 'integrated_jumps': 3.0, 'guiding_paths_lits': 771.0, 'guiding_paths': 22.0, 'splits': 0.0, 'lemmas_conflict': 0.0, 'lemmas_loop': 6.0, 'lemmas_other': 6.0, 'lits_conflict': 0.0, 'lits_loop': 8.0, 'lits_other': 12.0, 'jumps': {'jumps': 0.0, 'jumps_bounded': 0.0, 'levels': 0.0, 'levels_bounded': 0.0, 'max': 0.0, 'max_executed': 0.0, 'max_bounded': 0.0}}}}}, 'user_step': {}, 'user_accu': {}}))

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [3]:
Running step bounds   | Previous =      2 : Current =      3
Incrementor step ends | Minimum  =   None : Maximum =    100

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(3)]), ('action_effects', [Number(3)]), ('action_preconditions', [Number(3)]), ('variable_relations', [Number(3)]), ('abstraction_mappings', [Number(3)]), ('state_module', [Number(3), Number(0)]), ('plan_module', [Number(3), Number(0), Function('false', [], True), Function('false', [], True)]), ('optimisation_module', [Number(3), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('conformance_module', [Number(3), Number(0), Number(1), Number(20), Function('sequential', [], True), Function('true', [], True)])]

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.067680s.

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.006948s with result Unsatisfiable.

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [3]:
Result = SolveResult.Unsatisfiable, Stop condition = None
Increment time = 0.07462829999999965, Incremental time limit = None
Running cumulative time = 0.26611339999999917, Cumulative time limit = 3600
(RSS = 108.000000b, VMS = 102.000000b)

[15-09-2021_15-49-21] DEBUG :: ASH Planner Main #1 >> Increment feedback: Feedback(increment=3, start_step=3, end_step=4, solve_result=<SolveResult.Unsatisfiable: 'UNSAT'>, cumulative_statistics=Statistics(grounding_time=0.2454995999999996, solving_time=0.02061379999999957, total_time=0.26611339999999917, memory=Memory(rss=0.0, vms=0.0), step_range=range(0, 4), clingo_stats={}), increment_statistics=Statistics(grounding_time=0.0676798999999999, solving_time=0.006948399999999744, total_time=0.07462829999999965, memory=Memory(rss=108, vms=102), step_range=range(3, 4), clingo_stats={'problem': {'lp': {'atoms': 11038.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 42896.0, 'bodies_tr': 42896.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 597.0, 'count_bodies_tr': 597.0, 'sccs': 34.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 488.0, 'rules': 86316.0, 'rules_normal': 85665.0, 'rules_choice': 651.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 86316.0, 'rules_tr_normal': 85665.0, 'rules_tr_choice': 651.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 18736.0, 'eqs_atom': 4603.0, 'eqs_body': 1692.0, 'eqs_other': 12441.0}, 'lpStep': {'atoms': 1783.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 13262.0, 'bodies_tr': 13262.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 183.0, 'count_bodies_tr': 183.0, 'sccs': 8.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 76.0, 'rules': 26266.0, 'rules_normal': 26110.0, 'rules_choice': 156.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 26266.0, 'rules_tr_normal': 26110.0, 'rules_tr_choice': 156.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 3434.0, 'eqs_atom': 809.0, 'eqs_body': 324.0, 'eqs_other': 2301.0}, 'generator': {'vars': 2094.0, 'vars_eliminated': 0.0, 'vars_frozen': 1519.0, 'constraints': 203.0, 'constraints_binary': 4603.0, 'constraints_ternary': 281.0, 'acyc_edges': 0.0, 'complexity': 5162.0}}, 'solving': {'solvers': {'choices': 168.0, 'conflicts': 23.0, 'conflicts_analyzed': 16.0, 'restarts': 0.0, 'restarts_last': 4.0, 'extra': {'domain_choices': 0.0, 'models': 0.0, 'models_level': 0.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 17.0, 'distributed_sum_lbd': 21.0, 'integrated': 92.0, 'lemmas': 103.0, 'lits_learnt': 171.0, 'lemmas_binary': 8.0, 'lemmas_ternary': 0.0, 'cpu_time': 0.0, 'integrated_imps': 72.0, 'integrated_jumps': 44.0, 'guiding_paths_lits': 602.0, 'guiding_paths': 7.0, 'splits': 0.0, 'lemmas_conflict': 16.0, 'lemmas_loop': 9.0, 'lemmas_other': 78.0, 'lits_conflict': 25.0, 'lits_loop': 46.0, 'lits_other': 100.0, 'jumps': {'jumps': 16.0, 'jumps_bounded': 13.0, 'levels': 1242.0, 'levels_bounded': 1118.0, 'max': 102.0, 'max_executed': 102.0, 'max_bounded': 86.0}}}}, 'summary': {'call': 3.0, 'result': 2.0, 'signal': 0.0, 'exhausted': 1.0, 'costs': [], 'lower': [], 'concurrency': 8.0, 'winner': 3.0, 'times': {'total': 0.07564163208007812, 'cpu': 0.078125, 'solve': 0.0028362274169921875, 'unsat': 0.0028362274169921875, 'sat': 0.0}, 'models': {'enumerated': 0.0, 'optimal': 0.0}}, 'accu': {'times': {'total': 0.30701637268066406, 'cpu': 0.296875, 'solve': 0.008821487426757812, 'unsat': 0.005828857421875, 'sat': 0.00099945068359375}, 'models': {'enumerated': 1.0, 'optimal': 0.0}, 'solving': {'solvers': {'choices': 171.0, 'conflicts': 31.0, 'conflicts_analyzed': 16.0, 'restarts': 0.0, 'restarts_last': 4.0, 'extra': {'domain_choices': 0.0, 'models': 1.0, 'models_level': 1.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 19.0, 'distributed_sum_lbd': 25.0, 'integrated': 98.0, 'lemmas': 115.0, 'lits_learnt': 191.0, 'lemmas_binary': 16.0, 'lemmas_ternary': 0.0, 'cpu_time': 0.0, 'integrated_imps': 78.0, 'integrated_jumps': 47.0, 'guiding_paths_lits': 1373.0, 'guiding_paths': 29.0, 'splits': 0.0, 'lemmas_conflict': 16.0, 'lemmas_loop': 15.0, 'lemmas_other': 84.0, 'lits_conflict': 25.0, 'lits_loop': 54.0, 'lits_other': 112.0, 'jumps': {'jumps': 16.0, 'jumps_bounded': 13.0, 'levels': 1242.0, 'levels_bounded': 1118.0, 'max': 102.0, 'max_executed': 102.0, 'max_bounded': 86.0}}}}}, 'user_step': {}, 'user_accu': {}}))

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [4]:
Running step bounds   | Previous =      3 : Current =      4
Incrementor step ends | Minimum  =   None : Maximum =    100

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(4)]), ('action_effects', [Number(4)]), ('action_preconditions', [Number(4)]), ('variable_relations', [Number(4)]), ('abstraction_mappings', [Number(4)]), ('state_module', [Number(4), Number(0)]), ('plan_module', [Number(4), Number(0), Function('false', [], True), Function('false', [], True)]), ('optimisation_module', [Number(4), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('conformance_module', [Number(4), Number(0), Number(1), Number(20), Function('sequential', [], True), Function('true', [], True)])]

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.072479s.

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.006418s with result Unsatisfiable.

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [4]:
Result = SolveResult.Unsatisfiable, Stop condition = None
Increment time = 0.07889690000000016, Incremental time limit = None
Running cumulative time = 0.3450102999999993, Cumulative time limit = 3600
(RSS = 111.000000b, VMS = 104.000000b)

[15-09-2021_15-49-21] DEBUG :: ASH Planner Main #1 >> Increment feedback: Feedback(increment=4, start_step=4, end_step=5, solve_result=<SolveResult.Unsatisfiable: 'UNSAT'>, cumulative_statistics=Statistics(grounding_time=0.31797819999999977, solving_time=0.02703209999999956, total_time=0.3450102999999993, memory=Memory(rss=0.0, vms=0.0), step_range=range(0, 5), clingo_stats={}), increment_statistics=Statistics(grounding_time=0.07247860000000017, solving_time=0.006418299999999988, total_time=0.07889690000000016, memory=Memory(rss=111, vms=104), step_range=range(4, 5), clingo_stats={'problem': {'lp': {'atoms': 12976.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 56240.0, 'bodies_tr': 56240.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 780.0, 'count_bodies_tr': 780.0, 'sccs': 42.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 564.0, 'rules': 112855.0, 'rules_normal': 112048.0, 'rules_choice': 807.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 112855.0, 'rules_tr_normal': 112048.0, 'rules_tr_choice': 807.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 22461.0, 'eqs_atom': 5422.0, 'eqs_body': 2025.0, 'eqs_other': 15014.0}, 'lpStep': {'atoms': 1938.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 13344.0, 'bodies_tr': 13344.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 183.0, 'count_bodies_tr': 183.0, 'sccs': 8.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 76.0, 'rules': 26539.0, 'rules_normal': 26383.0, 'rules_choice': 156.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 26539.0, 'rules_tr_normal': 26383.0, 'rules_tr_choice': 156.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 3725.0, 'eqs_atom': 819.0, 'eqs_body': 333.0, 'eqs_other': 2573.0}, 'generator': {'vars': 2463.0, 'vars_eliminated': 0.0, 'vars_frozen': 1787.0, 'constraints': 256.0, 'constraints_binary': 6222.0, 'constraints_ternary': 341.0, 'acyc_edges': 0.0, 'complexity': 6914.0}}, 'solving': {'solvers': {'choices': 132.0, 'conflicts': 27.0, 'conflicts_analyzed': 21.0, 'restarts': 0.0, 'restarts_last': 5.0, 'extra': {'domain_choices': 0.0, 'models': 0.0, 'models_level': 0.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 22.0, 'distributed_sum_lbd': 30.0, 'integrated': 65.0, 'lemmas': 92.0, 'lits_learnt': 191.0, 'lemmas_binary': 20.0, 'lemmas_ternary': 0.0, 'cpu_time': 0.0, 'integrated_imps': 38.0, 'integrated_jumps': 39.0, 'guiding_paths_lits': 535.0, 'guiding_paths': 5.0, 'splits': 0.0, 'lemmas_conflict': 21.0, 'lemmas_loop': 12.0, 'lemmas_other': 59.0, 'lits_conflict': 34.0, 'lits_loop': 52.0, 'lits_other': 105.0, 'jumps': {'jumps': 21.0, 'jumps_bounded': 8.0, 'levels': 955.0, 'levels_bounded': 856.0, 'max': 123.0, 'max_executed': 109.0, 'max_bounded': 107.0}}}}, 'summary': {'call': 4.0, 'result': 2.0, 'signal': 0.0, 'exhausted': 1.0, 'costs': [], 'lower': [], 'concurrency': 8.0, 'winner': 0.0, 'times': {'total': 0.07979011535644531, 'cpu': 0.078125, 'solve': 0.0029926300048828125, 'unsat': 0.0029926300048828125, 'sat': 0.0}, 'models': {'enumerated': 0.0, 'optimal': 0.0}}, 'accu': {'times': {'total': 0.3868064880371094, 'cpu': 0.375, 'solve': 0.011814117431640625, 'unsat': 0.008821487426757812, 'sat': 0.00099945068359375}, 'models': {'enumerated': 1.0, 'optimal': 0.0}, 'solving': {'solvers': {'choices': 303.0, 'conflicts': 58.0, 'conflicts_analyzed': 37.0, 'restarts': 0.0, 'restarts_last': 5.0, 'extra': {'domain_choices': 0.0, 'models': 1.0, 'models_level': 1.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 41.0, 'distributed_sum_lbd': 55.0, 'integrated': 163.0, 'lemmas': 207.0, 'lits_learnt': 382.0, 'lemmas_binary': 36.0, 'lemmas_ternary': 0.0, 'cpu_time': 0.0, 'integrated_imps': 116.0, 'integrated_jumps': 86.0, 'guiding_paths_lits': 1908.0, 'guiding_paths': 34.0, 'splits': 0.0, 'lemmas_conflict': 37.0, 'lemmas_loop': 27.0, 'lemmas_other': 143.0, 'lits_conflict': 59.0, 'lits_loop': 106.0, 'lits_other': 217.0, 'jumps': {'jumps': 37.0, 'jumps_bounded': 21.0, 'levels': 2197.0, 'levels_bounded': 1974.0, 'max': 123.0, 'max_executed': 109.0, 'max_bounded': 107.0}}}}}, 'user_step': {}, 'user_accu': {}}))

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [5]:
Running step bounds   | Previous =      4 : Current =      5
Incrementor step ends | Minimum  =   None : Maximum =    100

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(5)]), ('action_effects', [Number(5)]), ('action_preconditions', [Number(5)]), ('variable_relations', [Number(5)]), ('abstraction_mappings', [Number(5)]), ('state_module', [Number(5), Number(0)]), ('plan_module', [Number(5), Number(0), Function('false', [], True), Function('false', [], True)]), ('optimisation_module', [Number(5), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('conformance_module', [Number(5), Number(0), Number(1), Number(20), Function('sequential', [], True), Function('true', [], True)])]

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.075408s.

[15-09-2021_15-49-21] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.007241s with result Unsatisfiable.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [5]:
Result = SolveResult.Unsatisfiable, Stop condition = None
Increment time = 0.08264850000000035, Incremental time limit = None
Running cumulative time = 0.4276587999999997, Cumulative time limit = 3600
(RSS = 112.000000b, VMS = 106.000000b)

[15-09-2021_15-49-22] DEBUG :: ASH Planner Main #1 >> Increment feedback: Feedback(increment=5, start_step=5, end_step=6, solve_result=<SolveResult.Unsatisfiable: 'UNSAT'>, cumulative_statistics=Statistics(grounding_time=0.3933857999999999, solving_time=0.034272999999999776, total_time=0.4276587999999997, memory=Memory(rss=0.0, vms=0.0), step_range=range(0, 6), clingo_stats={}), increment_statistics=Statistics(grounding_time=0.07540760000000013, solving_time=0.007240900000000217, total_time=0.08264850000000035, memory=Memory(rss=112, vms=106), step_range=range(5, 6), clingo_stats={'problem': {'lp': {'atoms': 14769.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 69704.0, 'bodies_tr': 69704.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 963.0, 'count_bodies_tr': 963.0, 'sccs': 52.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 650.0, 'rules': 139671.0, 'rules_normal': 138708.0, 'rules_choice': 963.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 139671.0, 'rules_tr_normal': 138708.0, 'rules_tr_choice': 963.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 26319.0, 'eqs_atom': 6224.0, 'eqs_body': 2294.0, 'eqs_other': 17801.0}, 'lpStep': {'atoms': 1793.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 13464.0, 'bodies_tr': 13464.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 183.0, 'count_bodies_tr': 183.0, 'sccs': 10.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 86.0, 'rules': 26816.0, 'rules_normal': 26660.0, 'rules_choice': 156.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 26816.0, 'rules_tr_normal': 26660.0, 'rules_tr_choice': 156.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 3858.0, 'eqs_atom': 802.0, 'eqs_body': 269.0, 'eqs_other': 2787.0}, 'generator': {'vars': 2985.0, 'vars_eliminated': 0.0, 'vars_frozen': 2167.0, 'constraints': 334.0, 'constraints_binary': 9720.0, 'constraints_ternary': 595.0, 'acyc_edges': 0.0, 'complexity': 10784.0}}, 'solving': {'solvers': {'choices': 190.0, 'conflicts': 25.0, 'conflicts_analyzed': 17.0, 'restarts': 0.0, 'restarts_last': 3.0, 'extra': {'domain_choices': 0.0, 'models': 0.0, 'models_level': 0.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 13.0, 'distributed_sum_lbd': 21.0, 'integrated': 43.0, 'lemmas': 59.0, 'lits_learnt': 132.0, 'lemmas_binary': 24.0, 'lemmas_ternary': 0.0, 'cpu_time': 0.0, 'integrated_imps': 34.0, 'integrated_jumps': 62.0, 'guiding_paths_lits': 896.0, 'guiding_paths': 7.0, 'splits': 0.0, 'lemmas_conflict': 13.0, 'lemmas_loop': 4.0, 'lemmas_other': 42.0, 'lits_conflict': 28.0, 'lits_loop': 19.0, 'lits_other': 85.0, 'jumps': {'jumps': 17.0, 'jumps_bounded': 3.0, 'levels': 262.0, 'levels_bounded': 130.0, 'max': 146.0, 'max_executed': 146.0, 'max_bounded': 128.0}}}}, 'summary': {'call': 5.0, 'result': 2.0, 'signal': 0.0, 'exhausted': 1.0, 'costs': [], 'lower': [], 'concurrency': 8.0, 'winner': 1.0, 'times': {'total': 0.08377838134765625, 'cpu': 0.078125, 'solve': 0.0029926300048828125, 'unsat': 0.0029926300048828125, 'sat': 0.0}, 'models': {'enumerated': 0.0, 'optimal': 0.0}}, 'accu': {'times': {'total': 0.4705848693847656, 'cpu': 0.453125, 'solve': 0.014806747436523438, 'unsat': 0.011814117431640625, 'sat': 0.00099945068359375}, 'models': {'enumerated': 1.0, 'optimal': 0.0}, 'solving': {'solvers': {'choices': 493.0, 'conflicts': 83.0, 'conflicts_analyzed': 54.0, 'restarts': 0.0, 'restarts_last': 5.0, 'extra': {'domain_choices': 0.0, 'models': 1.0, 'models_level': 1.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 54.0, 'distributed_sum_lbd': 76.0, 'integrated': 206.0, 'lemmas': 266.0, 'lits_learnt': 514.0, 'lemmas_binary': 60.0, 'lemmas_ternary': 0.0, 'cpu_time': 0.0, 'integrated_imps': 150.0, 'integrated_jumps': 148.0, 'guiding_paths_lits': 2804.0, 'guiding_paths': 41.0, 'splits': 0.0, 'lemmas_conflict': 50.0, 'lemmas_loop': 31.0, 'lemmas_other': 185.0, 'lits_conflict': 87.0, 'lits_loop': 125.0, 'lits_other': 302.0, 'jumps': {'jumps': 54.0, 'jumps_bounded': 24.0, 'levels': 2459.0, 'levels_bounded': 2104.0, 'max': 146.0, 'max_executed': 146.0, 'max_bounded': 128.0}}}}}, 'user_step': {}, 'user_accu': {}}))

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [6]:
Running step bounds   | Previous =      5 : Current =      6
Incrementor step ends | Minimum  =   None : Maximum =    100

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(6)]), ('action_effects', [Number(6)]), ('action_preconditions', [Number(6)]), ('variable_relations', [Number(6)]), ('abstraction_mappings', [Number(6)]), ('state_module', [Number(6), Number(0)]), ('plan_module', [Number(6), Number(0), Function('false', [], True), Function('false', [], True)]), ('optimisation_module', [Number(6), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('conformance_module', [Number(6), Number(0), Number(1), Number(20), Function('sequential', [], True), Function('true', [], True)])]

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.088041s.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.008794s with result Unsatisfiable.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [6]:
Result = SolveResult.Unsatisfiable, Stop condition = None
Increment time = 0.0968353999999989, Incremental time limit = None
Running cumulative time = 0.5244941999999986, Cumulative time limit = 3600
(RSS = 114.000000b, VMS = 109.000000b)

[15-09-2021_15-49-22] DEBUG :: ASH Planner Main #1 >> Increment feedback: Feedback(increment=6, start_step=6, end_step=7, solve_result=<SolveResult.Unsatisfiable: 'UNSAT'>, cumulative_statistics=Statistics(grounding_time=0.4814267999999995, solving_time=0.04306739999999909, total_time=0.5244941999999986, memory=Memory(rss=0.0, vms=0.0), step_range=range(0, 7), clingo_stats={}), increment_statistics=Statistics(grounding_time=0.08804099999999959, solving_time=0.008794399999999314, total_time=0.0968353999999989, memory=Memory(rss=114, vms=109), step_range=range(6, 7), clingo_stats={'problem': {'lp': {'atoms': 16801.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 83426.0, 'bodies_tr': 83426.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 1146.0, 'count_bodies_tr': 1146.0, 'sccs': 62.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 737.0, 'rules': 166996.0, 'rules_normal': 165877.0, 'rules_choice': 1119.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 166996.0, 'rules_tr_normal': 165877.0, 'rules_tr_choice': 1119.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 30776.0, 'eqs_atom': 7127.0, 'eqs_body': 2577.0, 'eqs_other': 21072.0}, 'lpStep': {'atoms': 2032.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 13722.0, 'bodies_tr': 13722.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 183.0, 'count_bodies_tr': 183.0, 'sccs': 10.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 87.0, 'rules': 27325.0, 'rules_normal': 27169.0, 'rules_choice': 156.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 27325.0, 'rules_tr_normal': 27169.0, 'rules_tr_choice': 156.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 4457.0, 'eqs_atom': 903.0, 'eqs_body': 283.0, 'eqs_other': 3271.0}, 'generator': {'vars': 3577.0, 'vars_eliminated': 0.0, 'vars_frozen': 2569.0, 'constraints': 434.0, 'constraints_binary': 13848.0, 'constraints_ternary': 1017.0, 'acyc_edges': 0.0, 'complexity': 15474.0}}, 'solving': {'solvers': {'choices': 180.0, 'conflicts': 41.0, 'conflicts_analyzed': 33.0, 'restarts': 0.0, 'restarts_last': 9.0, 'extra': {'domain_choices': 0.0, 'models': 0.0, 'models_level': 0.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 28.0, 'distributed_sum_lbd': 71.0, 'integrated': 134.0, 'lemmas': 180.0, 'lits_learnt': 941.0, 'lemmas_binary': 37.0, 'lemmas_ternary': 31.0, 'cpu_time': 0.0, 'integrated_imps': 40.0, 'integrated_jumps': 73.0, 'guiding_paths_lits': 1043.0, 'guiding_paths': 7.0, 'splits': 0.0, 'lemmas_conflict': 29.0, 'lemmas_loop': 22.0, 'lemmas_other': 129.0, 'lits_conflict': 168.0, 'lits_loop': 116.0, 'lits_other': 657.0, 'jumps': {'jumps': 33.0, 'jumps_bounded': 4.0, 'levels': 259.0, 'levels_bounded': 152.0, 'max': 151.0, 'max_executed': 151.0, 'max_bounded': 149.0}}}}, 'summary': {'call': 6.0, 'result': 2.0, 'signal': 0.0, 'exhausted': 1.0, 'costs': [], 'lower': [], 'concurrency': 8.0, 'winner': 2.0, 'times': {'total': 0.09873199462890625, 'cpu': 0.09375, 'solve': 0.00299072265625, 'unsat': 0.00299072265625, 'sat': 0.0}, 'models': {'enumerated': 0.0, 'optimal': 0.0}}, 'accu': {'times': {'total': 0.5693168640136719, 'cpu': 0.546875, 'solve': 0.017797470092773438, 'unsat': 0.014804840087890625, 'sat': 0.00099945068359375}, 'models': {'enumerated': 1.0, 'optimal': 0.0}, 'solving': {'solvers': {'choices': 673.0, 'conflicts': 124.0, 'conflicts_analyzed': 87.0, 'restarts': 0.0, 'restarts_last': 9.0, 'extra': {'domain_choices': 0.0, 'models': 1.0, 'models_level': 1.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 82.0, 'distributed_sum_lbd': 147.0, 'integrated': 340.0, 'lemmas': 446.0, 'lits_learnt': 1455.0, 'lemmas_binary': 97.0, 'lemmas_ternary': 31.0, 'cpu_time': 0.0, 'integrated_imps': 190.0, 'integrated_jumps': 221.0, 'guiding_paths_lits': 3847.0, 'guiding_paths': 48.0, 'splits': 0.0, 'lemmas_conflict': 79.0, 'lemmas_loop': 53.0, 'lemmas_other': 314.0, 'lits_conflict': 255.0, 'lits_loop': 241.0, 'lits_other': 959.0, 'jumps': {'jumps': 87.0, 'jumps_bounded': 28.0, 'levels': 2718.0, 'levels_bounded': 2256.0, 'max': 151.0, 'max_executed': 151.0, 'max_bounded': 149.0}}}}}, 'user_step': {}, 'user_accu': {}}))

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [7]:
Running step bounds   | Previous =      6 : Current =      7
Incrementor step ends | Minimum  =   None : Maximum =    100

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(7)]), ('action_effects', [Number(7)]), ('action_preconditions', [Number(7)]), ('variable_relations', [Number(7)]), ('abstraction_mappings', [Number(7)]), ('state_module', [Number(7), Number(0)]), ('plan_module', [Number(7), Number(0), Function('false', [], True), Function('false', [], True)]), ('optimisation_module', [Number(7), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('conformance_module', [Number(7), Number(0), Number(1), Number(20), Function('sequential', [], True), Function('true', [], True)])]

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.078628s.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Model found:
Model :: Total atoms = 5410, Cost = (), Optimality proven = False, Number = 1, Thread ID = 0, Model type = ModelType.StableModel

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.018878s with result Satisfiable.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [7]:
Result = SolveResult.Satisfiable, Stop condition = None
Increment time = 0.0975059000000007, Incremental time limit = None
Running cumulative time = 0.6220000999999993, Cumulative time limit = 3600
(RSS = 118.000000b, VMS = 112.000000b)

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Incremental solving has found a model, current answer:
Result :: SATISFIABLE : SEARCH INTERRUPTED : Total models = 2
IncrementalStatistics :: Cumulative = (Statistics :: Grounding = 0.560055s, Solving = 0.061945s, Total = 0.622000s, Memory = (RSS = 0.000000b, VMS = 0.000000b)), Calls = 7
Final Model :: Total atoms = 5410, Cost = (), Optimality proven = False, Number = 1, Thread ID = 0, Model type = ModelType.StableModel

[15-09-2021_15-49-22] DEBUG :: ASH Planner Main #1 >> Increment feedback: Feedback(increment=7, start_step=7, end_step=8, solve_result=<SolveResult.Satisfiable: 'SAT'>, cumulative_statistics=Statistics(grounding_time=0.5600547999999996, solving_time=0.06194529999999965, total_time=0.6220000999999993, memory=Memory(rss=0.0, vms=0.0), step_range=range(0, 8), clingo_stats={}), increment_statistics=Statistics(grounding_time=0.07862800000000014, solving_time=0.018877900000000558, total_time=0.0975059000000007, memory=Memory(rss=118, vms=112), step_range=range(7, 8), clingo_stats={'problem': {'lp': {'atoms': 18839.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 97561.0, 'bodies_tr': 97561.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 1329.0, 'count_bodies_tr': 1329.0, 'sccs': 82.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 1057.0, 'rules': 194971.0, 'rules_normal': 193696.0, 'rules_choice': 1275.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 194971.0, 'rules_tr_normal': 193696.0, 'rules_tr_choice': 1275.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 36016.0, 'eqs_atom': 8118.0, 'eqs_body': 2741.0, 'eqs_other': 25157.0}, 'lpStep': {'atoms': 2038.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 14135.0, 'bodies_tr': 14135.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 183.0, 'count_bodies_tr': 183.0, 'sccs': 20.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 320.0, 'rules': 27975.0, 'rules_normal': 27819.0, 'rules_choice': 156.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 27975.0, 'rules_tr_normal': 27819.0, 'rules_tr_choice': 156.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 5240.0, 'eqs_atom': 991.0, 'eqs_body': 164.0, 'eqs_other': 4085.0}, 'generator': {'vars': 4774.0, 'vars_eliminated': 0.0, 'vars_frozen': 3374.0, 'constraints': 744.0, 'constraints_binary': 25502.0, 'constraints_ternary': 2014.0, 'acyc_edges': 0.0, 'complexity': 28480.0}}, 'solving': {'solvers': {'choices': 810.0, 'conflicts': 64.0, 'conflicts_analyzed': 64.0, 'restarts': 0.0, 'restarts_last': 18.0, 'extra': {'domain_choices': 0.0, 'models': 1.0, 'models_level': 232.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 58.0, 'distributed_sum_lbd': 130.0, 'integrated': 307.0, 'lemmas': 444.0, 'lits_learnt': 2402.0, 'lemmas_binary': 96.0, 'lemmas_ternary': 45.0, 'cpu_time': 0.03125, 'integrated_imps': 110.0, 'integrated_jumps': 241.0, 'guiding_paths_lits': 1190.0, 'guiding_paths': 7.0, 'splits': 0.0, 'lemmas_conflict': 60.0, 'lemmas_loop': 90.0, 'lemmas_other': 294.0, 'lits_conflict': 346.0, 'lits_loop': 561.0, 'lits_other': 1495.0, 'jumps': {'jumps': 64.0, 'jumps_bounded': 5.0, 'levels': 991.0, 'levels_bounded': 850.0, 'max': 176.0, 'max_executed': 176.0, 'max_bounded': 170.0}}}}, 'summary': {'call': 7.0, 'result': 1.0, 'signal': 0.0, 'exhausted': 0.0, 'costs': [], 'lower': [], 'concurrency': 8.0, 'winner': 0.0, 'times': {'total': 0.09873580932617188, 'cpu': 0.125, 'solve': 0.009943008422851562, 'unsat': 0.0, 'sat': 0.0029621124267578125}, 'models': {'enumerated': 1.0, 'optimal': 0.0}}, 'accu': {'times': {'total': 0.6680526733398438, 'cpu': 0.671875, 'solve': 0.027740478515625, 'unsat': 0.014804840087890625, 'sat': 0.0039615631103515625}, 'models': {'enumerated': 2.0, 'optimal': 0.0}, 'solving': {'solvers': {'choices': 1483.0, 'conflicts': 188.0, 'conflicts_analyzed': 151.0, 'restarts': 0.0, 'restarts_last': 18.0, 'extra': {'domain_choices': 0.0, 'models': 2.0, 'models_level': 233.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 140.0, 'distributed_sum_lbd': 277.0, 'integrated': 647.0, 'lemmas': 890.0, 'lits_learnt': 3857.0, 'lemmas_binary': 193.0, 'lemmas_ternary': 76.0, 'cpu_time': 0.03125, 'integrated_imps': 300.0, 'integrated_jumps': 462.0, 'guiding_paths_lits': 5037.0, 'guiding_paths': 55.0, 'splits': 0.0, 'lemmas_conflict': 139.0, 'lemmas_loop': 143.0, 'lemmas_other': 608.0, 'lits_conflict': 601.0, 'lits_loop': 802.0, 'lits_other': 2454.0, 'jumps': {'jumps': 151.0, 'jumps_bounded': 33.0, 'levels': 3709.0, 'levels_bounded': 3106.0, 'max': 176.0, 'max_executed': 176.0, 'max_bounded': 170.0}}}}}, 'user_step': {}, 'user_accu': {}}))

[15-09-2021_15-49-22] DEBUG :: ASH Planner Main #1 >> Goal at sequence index 1 achieved.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Queueing external: External(symbol='current_last_sgoals(2, 7)', truth=True, inc_range=None)

[15-09-2021_15-49-22] DEBUG :: ASH Planner Main #1 >> Setting current sub-goal stage to index 2:sub_goal(3, talos, grasp(manipulator_arm_2,(block,6)), grasping(manipulator_arm_2), (block,6), 2)

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [8]:
Running step bounds   | Previous =      7 : Current =      8
Incrementor step ends | Minimum  =   None : Maximum =    100

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(8)]), ('action_effects', [Number(8)]), ('action_preconditions', [Number(8)]), ('variable_relations', [Number(8)]), ('abstraction_mappings', [Number(8)]), ('state_module', [Number(8), Number(0)]), ('plan_module', [Number(8), Number(0), Function('false', [], True), Function('false', [], True)]), ('optimisation_module', [Number(8), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('conformance_module', [Number(8), Number(0), Number(1), Number(20), Function('sequential', [], True), Function('true', [], True)])]

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.082917s.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Assigning queued external: original = External(symbol='current_last_sgoals(2, 7)', truth=True, inc_range=None), conversion = current_last_sgoals(2,7).

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.011744s with result Unsatisfiable.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [8]:
Result = SolveResult.Unsatisfiable, Stop condition = None
Increment time = 0.09466090000000005, Incremental time limit = None
Running cumulative time = 0.7166609999999993, Cumulative time limit = 3600
(RSS = 123.000000b, VMS = 117.000000b)

[15-09-2021_15-49-22] DEBUG :: ASH Planner Main #1 >> Increment feedback: Feedback(increment=8, start_step=8, end_step=9, solve_result=<SolveResult.Unsatisfiable: 'UNSAT'>, cumulative_statistics=Statistics(grounding_time=0.6429716999999995, solving_time=0.07368929999999985, total_time=0.7166609999999993, memory=Memory(rss=0.0, vms=0.0), step_range=range(0, 9), clingo_stats={}), increment_statistics=Statistics(grounding_time=0.08291689999999985, solving_time=0.011744000000000199, total_time=0.09466090000000005, memory=Memory(rss=123, vms=117), step_range=range(8, 9), clingo_stats={'problem': {'lp': {'atoms': 20930.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 111380.0, 'bodies_tr': 111380.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 1512.0, 'count_bodies_tr': 1512.0, 'sccs': 92.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 1144.0, 'rules': 222774.0, 'rules_normal': 221343.0, 'rules_choice': 1431.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 222774.0, 'rules_tr_normal': 221343.0, 'rules_tr_choice': 1431.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 40824.0, 'eqs_atom': 9066.0, 'eqs_body': 3069.0, 'eqs_other': 28689.0}, 'lpStep': {'atoms': 2091.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 13819.0, 'bodies_tr': 13819.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 183.0, 'count_bodies_tr': 183.0, 'sccs': 10.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 87.0, 'rules': 27803.0, 'rules_normal': 27647.0, 'rules_choice': 156.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 27803.0, 'rules_tr_normal': 27647.0, 'rules_tr_choice': 156.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 4808.0, 'eqs_atom': 948.0, 'eqs_body': 328.0, 'eqs_other': 3532.0}, 'generator': {'vars': 5366.0, 'vars_eliminated': 0.0, 'vars_frozen': 3776.0, 'constraints': 541.0, 'constraints_binary': 18795.0, 'constraints_ternary': 1254.0, 'acyc_edges': 0.0, 'complexity': 28480.0}}, 'solving': {'solvers': {'choices': 0.0, 'conflicts': 7.0, 'conflicts_analyzed': 0.0, 'restarts': 0.0, 'restarts_last': 0.0, 'extra': {'domain_choices': 0.0, 'models': 0.0, 'models_level': 0.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 0.0, 'distributed_sum_lbd': 0.0, 'integrated': 0.0, 'lemmas': 0.0, 'lits_learnt': 0.0, 'lemmas_binary': 0.0, 'lemmas_ternary': 0.0, 'cpu_time': 0.0, 'integrated_imps': 0.0, 'integrated_jumps': 0.0, 'guiding_paths_lits': 1146.0, 'guiding_paths': 6.0, 'splits': 0.0, 'lemmas_conflict': 0.0, 'lemmas_loop': 0.0, 'lemmas_other': 0.0, 'lits_conflict': 0.0, 'lits_loop': 0.0, 'lits_other': 0.0, 'jumps': {'jumps': 0.0, 'jumps_bounded': 0.0, 'levels': 0.0, 'levels_bounded': 0.0, 'max': 0.0, 'max_executed': 0.0, 'max_bounded': 0.0}}}}, 'summary': {'call': 8.0, 'result': 2.0, 'signal': 0.0, 'exhausted': 1.0, 'costs': [], 'lower': [], 'concurrency': 8.0, 'winner': 0.0, 'times': {'total': 0.10121345520019531, 'cpu': 0.078125, 'solve': 0.0024547576904296875, 'unsat': 0.0024547576904296875, 'sat': 0.0}, 'models': {'enumerated': 0.0, 'optimal': 0.0}}, 'accu': {'times': {'total': 0.7692661285400391, 'cpu': 0.75, 'solve': 0.030195236206054688, 'unsat': 0.017259597778320312, 'sat': 0.0039615631103515625}, 'models': {'enumerated': 2.0, 'optimal': 0.0}, 'solving': {'solvers': {'choices': 1483.0, 'conflicts': 195.0, 'conflicts_analyzed': 151.0, 'restarts': 0.0, 'restarts_last': 18.0, 'extra': {'domain_choices': 0.0, 'models': 2.0, 'models_level': 233.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 140.0, 'distributed_sum_lbd': 277.0, 'integrated': 647.0, 'lemmas': 890.0, 'lits_learnt': 3857.0, 'lemmas_binary': 193.0, 'lemmas_ternary': 76.0, 'cpu_time': 0.03125, 'integrated_imps': 300.0, 'integrated_jumps': 462.0, 'guiding_paths_lits': 6183.0, 'guiding_paths': 61.0, 'splits': 0.0, 'lemmas_conflict': 139.0, 'lemmas_loop': 143.0, 'lemmas_other': 608.0, 'lits_conflict': 601.0, 'lits_loop': 802.0, 'lits_other': 2454.0, 'jumps': {'jumps': 151.0, 'jumps_bounded': 33.0, 'levels': 3709.0, 'levels_bounded': 3106.0, 'max': 176.0, 'max_executed': 176.0, 'max_bounded': 170.0}}}}}, 'user_step': {}, 'user_accu': {}}))

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [9]:
Running step bounds   | Previous =      8 : Current =      9
Incrementor step ends | Minimum  =   None : Maximum =    100

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(9)]), ('action_effects', [Number(9)]), ('action_preconditions', [Number(9)]), ('variable_relations', [Number(9)]), ('abstraction_mappings', [Number(9)]), ('state_module', [Number(9), Number(0)]), ('plan_module', [Number(9), Number(0), Function('false', [], True), Function('false', [], True)]), ('optimisation_module', [Number(9), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('conformance_module', [Number(9), Number(0), Number(1), Number(20), Function('sequential', [], True), Function('true', [], True)])]

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.077367s.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Model found:
Model :: Total atoms = 6085, Cost = (), Optimality proven = False, Number = 1, Thread ID = 3, Model type = ModelType.StableModel

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.019225s with result Satisfiable.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [9]:
Result = SolveResult.Satisfiable, Stop condition = None
Increment time = 0.09659230000000019, Incremental time limit = None
Running cumulative time = 0.8132532999999995, Cumulative time limit = 3600
(RSS = 125.000000b, VMS = 118.000000b)

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Incremental solving has found a model, current answer:
Result :: SATISFIABLE : SEARCH INTERRUPTED : Total models = 3
IncrementalStatistics :: Cumulative = (Statistics :: Grounding = 0.720339s, Solving = 0.092914s, Total = 0.813253s, Memory = (RSS = 0.000000b, VMS = 0.000000b)), Calls = 9
Final Model :: Total atoms = 6085, Cost = (), Optimality proven = False, Number = 1, Thread ID = 3, Model type = ModelType.StableModel

[15-09-2021_15-49-22] DEBUG :: ASH Planner Main #1 >> Increment feedback: Feedback(increment=9, start_step=9, end_step=10, solve_result=<SolveResult.Satisfiable: 'SAT'>, cumulative_statistics=Statistics(grounding_time=0.7203390999999995, solving_time=0.09291420000000006, total_time=0.8132532999999995, memory=Memory(rss=0.0, vms=0.0), step_range=range(0, 10), clingo_stats={}), increment_statistics=Statistics(grounding_time=0.07736739999999998, solving_time=0.01922490000000021, total_time=0.09659230000000019, memory=Memory(rss=125, vms=118), step_range=range(9, 10), clingo_stats={'problem': {'lp': {'atoms': 22968.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 125689.0, 'bodies_tr': 125689.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 1695.0, 'count_bodies_tr': 1695.0, 'sccs': 112.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 1565.0, 'rules': 251287.0, 'rules_normal': 249700.0, 'rules_choice': 1587.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 251287.0, 'rules_tr_normal': 249700.0, 'rules_tr_choice': 1587.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 45274.0, 'eqs_atom': 10051.0, 'eqs_body': 3196.0, 'eqs_other': 32027.0}, 'lpStep': {'atoms': 2038.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 14309.0, 'bodies_tr': 14309.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 183.0, 'count_bodies_tr': 183.0, 'sccs': 20.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 421.0, 'rules': 28513.0, 'rules_normal': 28357.0, 'rules_choice': 156.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 28513.0, 'rules_tr_normal': 28357.0, 'rules_tr_choice': 156.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 4450.0, 'eqs_atom': 985.0, 'eqs_body': 127.0, 'eqs_other': 3338.0}, 'generator': {'vars': 6789.0, 'vars_eliminated': 0.0, 'vars_frozen': 4737.0, 'constraints': 996.0, 'constraints_binary': 35813.0, 'constraints_ternary': 2803.0, 'acyc_edges': 0.0, 'complexity': 39900.0}}, 'solving': {'solvers': {'choices': 717.0, 'conflicts': 10.0, 'conflicts_analyzed': 10.0, 'restarts': 0.0, 'restarts_last': 7.0, 'extra': {'domain_choices': 0.0, 'models': 1.0, 'models_level': 291.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 9.0, 'distributed_sum_lbd': 24.0, 'integrated': 54.0, 'lemmas': 113.0, 'lits_learnt': 676.0, 'lemmas_binary': 9.0, 'lemmas_ternary': 0.0, 'cpu_time': 0.09375, 'integrated_imps': 16.0, 'integrated_jumps': 146.0, 'guiding_paths_lits': 1484.0, 'guiding_paths': 7.0, 'splits': 0.0, 'lemmas_conflict': 10.0, 'lemmas_loop': 58.0, 'lemmas_other': 45.0, 'lits_conflict': 61.0, 'lits_loop': 349.0, 'lits_other': 266.0, 'jumps': {'jumps': 10.0, 'jumps_bounded': 2.0, 'levels': 25.0, 'levels_bounded': 2.0, 'max': 6.0, 'max_executed': 6.0, 'max_bounded': 1.0}}}}, 'summary': {'call': 9.0, 'result': 1.0, 'signal': 0.0, 'exhausted': 0.0, 'costs': [], 'lower': [], 'concurrency': 8.0, 'winner': 3.0, 'times': {'total': 0.0977630615234375, 'cpu': 0.171875, 'solve': 0.0099945068359375, 'unsat': 0.0, 'sat': 0.0029926300048828125}, 'models': {'enumerated': 1.0, 'optimal': 0.0}}, 'accu': {'times': {'total': 0.8670291900634766, 'cpu': 0.921875, 'solve': 0.04018974304199219, 'unsat': 0.017259597778320312, 'sat': 0.006954193115234375}, 'models': {'enumerated': 3.0, 'optimal': 0.0}, 'solving': {'solvers': {'choices': 2200.0, 'conflicts': 205.0, 'conflicts_analyzed': 161.0, 'restarts': 0.0, 'restarts_last': 18.0, 'extra': {'domain_choices': 0.0, 'models': 3.0, 'models_level': 524.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 149.0, 'distributed_sum_lbd': 301.0, 'integrated': 701.0, 'lemmas': 1003.0, 'lits_learnt': 4533.0, 'lemmas_binary': 202.0, 'lemmas_ternary': 76.0, 'cpu_time': 0.125, 'integrated_imps': 316.0, 'integrated_jumps': 608.0, 'guiding_paths_lits': 7667.0, 'guiding_paths': 68.0, 'splits': 0.0, 'lemmas_conflict': 149.0, 'lemmas_loop': 201.0, 'lemmas_other': 653.0, 'lits_conflict': 662.0, 'lits_loop': 1151.0, 'lits_other': 2720.0, 'jumps': {'jumps': 161.0, 'jumps_bounded': 35.0, 'levels': 3734.0, 'levels_bounded': 3108.0, 'max': 176.0, 'max_executed': 176.0, 'max_bounded': 170.0}}}}}, 'user_step': {}, 'user_accu': {}}))

[15-09-2021_15-49-22] DEBUG :: ASH Planner Main #1 >> Goal at sequence index 2 achieved.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Queueing external: External(symbol='current_last_sgoals(3, 9)', truth=True, inc_range=None)

[15-09-2021_15-49-22] DEBUG :: ASH Planner Main #1 >> Setting current sub-goal stage to index 3:sub_goal(3, talos, move(puzzle_room), in(talos), puzzle_room, 3)

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [10]:
Running step bounds   | Previous =      9 : Current =     10
Incrementor step ends | Minimum  =   None : Maximum =    100

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(10)]), ('action_effects', [Number(10)]), ('action_preconditions', [Number(10)]), ('variable_relations', [Number(10)]), ('abstraction_mappings', [Number(10)]), ('state_module', [Number(10), Number(0)]), ('plan_module', [Number(10), Number(0), Function('false', [], True), Function('false', [], True)]), ('optimisation_module', [Number(10), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('conformance_module', [Number(10), Number(0), Number(1), Number(20), Function('sequential', [], True), Function('true', [], True)])]

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.081171s.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Assigning queued external: original = External(symbol='current_last_sgoals(3, 9)', truth=True, inc_range=None), conversion = current_last_sgoals(3,9).

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.012986s with result Unsatisfiable.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [10]:
Result = SolveResult.Unsatisfiable, Stop condition = None
Increment time = 0.0941566000000007, Incremental time limit = None
Running cumulative time = 0.9074099000000002, Cumulative time limit = 3600
(RSS = 129.000000b, VMS = 123.000000b)

[15-09-2021_15-49-22] DEBUG :: ASH Planner Main #1 >> Increment feedback: Feedback(increment=10, start_step=10, end_step=11, solve_result=<SolveResult.Unsatisfiable: 'UNSAT'>, cumulative_statistics=Statistics(grounding_time=0.8015096999999995, solving_time=0.10590020000000067, total_time=0.9074099000000002, memory=Memory(rss=0.0, vms=0.0), step_range=range(0, 11), clingo_stats={}), increment_statistics=Statistics(grounding_time=0.08117060000000009, solving_time=0.012986000000000608, total_time=0.0941566000000007, memory=Memory(rss=129, vms=123), step_range=range(10, 11), clingo_stats={'problem': {'lp': {'atoms': 25113.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 140520.0, 'bodies_tr': 140520.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 1878.0, 'count_bodies_tr': 1878.0, 'sccs': 132.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 2001.0, 'rules': 280546.0, 'rules_normal': 278803.0, 'rules_choice': 1743.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 280546.0, 'rules_tr_normal': 278803.0, 'rules_tr_choice': 1743.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 50023.0, 'eqs_atom': 11058.0, 'eqs_body': 3259.0, 'eqs_other': 35706.0}, 'lpStep': {'atoms': 2145.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 14831.0, 'bodies_tr': 14831.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 183.0, 'count_bodies_tr': 183.0, 'sccs': 20.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 436.0, 'rules': 29259.0, 'rules_normal': 29103.0, 'rules_choice': 156.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 29259.0, 'rules_tr_normal': 29103.0, 'rules_tr_choice': 156.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 4749.0, 'eqs_atom': 1007.0, 'eqs_body': 63.0, 'eqs_other': 3679.0}, 'generator': {'vars': 8338.0, 'vars_eliminated': 0.0, 'vars_frozen': 5747.0, 'constraints': 1488.0, 'constraints_binary': 53648.0, 'constraints_ternary': 4541.0, 'acyc_edges': 0.0, 'complexity': 60038.0}}, 'solving': {'solvers': {'choices': 0.0, 'conflicts': 8.0, 'conflicts_analyzed': 0.0, 'restarts': 0.0, 'restarts_last': 0.0, 'extra': {'domain_choices': 0.0, 'models': 0.0, 'models_level': 0.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 0.0, 'distributed_sum_lbd': 0.0, 'integrated': 0.0, 'lemmas': 0.0, 'lits_learnt': 0.0, 'lemmas_binary': 0.0, 'lemmas_ternary': 0.0, 'cpu_time': 0.0, 'integrated_imps': 0.0, 'integrated_jumps': 0.0, 'guiding_paths_lits': 1631.0, 'guiding_paths': 7.0, 'splits': 0.0, 'lemmas_conflict': 0.0, 'lemmas_loop': 0.0, 'lemmas_other': 0.0, 'lits_conflict': 0.0, 'lits_loop': 0.0, 'lits_other': 0.0, 'jumps': {'jumps': 0.0, 'jumps_bounded': 0.0, 'levels': 0.0, 'levels_bounded': 0.0, 'max': 0.0, 'max_executed': 0.0, 'max_bounded': 0.0}}}}, 'summary': {'call': 10.0, 'result': 2.0, 'signal': 0.0, 'exhausted': 1.0, 'costs': [], 'lower': [], 'concurrency': 8.0, 'winner': 7.0, 'times': {'total': 0.09862899780273438, 'cpu': 0.09375, 'solve': 0.0038814544677734375, 'unsat': 0.0038814544677734375, 'sat': 0.0}, 'models': {'enumerated': 0.0, 'optimal': 0.0}}, 'accu': {'times': {'total': 0.9656581878662109, 'cpu': 1.015625, 'solve': 0.044071197509765625, 'unsat': 0.02114105224609375, 'sat': 0.006954193115234375}, 'models': {'enumerated': 3.0, 'optimal': 0.0}, 'solving': {'solvers': {'choices': 2200.0, 'conflicts': 213.0, 'conflicts_analyzed': 161.0, 'restarts': 0.0, 'restarts_last': 18.0, 'extra': {'domain_choices': 0.0, 'models': 3.0, 'models_level': 524.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 149.0, 'distributed_sum_lbd': 301.0, 'integrated': 701.0, 'lemmas': 1003.0, 'lits_learnt': 4533.0, 'lemmas_binary': 202.0, 'lemmas_ternary': 76.0, 'cpu_time': 0.125, 'integrated_imps': 316.0, 'integrated_jumps': 608.0, 'guiding_paths_lits': 9298.0, 'guiding_paths': 75.0, 'splits': 0.0, 'lemmas_conflict': 149.0, 'lemmas_loop': 201.0, 'lemmas_other': 653.0, 'lits_conflict': 662.0, 'lits_loop': 1151.0, 'lits_other': 2720.0, 'jumps': {'jumps': 161.0, 'jumps_bounded': 35.0, 'levels': 3734.0, 'levels_bounded': 3108.0, 'max': 176.0, 'max_executed': 176.0, 'max_bounded': 170.0}}}}}, 'user_step': {}, 'user_accu': {}}))

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [11]:
Running step bounds   | Previous =     10 : Current =     11
Incrementor step ends | Minimum  =   None : Maximum =    100

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(11)]), ('action_effects', [Number(11)]), ('action_preconditions', [Number(11)]), ('variable_relations', [Number(11)]), ('abstraction_mappings', [Number(11)]), ('state_module', [Number(11), Number(0)]), ('plan_module', [Number(11), Number(0), Function('false', [], True), Function('false', [], True)]), ('optimisation_module', [Number(11), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('conformance_module', [Number(11), Number(0), Number(1), Number(20), Function('sequential', [], True), Function('true', [], True)])]

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.078525s.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.014533s with result Unsatisfiable.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [11]:
Result = SolveResult.Unsatisfiable, Stop condition = None
Increment time = 0.09305800000000009, Incremental time limit = None
Running cumulative time = 1.0004679000000003, Cumulative time limit = 3600
(RSS = 131.000000b, VMS = 124.000000b)

[15-09-2021_15-49-22] DEBUG :: ASH Planner Main #1 >> Increment feedback: Feedback(increment=11, start_step=11, end_step=12, solve_result=<SolveResult.Unsatisfiable: 'UNSAT'>, cumulative_statistics=Statistics(grounding_time=0.8800344999999998, solving_time=0.12043340000000047, total_time=1.0004679000000003, memory=Memory(rss=0.0, vms=0.0), step_range=range(0, 12), clingo_stats={}), increment_statistics=Statistics(grounding_time=0.07852480000000028, solving_time=0.014533199999999802, total_time=0.09305800000000009, memory=Memory(rss=131, vms=124), step_range=range(11, 12), clingo_stats={'problem': {'lp': {'atoms': 27263.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 155377.0, 'bodies_tr': 155377.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 2061.0, 'count_bodies_tr': 2061.0, 'sccs': 152.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 2437.0, 'rules': 310023.0, 'rules_normal': 308124.0, 'rules_choice': 1899.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 310023.0, 'rules_tr_normal': 308124.0, 'rules_tr_choice': 1899.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 54825.0, 'eqs_atom': 12066.0, 'eqs_body': 3323.0, 'eqs_other': 39436.0}, 'lpStep': {'atoms': 2150.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 14857.0, 'bodies_tr': 14857.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 183.0, 'count_bodies_tr': 183.0, 'sccs': 20.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 436.0, 'rules': 29477.0, 'rules_normal': 29321.0, 'rules_choice': 156.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 29477.0, 'rules_tr_normal': 29321.0, 'rules_tr_choice': 156.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 4802.0, 'eqs_atom': 1008.0, 'eqs_body': 64.0, 'eqs_other': 3730.0}, 'generator': {'vars': 9892.0, 'vars_eliminated': 0.0, 'vars_frozen': 6761.0, 'constraints': 1981.0, 'constraints_binary': 71706.0, 'constraints_ternary': 6283.0, 'acyc_edges': 0.0, 'complexity': 80404.0}}, 'solving': {'solvers': {'choices': 108.0, 'conflicts': 24.0, 'conflicts_analyzed': 16.0, 'restarts': 0.0, 'restarts_last': 3.0, 'extra': {'domain_choices': 0.0, 'models': 0.0, 'models_level': 0.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 15.0, 'distributed_sum_lbd': 39.0, 'integrated': 71.0, 'lemmas': 295.0, 'lits_learnt': 2417.0, 'lemmas_binary': 0.0, 'lemmas_ternary': 21.0, 'cpu_time': 0.0, 'integrated_imps': 28.0, 'integrated_jumps': 62.0, 'guiding_paths_lits': 1778.0, 'guiding_paths': 7.0, 'splits': 0.0, 'lemmas_conflict': 15.0, 'lemmas_loop': 209.0, 'lemmas_other': 71.0, 'lits_conflict': 107.0, 'lits_loop': 1802.0, 'lits_other': 508.0, 'jumps': {'jumps': 16.0, 'jumps_bounded': 4.0, 'levels': 50.0, 'levels_bounded': 4.0, 'max': 9.0, 'max_executed': 8.0, 'max_bounded': 1.0}}}}, 'summary': {'call': 11.0, 'result': 2.0, 'signal': 0.0, 'exhausted': 1.0, 'costs': [], 'lower': [], 'concurrency': 8.0, 'winner': 3.0, 'times': {'total': 0.09474754333496094, 'cpu': 0.09375, 'solve': 0.0039653778076171875, 'unsat': 0.0039653778076171875, 'sat': 0.0}, 'models': {'enumerated': 0.0, 'optimal': 0.0}}, 'accu': {'times': {'total': 1.0604057312011719, 'cpu': 1.109375, 'solve': 0.04803657531738281, 'unsat': 0.025106430053710938, 'sat': 0.006954193115234375}, 'models': {'enumerated': 3.0, 'optimal': 0.0}, 'solving': {'solvers': {'choices': 2308.0, 'conflicts': 237.0, 'conflicts_analyzed': 177.0, 'restarts': 0.0, 'restarts_last': 18.0, 'extra': {'domain_choices': 0.0, 'models': 3.0, 'models_level': 524.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 164.0, 'distributed_sum_lbd': 340.0, 'integrated': 772.0, 'lemmas': 1298.0, 'lits_learnt': 6950.0, 'lemmas_binary': 202.0, 'lemmas_ternary': 97.0, 'cpu_time': 0.125, 'integrated_imps': 344.0, 'integrated_jumps': 670.0, 'guiding_paths_lits': 11076.0, 'guiding_paths': 82.0, 'splits': 0.0, 'lemmas_conflict': 164.0, 'lemmas_loop': 410.0, 'lemmas_other': 724.0, 'lits_conflict': 769.0, 'lits_loop': 2953.0, 'lits_other': 3228.0, 'jumps': {'jumps': 177.0, 'jumps_bounded': 39.0, 'levels': 3784.0, 'levels_bounded': 3112.0, 'max': 176.0, 'max_executed': 176.0, 'max_bounded': 170.0}}}}}, 'user_step': {}, 'user_accu': {}}))

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [12]:
Running step bounds   | Previous =     11 : Current =     12
Incrementor step ends | Minimum  =   None : Maximum =    100

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(12)]), ('action_effects', [Number(12)]), ('action_preconditions', [Number(12)]), ('variable_relations', [Number(12)]), ('abstraction_mappings', [Number(12)]), ('state_module', [Number(12), Number(0)]), ('plan_module', [Number(12), Number(0), Function('false', [], True), Function('false', [], True)]), ('optimisation_module', [Number(12), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('conformance_module', [Number(12), Number(0), Number(1), Number(20), Function('sequential', [], True), Function('true', [], True)])]

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.085583s.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.016654s with result Unsatisfiable.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [12]:
Result = SolveResult.Unsatisfiable, Stop condition = None
Increment time = 0.10223669999999974, Incremental time limit = None
Running cumulative time = 1.1027046, Cumulative time limit = 3600
(RSS = 135.000000b, VMS = 126.000000b)

[15-09-2021_15-49-22] DEBUG :: ASH Planner Main #1 >> Increment feedback: Feedback(increment=12, start_step=12, end_step=13, solve_result=<SolveResult.Unsatisfiable: 'UNSAT'>, cumulative_statistics=Statistics(grounding_time=0.9656174999999996, solving_time=0.13708710000000046, total_time=1.1027046, memory=Memory(rss=0.0, vms=0.0), step_range=range(0, 13), clingo_stats={}), increment_statistics=Statistics(grounding_time=0.08558299999999974, solving_time=0.016653699999999994, total_time=0.10223669999999974, memory=Memory(rss=135, vms=126), step_range=range(12, 13), clingo_stats={'problem': {'lp': {'atoms': 29418.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 170260.0, 'bodies_tr': 170260.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 2244.0, 'count_bodies_tr': 2244.0, 'sccs': 172.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 2873.0, 'rules': 339718.0, 'rules_normal': 337663.0, 'rules_choice': 2055.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 339718.0, 'rules_tr_normal': 337663.0, 'rules_tr_choice': 2055.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 59678.0, 'eqs_atom': 13075.0, 'eqs_body': 3386.0, 'eqs_other': 43217.0}, 'lpStep': {'atoms': 2155.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 14883.0, 'bodies_tr': 14883.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 183.0, 'count_bodies_tr': 183.0, 'sccs': 20.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 436.0, 'rules': 29695.0, 'rules_normal': 29539.0, 'rules_choice': 156.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 29695.0, 'rules_tr_normal': 29539.0, 'rules_tr_choice': 156.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 4853.0, 'eqs_atom': 1009.0, 'eqs_body': 63.0, 'eqs_other': 3781.0}, 'generator': {'vars': 11451.0, 'vars_eliminated': 0.0, 'vars_frozen': 7779.0, 'constraints': 2475.0, 'constraints_binary': 89987.0, 'constraints_ternary': 8029.0, 'acyc_edges': 0.0, 'complexity': 100998.0}}, 'solving': {'solvers': {'choices': 213.0, 'conflicts': 49.0, 'conflicts_analyzed': 43.0, 'restarts': 0.0, 'restarts_last': 12.0, 'extra': {'domain_choices': 0.0, 'models': 0.0, 'models_level': 0.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 37.0, 'distributed_sum_lbd': 106.0, 'integrated': 182.0, 'lemmas': 437.0, 'lits_learnt': 4044.0, 'lemmas_binary': 19.0, 'lemmas_ternary': 34.0, 'cpu_time': 0.0, 'integrated_imps': 29.0, 'integrated_jumps': 54.0, 'guiding_paths_lits': 1925.0, 'guiding_paths': 7.0, 'splits': 0.0, 'lemmas_conflict': 42.0, 'lemmas_loop': 226.0, 'lemmas_other': 169.0, 'lits_conflict': 467.0, 'lits_loop': 1997.0, 'lits_other': 1580.0, 'jumps': {'jumps': 43.0, 'jumps_bounded': 1.0, 'levels': 159.0, 'levels_bounded': 1.0, 'max': 38.0, 'max_executed': 38.0, 'max_bounded': 1.0}}}}, 'summary': {'call': 12.0, 'result': 2.0, 'signal': 0.0, 'exhausted': 1.0, 'costs': [], 'lower': [], 'concurrency': 8.0, 'winner': 5.0, 'times': {'total': 0.10372543334960938, 'cpu': 0.109375, 'solve': 0.0059814453125, 'unsat': 0.0059814453125, 'sat': 0.0}, 'models': {'enumerated': 0.0, 'optimal': 0.0}}, 'accu': {'times': {'total': 1.1641311645507812, 'cpu': 1.21875, 'solve': 0.05401802062988281, 'unsat': 0.031087875366210938, 'sat': 0.006954193115234375}, 'models': {'enumerated': 3.0, 'optimal': 0.0}, 'solving': {'solvers': {'choices': 2521.0, 'conflicts': 286.0, 'conflicts_analyzed': 220.0, 'restarts': 0.0, 'restarts_last': 18.0, 'extra': {'domain_choices': 0.0, 'models': 3.0, 'models_level': 524.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 201.0, 'distributed_sum_lbd': 446.0, 'integrated': 954.0, 'lemmas': 1735.0, 'lits_learnt': 10994.0, 'lemmas_binary': 221.0, 'lemmas_ternary': 131.0, 'cpu_time': 0.125, 'integrated_imps': 373.0, 'integrated_jumps': 724.0, 'guiding_paths_lits': 13001.0, 'guiding_paths': 89.0, 'splits': 0.0, 'lemmas_conflict': 206.0, 'lemmas_loop': 636.0, 'lemmas_other': 893.0, 'lits_conflict': 1236.0, 'lits_loop': 4950.0, 'lits_other': 4808.0, 'jumps': {'jumps': 220.0, 'jumps_bounded': 40.0, 'levels': 3943.0, 'levels_bounded': 3113.0, 'max': 176.0, 'max_executed': 176.0, 'max_bounded': 170.0}}}}}, 'user_step': {}, 'user_accu': {}}))

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [13]:
Running step bounds   | Previous =     12 : Current =     13
Incrementor step ends | Minimum  =   None : Maximum =    100

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(13)]), ('action_effects', [Number(13)]), ('action_preconditions', [Number(13)]), ('variable_relations', [Number(13)]), ('abstraction_mappings', [Number(13)]), ('state_module', [Number(13), Number(0)]), ('plan_module', [Number(13), Number(0), Function('false', [], True), Function('false', [], True)]), ('optimisation_module', [Number(13), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('conformance_module', [Number(13), Number(0), Number(1), Number(20), Function('sequential', [], True), Function('true', [], True)])]

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.087313s.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.026597s with result Unsatisfiable.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [13]:
Result = SolveResult.Unsatisfiable, Stop condition = None
Increment time = 0.11391010000000001, Incremental time limit = None
Running cumulative time = 1.2166147, Cumulative time limit = 3600
(RSS = 142.000000b, VMS = 135.000000b)

[15-09-2021_15-49-22] DEBUG :: ASH Planner Main #1 >> Increment feedback: Feedback(increment=13, start_step=13, end_step=14, solve_result=<SolveResult.Unsatisfiable: 'UNSAT'>, cumulative_statistics=Statistics(grounding_time=1.0529307999999995, solving_time=0.16368390000000055, total_time=1.2166147, memory=Memory(rss=0.0, vms=0.0), step_range=range(0, 14), clingo_stats={}), increment_statistics=Statistics(grounding_time=0.08731329999999993, solving_time=0.026596800000000087, total_time=0.11391010000000001, memory=Memory(rss=142, vms=135), step_range=range(13, 14), clingo_stats={'problem': {'lp': {'atoms': 31578.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 185169.0, 'bodies_tr': 185169.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 2427.0, 'count_bodies_tr': 2427.0, 'sccs': 192.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 3309.0, 'rules': 369631.0, 'rules_normal': 367420.0, 'rules_choice': 2211.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 369631.0, 'rules_tr_normal': 367420.0, 'rules_tr_choice': 2211.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 64584.0, 'eqs_atom': 14085.0, 'eqs_body': 3450.0, 'eqs_other': 47049.0}, 'lpStep': {'atoms': 2160.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 14909.0, 'bodies_tr': 14909.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 183.0, 'count_bodies_tr': 183.0, 'sccs': 20.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 436.0, 'rules': 29913.0, 'rules_normal': 29757.0, 'rules_choice': 156.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 29913.0, 'rules_tr_normal': 29757.0, 'rules_tr_choice': 156.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 4906.0, 'eqs_atom': 1010.0, 'eqs_body': 64.0, 'eqs_other': 3832.0}, 'generator': {'vars': 13015.0, 'vars_eliminated': 0.0, 'vars_frozen': 8801.0, 'constraints': 2970.0, 'constraints_binary': 108491.0, 'constraints_ternary': 9779.0, 'acyc_edges': 0.0, 'complexity': 121820.0}}, 'solving': {'solvers': {'choices': 487.0, 'conflicts': 137.0, 'conflicts_analyzed': 130.0, 'restarts': 0.0, 'restarts_last': 28.0, 'extra': {'domain_choices': 0.0, 'models': 0.0, 'models_level': 0.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 113.0, 'distributed_sum_lbd': 304.0, 'integrated': 624.0, 'lemmas': 1399.0, 'lits_learnt': 14421.0, 'lemmas_binary': 157.0, 'lemmas_ternary': 131.0, 'cpu_time': 0.109375, 'integrated_imps': 128.0, 'integrated_jumps': 225.0, 'guiding_paths_lits': 2072.0, 'guiding_paths': 7.0, 'splits': 0.0, 'lemmas_conflict': 123.0, 'lemmas_loop': 669.0, 'lemmas_other': 607.0, 'lits_conflict': 1501.0, 'lits_loop': 5635.0, 'lits_other': 7285.0, 'jumps': {'jumps': 130.0, 'jumps_bounded': 2.0, 'levels': 544.0, 'levels_bounded': 297.0, 'max': 298.0, 'max_executed': 298.0, 'max_bounded': 296.0}}}}, 'summary': {'call': 13.0, 'result': 2.0, 'signal': 0.0, 'exhausted': 1.0, 'costs': [], 'lower': [], 'concurrency': 8.0, 'winner': 7.0, 'times': {'total': 0.11569023132324219, 'cpu': 0.21875, 'solve': 0.01496124267578125, 'unsat': 0.01496124267578125, 'sat': 0.0}, 'models': {'enumerated': 0.0, 'optimal': 0.0}}, 'accu': {'times': {'total': 1.2798213958740234, 'cpu': 1.4375, 'solve': 0.06897926330566406, 'unsat': 0.04604911804199219, 'sat': 0.006954193115234375}, 'models': {'enumerated': 3.0, 'optimal': 0.0}, 'solving': {'solvers': {'choices': 3008.0, 'conflicts': 423.0, 'conflicts_analyzed': 350.0, 'restarts': 0.0, 'restarts_last': 28.0, 'extra': {'domain_choices': 0.0, 'models': 3.0, 'models_level': 524.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 314.0, 'distributed_sum_lbd': 750.0, 'integrated': 1578.0, 'lemmas': 3134.0, 'lits_learnt': 25415.0, 'lemmas_binary': 378.0, 'lemmas_ternary': 262.0, 'cpu_time': 0.234375, 'integrated_imps': 501.0, 'integrated_jumps': 949.0, 'guiding_paths_lits': 15073.0, 'guiding_paths': 96.0, 'splits': 0.0, 'lemmas_conflict': 329.0, 'lemmas_loop': 1305.0, 'lemmas_other': 1500.0, 'lits_conflict': 2737.0, 'lits_loop': 10585.0, 'lits_other': 12093.0, 'jumps': {'jumps': 350.0, 'jumps_bounded': 42.0, 'levels': 4487.0, 'levels_bounded': 3410.0, 'max': 298.0, 'max_executed': 298.0, 'max_bounded': 296.0}}}}}, 'user_step': {}, 'user_accu': {}}))

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [14]:
Running step bounds   | Previous =     13 : Current =     14
Incrementor step ends | Minimum  =   None : Maximum =    100

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(14)]), ('action_effects', [Number(14)]), ('action_preconditions', [Number(14)]), ('variable_relations', [Number(14)]), ('abstraction_mappings', [Number(14)]), ('state_module', [Number(14), Number(0)]), ('plan_module', [Number(14), Number(0), Function('false', [], True), Function('false', [], True)]), ('optimisation_module', [Number(14), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('conformance_module', [Number(14), Number(0), Number(1), Number(20), Function('sequential', [], True), Function('true', [], True)])]

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.094610s.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.025996s with result Unsatisfiable.

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [14]:
Result = SolveResult.Unsatisfiable, Stop condition = None
Increment time = 0.12060549999999992, Incremental time limit = None
Running cumulative time = 1.3372202, Cumulative time limit = 3600
(RSS = 145.000000b, VMS = 137.000000b)

[15-09-2021_15-49-22] DEBUG :: ASH Planner Main #1 >> Increment feedback: Feedback(increment=14, start_step=14, end_step=15, solve_result=<SolveResult.Unsatisfiable: 'UNSAT'>, cumulative_statistics=Statistics(grounding_time=1.1475405999999992, solving_time=0.18967960000000073, total_time=1.3372202, memory=Memory(rss=0.0, vms=0.0), step_range=range(0, 15), clingo_stats={}), increment_statistics=Statistics(grounding_time=0.09460979999999974, solving_time=0.025995700000000177, total_time=0.12060549999999992, memory=Memory(rss=145, vms=137), step_range=range(14, 15), clingo_stats={'problem': {'lp': {'atoms': 33743.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 200104.0, 'bodies_tr': 200104.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 2610.0, 'count_bodies_tr': 2610.0, 'sccs': 212.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 3745.0, 'rules': 399762.0, 'rules_normal': 397395.0, 'rules_choice': 2367.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 399762.0, 'rules_tr_normal': 397395.0, 'rules_tr_choice': 2367.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 69541.0, 'eqs_atom': 15096.0, 'eqs_body': 3513.0, 'eqs_other': 50932.0}, 'lpStep': {'atoms': 2165.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 14935.0, 'bodies_tr': 14935.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 183.0, 'count_bodies_tr': 183.0, 'sccs': 20.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 436.0, 'rules': 30131.0, 'rules_normal': 29975.0, 'rules_choice': 156.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 30131.0, 'rules_tr_normal': 29975.0, 'rules_tr_choice': 156.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 4957.0, 'eqs_atom': 1011.0, 'eqs_body': 63.0, 'eqs_other': 3883.0}, 'generator': {'vars': 14584.0, 'vars_eliminated': 0.0, 'vars_frozen': 9827.0, 'constraints': 3466.0, 'constraints_binary': 125916.0, 'constraints_ternary': 11470.0, 'acyc_edges': 0.0, 'complexity': 141505.0}}, 'solving': {'solvers': {'choices': 866.0, 'conflicts': 225.0, 'conflicts_analyzed': 218.0, 'restarts': 0.0, 'restarts_last': 52.0, 'extra': {'domain_choices': 0.0, 'models': 0.0, 'models_level': 0.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 185.0, 'distributed_sum_lbd': 514.0, 'integrated': 1004.0, 'lemmas': 1591.0, 'lits_learnt': 19041.0, 'lemmas_binary': 143.0, 'lemmas_ternary': 112.0, 'cpu_time': 0.109375, 'integrated_imps': 292.0, 'integrated_jumps': 475.0, 'guiding_paths_lits': 2219.0, 'guiding_paths': 7.0, 'splits': 0.0, 'lemmas_conflict': 214.0, 'lemmas_loop': 454.0, 'lemmas_other': 923.0, 'lits_conflict': 3275.0, 'lits_loop': 3879.0, 'lits_other': 11887.0, 'jumps': {'jumps': 218.0, 'jumps_bounded': 6.0, 'levels': 1023.0, 'levels_bounded': 638.0, 'max': 318.0, 'max_executed': 318.0, 'max_bounded': 317.0}}}}, 'summary': {'call': 14.0, 'result': 2.0, 'signal': 0.0, 'exhausted': 1.0, 'costs': [], 'lower': [], 'concurrency': 8.0, 'winner': 3.0, 'times': {'total': 0.12270164489746094, 'cpu': 0.21875, 'solve': 0.013963699340820312, 'unsat': 0.013963699340820312, 'sat': 0.0}, 'models': {'enumerated': 0.0, 'optimal': 0.0}}, 'accu': {'times': {'total': 1.4025230407714844, 'cpu': 1.65625, 'solve': 0.08294296264648438, 'unsat': 0.0600128173828125, 'sat': 0.006954193115234375}, 'models': {'enumerated': 3.0, 'optimal': 0.0}, 'solving': {'solvers': {'choices': 3874.0, 'conflicts': 648.0, 'conflicts_analyzed': 568.0, 'restarts': 0.0, 'restarts_last': 52.0, 'extra': {'domain_choices': 0.0, 'models': 3.0, 'models_level': 524.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 499.0, 'distributed_sum_lbd': 1264.0, 'integrated': 2582.0, 'lemmas': 4725.0, 'lits_learnt': 44456.0, 'lemmas_binary': 521.0, 'lemmas_ternary': 374.0, 'cpu_time': 0.34375, 'integrated_imps': 793.0, 'integrated_jumps': 1424.0, 'guiding_paths_lits': 17292.0, 'guiding_paths': 103.0, 'splits': 0.0, 'lemmas_conflict': 543.0, 'lemmas_loop': 1759.0, 'lemmas_other': 2423.0, 'lits_conflict': 6012.0, 'lits_loop': 14464.0, 'lits_other': 23980.0, 'jumps': {'jumps': 568.0, 'jumps_bounded': 48.0, 'levels': 5510.0, 'levels_bounded': 4048.0, 'max': 318.0, 'max_executed': 318.0, 'max_bounded': 317.0}}}}}, 'user_step': {}, 'user_accu': {}}))

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [15]:
Running step bounds   | Previous =     14 : Current =     15
Incrementor step ends | Minimum  =   None : Maximum =    100

[15-09-2021_15-49-22] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(15)]), ('action_effects', [Number(15)]), ('action_preconditions', [Number(15)]), ('variable_relations', [Number(15)]), ('abstraction_mappings', [Number(15)]), ('state_module', [Number(15), Number(0)]), ('plan_module', [Number(15), Number(0), Function('false', [], True), Function('false', [], True)]), ('optimisation_module', [Number(15), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('conformance_module', [Number(15), Number(0), Number(1), Number(20), Function('sequential', [], True), Function('true', [], True)])]

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.087008s.

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Model found:
Model :: Total atoms = 8114, Cost = (), Optimality proven = False, Number = 1, Thread ID = 2, Model type = ModelType.StableModel

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.048623s with result Satisfiable.

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [15]:
Result = SolveResult.Satisfiable, Stop condition = None
Increment time = 0.13563100000000006, Incremental time limit = None
Running cumulative time = 1.4728512, Cumulative time limit = 3600
(RSS = 149.000000b, VMS = 141.000000b)

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Incremental solving has found a model, current answer:
Result :: SATISFIABLE : SEARCH INTERRUPTED : Total models = 4
IncrementalStatistics :: Cumulative = (Statistics :: Grounding = 1.234548s, Solving = 0.238303s, Total = 1.472851s, Memory = (RSS = 0.000000b, VMS = 0.000000b)), Calls = 15
Final Model :: Total atoms = 8114, Cost = (), Optimality proven = False, Number = 1, Thread ID = 2, Model type = ModelType.StableModel

[15-09-2021_15-49-23] DEBUG :: ASH Planner Main #1 >> Increment feedback: Feedback(increment=15, start_step=15, end_step=16, solve_result=<SolveResult.Satisfiable: 'SAT'>, cumulative_statistics=Statistics(grounding_time=1.234548499999999, solving_time=0.2383027000000011, total_time=1.4728512, memory=Memory(rss=0.0, vms=0.0), step_range=range(0, 16), clingo_stats={}), increment_statistics=Statistics(grounding_time=0.0870078999999997, solving_time=0.04862310000000036, total_time=0.13563100000000006, memory=Memory(rss=149, vms=141), step_range=range(15, 16), clingo_stats={'problem': {'lp': {'atoms': 35913.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 215065.0, 'bodies_tr': 215065.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 2793.0, 'count_bodies_tr': 2793.0, 'sccs': 232.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 4181.0, 'rules': 430111.0, 'rules_normal': 427588.0, 'rules_choice': 2523.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 430111.0, 'rules_tr_normal': 427588.0, 'rules_tr_choice': 2523.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 74551.0, 'eqs_atom': 16108.0, 'eqs_body': 3577.0, 'eqs_other': 54866.0}, 'lpStep': {'atoms': 2170.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 14961.0, 'bodies_tr': 14961.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 183.0, 'count_bodies_tr': 183.0, 'sccs': 20.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 436.0, 'rules': 30349.0, 'rules_normal': 30193.0, 'rules_choice': 156.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 30349.0, 'rules_tr_normal': 30193.0, 'rules_tr_choice': 156.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 5010.0, 'eqs_atom': 1012.0, 'eqs_body': 64.0, 'eqs_other': 3934.0}, 'generator': {'vars': 16158.0, 'vars_eliminated': 0.0, 'vars_frozen': 10857.0, 'constraints': 3805.0, 'constraints_binary': 140086.0, 'constraints_ternary': 12593.0, 'acyc_edges': 0.0, 'complexity': 157182.0}}, 'solving': {'solvers': {'choices': 2875.0, 'conflicts': 377.0, 'conflicts_analyzed': 377.0, 'restarts': 0.0, 'restarts_last': 96.0, 'extra': {'domain_choices': 0.0, 'models': 1.0, 'models_level': 466.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 268.0, 'distributed_sum_lbd': 769.0, 'integrated': 1554.0, 'lemmas': 2415.0, 'lits_learnt': 37506.0, 'lemmas_binary': 251.0, 'lemmas_ternary': 225.0, 'cpu_time': 0.21875, 'integrated_imps': 316.0, 'integrated_jumps': 1292.0, 'guiding_paths_lits': 2366.0, 'guiding_paths': 7.0, 'splits': 0.0, 'lemmas_conflict': 373.0, 'lemmas_loop': 572.0, 'lemmas_other': 1470.0, 'lits_conflict': 7754.0, 'lits_loop': 4794.0, 'lits_other': 24958.0, 'jumps': {'jumps': 377.0, 'jumps_bounded': 4.0, 'levels': 1054.0, 'levels_bounded': 341.0, 'max': 339.0, 'max_executed': 339.0, 'max_bounded': 338.0}}}}, 'summary': {'call': 15.0, 'result': 1.0, 'signal': 0.0, 'exhausted': 0.0, 'costs': [], 'lower': [], 'concurrency': 8.0, 'winner': 2.0, 'times': {'total': 0.140625, 'cpu': 0.296875, 'solve': 0.03690147399902344, 'unsat': 0.0, 'sat': 0.023937225341796875}, 'models': {'enumerated': 1.0, 'optimal': 0.0}}, 'accu': {'times': {'total': 1.5431480407714844, 'cpu': 1.953125, 'solve': 0.11984443664550781, 'unsat': 0.0600128173828125, 'sat': 0.03089141845703125}, 'models': {'enumerated': 4.0, 'optimal': 0.0}, 'solving': {'solvers': {'choices': 6749.0, 'conflicts': 1025.0, 'conflicts_analyzed': 945.0, 'restarts': 0.0, 'restarts_last': 96.0, 'extra': {'domain_choices': 0.0, 'models': 4.0, 'models_level': 990.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 767.0, 'distributed_sum_lbd': 2033.0, 'integrated': 4136.0, 'lemmas': 7140.0, 'lits_learnt': 81962.0, 'lemmas_binary': 772.0, 'lemmas_ternary': 599.0, 'cpu_time': 0.5625, 'integrated_imps': 1109.0, 'integrated_jumps': 2716.0, 'guiding_paths_lits': 19658.0, 'guiding_paths': 110.0, 'splits': 0.0, 'lemmas_conflict': 916.0, 'lemmas_loop': 2331.0, 'lemmas_other': 3893.0, 'lits_conflict': 13766.0, 'lits_loop': 19258.0, 'lits_other': 48938.0, 'jumps': {'jumps': 945.0, 'jumps_bounded': 52.0, 'levels': 6564.0, 'levels_bounded': 4389.0, 'max': 339.0, 'max_executed': 339.0, 'max_bounded': 338.0}}}}}, 'user_step': {}, 'user_accu': {}}))

[15-09-2021_15-49-23] DEBUG :: ASH Planner Main #1 >> Goal at sequence index 3 achieved.

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Queueing external: External(symbol='current_last_sgoals(4, 15)', truth=True, inc_range=None)

[15-09-2021_15-49-23] DEBUG :: ASH Planner Main #1 >> Setting current sub-goal stage to index 4:sub_goal(3, talos, put(manipulator_arm_2,(block,6),puzzle_room_table), on((block,6)), puzzle_room_table, 4)

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [16]:
Running step bounds   | Previous =     15 : Current =     16
Incrementor step ends | Minimum  =   None : Maximum =    100

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(16)]), ('action_effects', [Number(16)]), ('action_preconditions', [Number(16)]), ('variable_relations', [Number(16)]), ('abstraction_mappings', [Number(16)]), ('state_module', [Number(16), Number(0)]), ('plan_module', [Number(16), Number(0), Function('false', [], True), Function('false', [], True)]), ('optimisation_module', [Number(16), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('conformance_module', [Number(16), Number(0), Number(1), Number(20), Function('sequential', [], True), Function('true', [], True)])]

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.093936s.

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Assigning queued external: original = External(symbol='current_last_sgoals(4, 15)', truth=True, inc_range=None), conversion = current_last_sgoals(4,15).

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.019520s with result Unsatisfiable.

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [16]:
Result = SolveResult.Unsatisfiable, Stop condition = None
Increment time = 0.11345589999999994, Incremental time limit = None
Running cumulative time = 1.5863071, Cumulative time limit = 3600
(RSS = 155.000000b, VMS = 150.000000b)

[15-09-2021_15-49-23] DEBUG :: ASH Planner Main #1 >> Increment feedback: Feedback(increment=16, start_step=16, end_step=17, solve_result=<SolveResult.Unsatisfiable: 'UNSAT'>, cumulative_statistics=Statistics(grounding_time=1.3284846999999989, solving_time=0.2578224000000011, total_time=1.5863071, memory=Memory(rss=0.0, vms=0.0), step_range=range(0, 17), clingo_stats={}), increment_statistics=Statistics(grounding_time=0.09393619999999991, solving_time=0.01951970000000003, total_time=0.11345589999999994, memory=Memory(rss=155, vms=150), step_range=range(16, 17), clingo_stats={'problem': {'lp': {'atoms': 38088.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 230052.0, 'bodies_tr': 230052.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 2976.0, 'count_bodies_tr': 2976.0, 'sccs': 252.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 4617.0, 'rules': 460678.0, 'rules_normal': 457999.0, 'rules_choice': 2679.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 460678.0, 'rules_tr_normal': 457999.0, 'rules_tr_choice': 2679.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 79612.0, 'eqs_atom': 17121.0, 'eqs_body': 3640.0, 'eqs_other': 58851.0}, 'lpStep': {'atoms': 2175.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 14987.0, 'bodies_tr': 14987.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 183.0, 'count_bodies_tr': 183.0, 'sccs': 20.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 436.0, 'rules': 30567.0, 'rules_normal': 30411.0, 'rules_choice': 156.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 30567.0, 'rules_tr_normal': 30411.0, 'rules_tr_choice': 156.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 5061.0, 'eqs_atom': 1013.0, 'eqs_body': 63.0, 'eqs_other': 3985.0}, 'generator': {'vars': 17737.0, 'vars_eliminated': 0.0, 'vars_frozen': 11891.0, 'constraints': 4033.0, 'constraints_binary': 150291.0, 'constraints_ternary': 13348.0, 'acyc_edges': 0.0, 'complexity': 168407.0}}, 'solving': {'solvers': {'choices': 0.0, 'conflicts': 8.0, 'conflicts_analyzed': 0.0, 'restarts': 0.0, 'restarts_last': 0.0, 'extra': {'domain_choices': 0.0, 'models': 0.0, 'models_level': 0.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 0.0, 'distributed_sum_lbd': 0.0, 'integrated': 0.0, 'lemmas': 0.0, 'lits_learnt': 0.0, 'lemmas_binary': 0.0, 'lemmas_ternary': 0.0, 'cpu_time': 0.0, 'integrated_imps': 0.0, 'integrated_jumps': 0.0, 'guiding_paths_lits': 2513.0, 'guiding_paths': 7.0, 'splits': 0.0, 'lemmas_conflict': 0.0, 'lemmas_loop': 0.0, 'lemmas_other': 0.0, 'lits_conflict': 0.0, 'lits_loop': 0.0, 'lits_other': 0.0, 'jumps': {'jumps': 0.0, 'jumps_bounded': 0.0, 'levels': 0.0, 'levels_bounded': 0.0, 'max': 0.0, 'max_executed': 0.0, 'max_bounded': 0.0}}}}, 'summary': {'call': 16.0, 'result': 2.0, 'signal': 0.0, 'exhausted': 1.0, 'costs': [], 'lower': [], 'concurrency': 8.0, 'winner': 0.0, 'times': {'total': 0.12111091613769531, 'cpu': 0.109375, 'solve': 0.0050067901611328125, 'unsat': 0.0050067901611328125, 'sat': 0.0}, 'models': {'enumerated': 0.0, 'optimal': 0.0}}, 'accu': {'times': {'total': 1.6642589569091797, 'cpu': 2.0625, 'solve': 0.12485122680664062, 'unsat': 0.06501960754394531, 'sat': 0.03089141845703125}, 'models': {'enumerated': 4.0, 'optimal': 0.0}, 'solving': {'solvers': {'choices': 6749.0, 'conflicts': 1033.0, 'conflicts_analyzed': 945.0, 'restarts': 0.0, 'restarts_last': 96.0, 'extra': {'domain_choices': 0.0, 'models': 4.0, 'models_level': 990.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 767.0, 'distributed_sum_lbd': 2033.0, 'integrated': 4136.0, 'lemmas': 7140.0, 'lits_learnt': 81962.0, 'lemmas_binary': 772.0, 'lemmas_ternary': 599.0, 'cpu_time': 0.5625, 'integrated_imps': 1109.0, 'integrated_jumps': 2716.0, 'guiding_paths_lits': 22171.0, 'guiding_paths': 117.0, 'splits': 0.0, 'lemmas_conflict': 916.0, 'lemmas_loop': 2331.0, 'lemmas_other': 3893.0, 'lits_conflict': 13766.0, 'lits_loop': 19258.0, 'lits_other': 48938.0, 'jumps': {'jumps': 945.0, 'jumps_bounded': 52.0, 'levels': 6564.0, 'levels_bounded': 4389.0, 'max': 339.0, 'max_executed': 339.0, 'max_bounded': 338.0}}}}}, 'user_step': {}, 'user_accu': {}}))

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [17]:
Running step bounds   | Previous =     16 : Current =     17
Incrementor step ends | Minimum  =   None : Maximum =    100

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(17)]), ('action_effects', [Number(17)]), ('action_preconditions', [Number(17)]), ('variable_relations', [Number(17)]), ('abstraction_mappings', [Number(17)]), ('state_module', [Number(17), Number(0)]), ('plan_module', [Number(17), Number(0), Function('false', [], True), Function('false', [], True)]), ('optimisation_module', [Number(17), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('conformance_module', [Number(17), Number(0), Number(1), Number(20), Function('sequential', [], True), Function('true', [], True)])]

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.090012s.

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Model found:
Model :: Total atoms = 8793, Cost = (), Optimality proven = False, Number = 1, Thread ID = 4, Model type = ModelType.StableModel

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.039090s with result Satisfiable.

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [17]:
Result = SolveResult.Satisfiable, Stop condition = None
Increment time = 0.1291019000000002, Incremental time limit = None
Running cumulative time = 1.7154090000000002, Cumulative time limit = 3600
(RSS = 160.000000b, VMS = 154.000000b)

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Incremental solving has found a model, current answer:
Result :: SATISFIABLE : SEARCH INTERRUPTED : Total models = 5
IncrementalStatistics :: Cumulative = (Statistics :: Grounding = 1.418496s, Solving = 0.296913s, Total = 1.715409s, Memory = (RSS = 0.000000b, VMS = 0.000000b)), Calls = 17
Final Model :: Total atoms = 8793, Cost = (), Optimality proven = False, Number = 1, Thread ID = 4, Model type = ModelType.StableModel

[15-09-2021_15-49-23] DEBUG :: ASH Planner Main #1 >> Increment feedback: Feedback(increment=17, start_step=17, end_step=18, solve_result=<SolveResult.Satisfiable: 'SAT'>, cumulative_statistics=Statistics(grounding_time=1.4184962999999993, solving_time=0.2969127000000009, total_time=1.7154090000000002, memory=Memory(rss=0.0, vms=0.0), step_range=range(0, 18), clingo_stats={}), increment_statistics=Statistics(grounding_time=0.09001160000000041, solving_time=0.0390902999999998, total_time=0.1291019000000002, memory=Memory(rss=160, vms=154), step_range=range(17, 18), clingo_stats={'problem': {'lp': {'atoms': 40268.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 245065.0, 'bodies_tr': 245065.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 3159.0, 'count_bodies_tr': 3159.0, 'sccs': 272.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 5053.0, 'rules': 491463.0, 'rules_normal': 488628.0, 'rules_choice': 2835.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 491463.0, 'rules_tr_normal': 488628.0, 'rules_tr_choice': 2835.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 84726.0, 'eqs_atom': 18135.0, 'eqs_body': 3704.0, 'eqs_other': 62887.0}, 'lpStep': {'atoms': 2180.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 15013.0, 'bodies_tr': 15013.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 183.0, 'count_bodies_tr': 183.0, 'sccs': 20.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 436.0, 'rules': 30785.0, 'rules_normal': 30629.0, 'rules_choice': 156.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 30785.0, 'rules_tr_normal': 30629.0, 'rules_tr_choice': 156.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 5114.0, 'eqs_atom': 1014.0, 'eqs_body': 64.0, 'eqs_other': 4036.0}, 'generator': {'vars': 19321.0, 'vars_eliminated': 0.0, 'vars_frozen': 12929.0, 'constraints': 4532.0, 'constraints_binary': 169687.0, 'constraints_ternary': 15123.0, 'acyc_edges': 0.0, 'complexity': 190150.0}}, 'solving': {'solvers': {'choices': 1844.0, 'conflicts': 111.0, 'conflicts_analyzed': 111.0, 'restarts': 0.0, 'restarts_last': 41.0, 'extra': {'domain_choices': 0.0, 'models': 1.0, 'models_level': 526.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 78.0, 'distributed_sum_lbd': 235.0, 'integrated': 401.0, 'lemmas': 678.0, 'lits_learnt': 10636.0, 'lemmas_binary': 55.0, 'lemmas_ternary': 78.0, 'cpu_time': 0.125, 'integrated_imps': 43.0, 'integrated_jumps': 858.0, 'guiding_paths_lits': 2660.0, 'guiding_paths': 7.0, 'splits': 0.0, 'lemmas_conflict': 111.0, 'lemmas_loop': 166.0, 'lemmas_other': 401.0, 'lits_conflict': 2931.0, 'lits_loop': 1260.0, 'lits_other': 6445.0, 'jumps': {'jumps': 111.0, 'jumps_bounded': 1.0, 'levels': 174.0, 'levels_bounded': 1.0, 'max': 11.0, 'max_executed': 11.0, 'max_bounded': 1.0}}}}, 'summary': {'call': 17.0, 'result': 1.0, 'signal': 0.0, 'exhausted': 0.0, 'costs': [], 'lower': [], 'concurrency': 8.0, 'winner': 4.0, 'times': {'total': 0.1316509246826172, 'cpu': 0.234375, 'solve': 0.02294158935546875, 'unsat': 0.0, 'sat': 0.006984710693359375}, 'models': {'enumerated': 1.0, 'optimal': 0.0}}, 'accu': {'times': {'total': 1.7959098815917969, 'cpu': 2.296875, 'solve': 0.14779281616210938, 'unsat': 0.06501960754394531, 'sat': 0.037876129150390625}, 'models': {'enumerated': 5.0, 'optimal': 0.0}, 'solving': {'solvers': {'choices': 8593.0, 'conflicts': 1144.0, 'conflicts_analyzed': 1056.0, 'restarts': 0.0, 'restarts_last': 96.0, 'extra': {'domain_choices': 0.0, 'models': 5.0, 'models_level': 1516.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 845.0, 'distributed_sum_lbd': 2268.0, 'integrated': 4537.0, 'lemmas': 7818.0, 'lits_learnt': 92598.0, 'lemmas_binary': 827.0, 'lemmas_ternary': 677.0, 'cpu_time': 0.6875, 'integrated_imps': 1152.0, 'integrated_jumps': 3574.0, 'guiding_paths_lits': 24831.0, 'guiding_paths': 124.0, 'splits': 0.0, 'lemmas_conflict': 1027.0, 'lemmas_loop': 2497.0, 'lemmas_other': 4294.0, 'lits_conflict': 16697.0, 'lits_loop': 20518.0, 'lits_other': 55383.0, 'jumps': {'jumps': 1056.0, 'jumps_bounded': 53.0, 'levels': 6738.0, 'levels_bounded': 4390.0, 'max': 339.0, 'max_executed': 339.0, 'max_bounded': 338.0}}}}}, 'user_step': {}, 'user_accu': {}}))

[15-09-2021_15-49-23] DEBUG :: ASH Planner Main #1 >> Goal at sequence index 4 achieved.

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Queueing external: External(symbol='current_last_sgoals(5, 17)', truth=True, inc_range=None)

[15-09-2021_15-49-23] DEBUG :: ASH Planner Main #1 >> Setting current sub-goal stage to index 5:sub_goal(3, talos, grasp(manipulator_arm_1,(block,2)), grasping(manipulator_arm_1), (block,2), 5)

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [18]:
Running step bounds   | Previous =     17 : Current =     18
Incrementor step ends | Minimum  =   None : Maximum =    100

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(18)]), ('action_effects', [Number(18)]), ('action_preconditions', [Number(18)]), ('variable_relations', [Number(18)]), ('abstraction_mappings', [Number(18)]), ('state_module', [Number(18), Number(0)]), ('plan_module', [Number(18), Number(0), Function('false', [], True), Function('false', [], True)]), ('optimisation_module', [Number(18), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('conformance_module', [Number(18), Number(0), Number(1), Number(20), Function('sequential', [], True), Function('true', [], True)])]

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.115276s.

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Assigning queued external: original = External(symbol='current_last_sgoals(5, 17)', truth=True, inc_range=None), conversion = current_last_sgoals(5,17).

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.022964s with result Unsatisfiable.

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [18]:
Result = SolveResult.Unsatisfiable, Stop condition = None
Increment time = 0.13824089999999956, Incremental time limit = None
Running cumulative time = 1.8536498999999997, Cumulative time limit = 3600
(RSS = 162.000000b, VMS = 156.000000b)

[15-09-2021_15-49-23] DEBUG :: ASH Planner Main #1 >> Increment feedback: Feedback(increment=18, start_step=18, end_step=19, solve_result=<SolveResult.Unsatisfiable: 'UNSAT'>, cumulative_statistics=Statistics(grounding_time=1.5337727999999986, solving_time=0.31987710000000114, total_time=1.8536498999999997, memory=Memory(rss=0.0, vms=0.0), step_range=range(0, 19), clingo_stats={}), increment_statistics=Statistics(grounding_time=0.11527649999999934, solving_time=0.022964400000000218, total_time=0.13824089999999956, memory=Memory(rss=162, vms=156), step_range=range(18, 19), clingo_stats={'problem': {'lp': {'atoms': 42453.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 260104.0, 'bodies_tr': 260104.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 3342.0, 'count_bodies_tr': 3342.0, 'sccs': 292.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 5489.0, 'rules': 522466.0, 'rules_normal': 519475.0, 'rules_choice': 2991.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 522466.0, 'rules_tr_normal': 519475.0, 'rules_tr_choice': 2991.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 89891.0, 'eqs_atom': 19150.0, 'eqs_body': 3767.0, 'eqs_other': 66974.0}, 'lpStep': {'atoms': 2185.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 15039.0, 'bodies_tr': 15039.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 183.0, 'count_bodies_tr': 183.0, 'sccs': 20.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 436.0, 'rules': 31003.0, 'rules_normal': 30847.0, 'rules_choice': 156.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 31003.0, 'rules_tr_normal': 30847.0, 'rules_tr_choice': 156.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 5165.0, 'eqs_atom': 1015.0, 'eqs_body': 63.0, 'eqs_other': 4087.0}, 'generator': {'vars': 20910.0, 'vars_eliminated': 0.0, 'vars_frozen': 13971.0, 'constraints': 5028.0, 'constraints_binary': 189282.0, 'constraints_ternary': 16834.0, 'acyc_edges': 0.0, 'complexity': 212025.0}}, 'solving': {'solvers': {'choices': 72.0, 'conflicts': 23.0, 'conflicts_analyzed': 18.0, 'restarts': 0.0, 'restarts_last': 7.0, 'extra': {'domain_choices': 0.0, 'models': 0.0, 'models_level': 0.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 14.0, 'distributed_sum_lbd': 37.0, 'integrated': 53.0, 'lemmas': 80.0, 'lits_learnt': 3121.0, 'lemmas_binary': 6.0, 'lemmas_ternary': 0.0, 'cpu_time': 0.125, 'integrated_imps': 11.0, 'integrated_jumps': 33.0, 'guiding_paths_lits': 2807.0, 'guiding_paths': 7.0, 'splits': 0.0, 'lemmas_conflict': 18.0, 'lemmas_loop': 10.0, 'lemmas_other': 52.0, 'lits_conflict': 865.0, 'lits_loop': 78.0, 'lits_other': 2178.0, 'jumps': {'jumps': 18.0, 'jumps_bounded': 2.0, 'levels': 28.0, 'levels_bounded': 2.0, 'max': 7.0, 'max_executed': 7.0, 'max_bounded': 1.0}}}}, 'summary': {'call': 18.0, 'result': 2.0, 'signal': 0.0, 'exhausted': 1.0, 'costs': [], 'lower': [], 'concurrency': 8.0, 'winner': 5.0, 'times': {'total': 0.14361572265625, 'cpu': 0.234375, 'solve': 0.008975982666015625, 'unsat': 0.008975982666015625, 'sat': 0.0}, 'models': {'enumerated': 0.0, 'optimal': 0.0}}, 'accu': {'times': {'total': 1.9395256042480469, 'cpu': 2.53125, 'solve': 0.156768798828125, 'unsat': 0.07399559020996094, 'sat': 0.037876129150390625}, 'models': {'enumerated': 5.0, 'optimal': 0.0}, 'solving': {'solvers': {'choices': 8665.0, 'conflicts': 1167.0, 'conflicts_analyzed': 1074.0, 'restarts': 0.0, 'restarts_last': 96.0, 'extra': {'domain_choices': 0.0, 'models': 5.0, 'models_level': 1516.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 859.0, 'distributed_sum_lbd': 2305.0, 'integrated': 4590.0, 'lemmas': 7898.0, 'lits_learnt': 95719.0, 'lemmas_binary': 833.0, 'lemmas_ternary': 677.0, 'cpu_time': 0.8125, 'integrated_imps': 1163.0, 'integrated_jumps': 3607.0, 'guiding_paths_lits': 27638.0, 'guiding_paths': 131.0, 'splits': 0.0, 'lemmas_conflict': 1045.0, 'lemmas_loop': 2507.0, 'lemmas_other': 4346.0, 'lits_conflict': 17562.0, 'lits_loop': 20596.0, 'lits_other': 57561.0, 'jumps': {'jumps': 1074.0, 'jumps_bounded': 55.0, 'levels': 6766.0, 'levels_bounded': 4392.0, 'max': 339.0, 'max_executed': 339.0, 'max_bounded': 338.0}}}}}, 'user_step': {}, 'user_accu': {}}))

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [19]:
Running step bounds   | Previous =     18 : Current =     19
Incrementor step ends | Minimum  =   None : Maximum =    100

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(19)]), ('action_effects', [Number(19)]), ('action_preconditions', [Number(19)]), ('variable_relations', [Number(19)]), ('abstraction_mappings', [Number(19)]), ('state_module', [Number(19), Number(0)]), ('plan_module', [Number(19), Number(0), Function('false', [], True), Function('false', [], True)]), ('optimisation_module', [Number(19), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('conformance_module', [Number(19), Number(0), Number(1), Number(20), Function('sequential', [], True), Function('true', [], True)])]

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.095394s.

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Model found:
Model :: Total atoms = 9474, Cost = (), Optimality proven = False, Number = 1, Thread ID = 5, Model type = ModelType.StableModel

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.048398s with result Satisfiable.

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [19]:
Result = SolveResult.Satisfiable, Stop condition = None
Increment time = 0.14379279999999994, Incremental time limit = None
Running cumulative time = 1.9974426999999997, Cumulative time limit = 3600
(RSS = 167.000000b, VMS = 160.000000b)

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Incremental solving has found a model, current answer:
Result :: SATISFIABLE : SEARCH INTERRUPTED : Total models = 6
IncrementalStatistics :: Cumulative = (Statistics :: Grounding = 1.629167s, Solving = 0.368275s, Total = 1.997443s, Memory = (RSS = 0.000000b, VMS = 0.000000b)), Calls = 19
Final Model :: Total atoms = 9474, Cost = (), Optimality proven = False, Number = 1, Thread ID = 5, Model type = ModelType.StableModel

[15-09-2021_15-49-23] DEBUG :: ASH Planner Main #1 >> Increment feedback: Feedback(increment=19, start_step=19, end_step=20, solve_result=<SolveResult.Satisfiable: 'SAT'>, cumulative_statistics=Statistics(grounding_time=1.629167299999998, solving_time=0.3682754000000017, total_time=1.9974426999999997, memory=Memory(rss=0.0, vms=0.0), step_range=range(0, 20), clingo_stats={}), increment_statistics=Statistics(grounding_time=0.09539449999999938, solving_time=0.04839830000000056, total_time=0.14379279999999994, memory=Memory(rss=167, vms=160), step_range=range(19, 20), clingo_stats={'problem': {'lp': {'atoms': 44643.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 275169.0, 'bodies_tr': 275169.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 3525.0, 'count_bodies_tr': 3525.0, 'sccs': 312.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 5925.0, 'rules': 553687.0, 'rules_normal': 550540.0, 'rules_choice': 3147.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 553687.0, 'rules_tr_normal': 550540.0, 'rules_tr_choice': 3147.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 95109.0, 'eqs_atom': 20166.0, 'eqs_body': 3831.0, 'eqs_other': 71112.0}, 'lpStep': {'atoms': 2190.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 15065.0, 'bodies_tr': 15065.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 183.0, 'count_bodies_tr': 183.0, 'sccs': 20.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 436.0, 'rules': 31221.0, 'rules_normal': 31065.0, 'rules_choice': 156.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 31221.0, 'rules_tr_normal': 31065.0, 'rules_tr_choice': 156.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 5218.0, 'eqs_atom': 1016.0, 'eqs_body': 64.0, 'eqs_other': 4138.0}, 'generator': {'vars': 22504.0, 'vars_eliminated': 0.0, 'vars_frozen': 15017.0, 'constraints': 5529.0, 'constraints_binary': 209124.0, 'constraints_ternary': 18608.0, 'acyc_edges': 0.0, 'complexity': 234215.0}}, 'solving': {'solvers': {'choices': 1606.0, 'conflicts': 184.0, 'conflicts_analyzed': 184.0, 'restarts': 0.0, 'restarts_last': 62.0, 'extra': {'domain_choices': 0.0, 'models': 1.0, 'models_level': 602.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 132.0, 'distributed_sum_lbd': 384.0, 'integrated': 586.0, 'lemmas': 1292.0, 'lits_learnt': 21198.0, 'lemmas_binary': 75.0, 'lemmas_ternary': 72.0, 'cpu_time': 0.3125, 'integrated_imps': 102.0, 'integrated_jumps': 797.0, 'guiding_paths_lits': 2954.0, 'guiding_paths': 7.0, 'splits': 0.0, 'lemmas_conflict': 184.0, 'lemmas_loop': 526.0, 'lemmas_other': 582.0, 'lits_conflict': 5373.0, 'lits_loop': 4309.0, 'lits_other': 11516.0, 'jumps': {'jumps': 184.0, 'jumps_bounded': 3.0, 'levels': 1144.0, 'levels_bounded': 845.0, 'max': 429.0, 'max_executed': 429.0, 'max_bounded': 422.0}}}}, 'summary': {'call': 19.0, 'result': 1.0, 'signal': 0.0, 'exhausted': 0.0, 'costs': [], 'lower': [], 'concurrency': 8.0, 'winner': 5.0, 'times': {'total': 0.14655303955078125, 'cpu': 0.421875, 'solve': 0.03581809997558594, 'unsat': 0.0, 'sat': 0.016923904418945312}, 'models': {'enumerated': 1.0, 'optimal': 0.0}}, 'accu': {'times': {'total': 2.086078643798828, 'cpu': 2.953125, 'solve': 0.19258689880371094, 'unsat': 0.07399559020996094, 'sat': 0.05480003356933594}, 'models': {'enumerated': 6.0, 'optimal': 0.0}, 'solving': {'solvers': {'choices': 10271.0, 'conflicts': 1351.0, 'conflicts_analyzed': 1258.0, 'restarts': 0.0, 'restarts_last': 96.0, 'extra': {'domain_choices': 0.0, 'models': 6.0, 'models_level': 2118.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 991.0, 'distributed_sum_lbd': 2689.0, 'integrated': 5176.0, 'lemmas': 9190.0, 'lits_learnt': 116917.0, 'lemmas_binary': 908.0, 'lemmas_ternary': 749.0, 'cpu_time': 1.125, 'integrated_imps': 1265.0, 'integrated_jumps': 4404.0, 'guiding_paths_lits': 30592.0, 'guiding_paths': 138.0, 'splits': 0.0, 'lemmas_conflict': 1229.0, 'lemmas_loop': 3033.0, 'lemmas_other': 4928.0, 'lits_conflict': 22935.0, 'lits_loop': 24905.0, 'lits_other': 69077.0, 'jumps': {'jumps': 1258.0, 'jumps_bounded': 58.0, 'levels': 7910.0, 'levels_bounded': 5237.0, 'max': 429.0, 'max_executed': 429.0, 'max_bounded': 422.0}}}}}, 'user_step': {}, 'user_accu': {}}))

[15-09-2021_15-49-23] DEBUG :: ASH Planner Main #1 >> Goal at sequence index 5 achieved.

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Queueing external: External(symbol='current_last_sgoals(6, 19)', truth=True, inc_range=None)

[15-09-2021_15-49-23] DEBUG :: ASH Planner Main #1 >> Setting current sub-goal stage to index 6:sub_goal(3, talos, release(manipulator_arm_2,(block,6)), grasping(manipulator_arm_2), nothing, 6)

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [20]:
Running step bounds   | Previous =     19 : Current =     20
Incrementor step ends | Minimum  =   None : Maximum =    100

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(20)]), ('action_effects', [Number(20)]), ('action_preconditions', [Number(20)]), ('variable_relations', [Number(20)]), ('abstraction_mappings', [Number(20)]), ('state_module', [Number(20), Number(0)]), ('plan_module', [Number(20), Number(0), Function('false', [], True), Function('false', [], True)]), ('optimisation_module', [Number(20), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('conformance_module', [Number(20), Number(0), Number(1), Number(20), Function('sequential', [], True), Function('true', [], True)])]

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.098012s.

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Assigning queued external: original = External(symbol='current_last_sgoals(6, 19)', truth=True, inc_range=None), conversion = current_last_sgoals(6,19).

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Model found:
Model :: Total atoms = 9817, Cost = (), Optimality proven = False, Number = 1, Thread ID = 2, Model type = ModelType.StableModel

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.040282s with result Satisfiable.

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [20]:
Result = SolveResult.Satisfiable, Stop condition = None
Increment time = 0.13829400000000014, Incremental time limit = None
Running cumulative time = 2.1357367, Cumulative time limit = 3600
(RSS = 171.000000b, VMS = 163.000000b)

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Incremental solving has found a model, current answer:
Result :: SATISFIABLE : SEARCH INTERRUPTED : Total models = 7
IncrementalStatistics :: Cumulative = (Statistics :: Grounding = 1.727180s, Solving = 0.408557s, Total = 2.135737s, Memory = (RSS = 0.000000b, VMS = 0.000000b)), Calls = 20
Final Model :: Total atoms = 9817, Cost = (), Optimality proven = False, Number = 1, Thread ID = 2, Model type = ModelType.StableModel

[15-09-2021_15-49-23] DEBUG :: ASH Planner Main #1 >> Increment feedback: Feedback(increment=20, start_step=20, end_step=21, solve_result=<SolveResult.Satisfiable: 'SAT'>, cumulative_statistics=Statistics(grounding_time=1.7271795999999986, solving_time=0.4085571000000012, total_time=2.1357367, memory=Memory(rss=0.0, vms=0.0), step_range=range(0, 21), clingo_stats={}), increment_statistics=Statistics(grounding_time=0.09801230000000061, solving_time=0.04028169999999953, total_time=0.13829400000000014, memory=Memory(rss=171, vms=163), step_range=range(20, 21), clingo_stats={'problem': {'lp': {'atoms': 46838.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 290260.0, 'bodies_tr': 290260.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 3708.0, 'count_bodies_tr': 3708.0, 'sccs': 332.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 6361.0, 'rules': 585126.0, 'rules_normal': 581823.0, 'rules_choice': 3303.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 585126.0, 'rules_tr_normal': 581823.0, 'rules_tr_choice': 3303.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 100378.0, 'eqs_atom': 21183.0, 'eqs_body': 3894.0, 'eqs_other': 75301.0}, 'lpStep': {'atoms': 2195.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 15091.0, 'bodies_tr': 15091.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 183.0, 'count_bodies_tr': 183.0, 'sccs': 20.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 436.0, 'rules': 31439.0, 'rules_normal': 31283.0, 'rules_choice': 156.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 31439.0, 'rules_tr_normal': 31283.0, 'rules_tr_choice': 156.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 5269.0, 'eqs_atom': 1017.0, 'eqs_body': 63.0, 'eqs_other': 4189.0}, 'generator': {'vars': 24103.0, 'vars_eliminated': 0.0, 'vars_frozen': 16067.0, 'constraints': 5741.0, 'constraints_binary': 218455.0, 'constraints_ternary': 19123.0, 'acyc_edges': 0.0, 'complexity': 244302.0}}, 'solving': {'solvers': {'choices': 1340.0, 'conflicts': 34.0, 'conflicts_analyzed': 34.0, 'restarts': 0.0, 'restarts_last': 16.0, 'extra': {'domain_choices': 0.0, 'models': 1.0, 'models_level': 617.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 30.0, 'distributed_sum_lbd': 84.0, 'integrated': 118.0, 'lemmas': 255.0, 'lits_learnt': 7912.0, 'lemmas_binary': 22.0, 'lemmas_ternary': 0.0, 'cpu_time': 0.09375, 'integrated_imps': 22.0, 'integrated_jumps': 69.0, 'guiding_paths_lits': 3101.0, 'guiding_paths': 7.0, 'splits': 0.0, 'lemmas_conflict': 34.0, 'lemmas_loop': 107.0, 'lemmas_other': 114.0, 'lits_conflict': 1541.0, 'lits_loop': 969.0, 'lits_other': 5402.0, 'jumps': {'jumps': 34.0, 'jumps_bounded': 1.0, 'levels': 60.0, 'levels_bounded': 1.0, 'max': 5.0, 'max_executed': 5.0, 'max_bounded': 1.0}}}}, 'summary': {'call': 20.0, 'result': 1.0, 'signal': 0.0, 'exhausted': 0.0, 'costs': [], 'lower': [], 'concurrency': 8.0, 'winner': 2.0, 'times': {'total': 0.1466999053955078, 'cpu': 0.21875, 'solve': 0.025197982788085938, 'unsat': 0.0, 'sat': 0.00824737548828125}, 'models': {'enumerated': 1.0, 'optimal': 0.0}}, 'accu': {'times': {'total': 2.232778549194336, 'cpu': 3.171875, 'solve': 0.21778488159179688, 'unsat': 0.07399559020996094, 'sat': 0.06304740905761719}, 'models': {'enumerated': 7.0, 'optimal': 0.0}, 'solving': {'solvers': {'choices': 11611.0, 'conflicts': 1385.0, 'conflicts_analyzed': 1292.0, 'restarts': 0.0, 'restarts_last': 96.0, 'extra': {'domain_choices': 0.0, 'models': 7.0, 'models_level': 2735.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 1021.0, 'distributed_sum_lbd': 2773.0, 'integrated': 5294.0, 'lemmas': 9445.0, 'lits_learnt': 124829.0, 'lemmas_binary': 930.0, 'lemmas_ternary': 749.0, 'cpu_time': 1.21875, 'integrated_imps': 1287.0, 'integrated_jumps': 4473.0, 'guiding_paths_lits': 33693.0, 'guiding_paths': 145.0, 'splits': 0.0, 'lemmas_conflict': 1263.0, 'lemmas_loop': 3140.0, 'lemmas_other': 5042.0, 'lits_conflict': 24476.0, 'lits_loop': 25874.0, 'lits_other': 74479.0, 'jumps': {'jumps': 1292.0, 'jumps_bounded': 59.0, 'levels': 7970.0, 'levels_bounded': 5238.0, 'max': 429.0, 'max_executed': 429.0, 'max_bounded': 422.0}}}}}, 'user_step': {}, 'user_accu': {}}))

[15-09-2021_15-49-23] DEBUG :: ASH Planner Main #1 >> Goal at sequence index 6 achieved.

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Queueing external: External(symbol='current_last_sgoals(7, 20)', truth=True, inc_range=None)

[15-09-2021_15-49-23] DEBUG :: ASH Planner Main #1 >> Setting current sub-goal stage to index 7:sub_goal(3, talos, grasp(manipulator_arm_2,(block,3)), grasping(manipulator_arm_2), (block,3), 7)

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [21]:
Running step bounds   | Previous =     20 : Current =     21
Incrementor step ends | Minimum  =   None : Maximum =    100

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(21)]), ('action_effects', [Number(21)]), ('action_preconditions', [Number(21)]), ('variable_relations', [Number(21)]), ('abstraction_mappings', [Number(21)]), ('state_module', [Number(21), Number(0)]), ('plan_module', [Number(21), Number(0), Function('false', [], True), Function('false', [], True)]), ('optimisation_module', [Number(21), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('conformance_module', [Number(21), Number(0), Number(1), Number(20), Function('sequential', [], True), Function('true', [], True)])]

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.097724s.

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Assigning queued external: original = External(symbol='current_last_sgoals(7, 20)', truth=True, inc_range=None), conversion = current_last_sgoals(7,20).

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Model found:
Model :: Total atoms = 10161, Cost = (), Optimality proven = False, Number = 1, Thread ID = 4, Model type = ModelType.StableModel

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.041990s with result Satisfiable.

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [21]:
Result = SolveResult.Satisfiable, Stop condition = None
Increment time = 0.13971399999999967, Incremental time limit = None
Running cumulative time = 2.2754506999999995, Cumulative time limit = 3600
(RSS = 176.000000b, VMS = 168.000000b)

[15-09-2021_15-49-23] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Incremental solving has found a model, current answer:
Result :: SATISFIABLE : SEARCH INTERRUPTED : Total models = 8
IncrementalStatistics :: Cumulative = (Statistics :: Grounding = 1.824903s, Solving = 0.450548s, Total = 2.275451s, Memory = (RSS = 0.000000b, VMS = 0.000000b)), Calls = 21
Final Model :: Total atoms = 10161, Cost = (), Optimality proven = False, Number = 1, Thread ID = 4, Model type = ModelType.StableModel

[15-09-2021_15-49-23] DEBUG :: ASH Planner Main #1 >> Increment feedback: Feedback(increment=21, start_step=21, end_step=22, solve_result=<SolveResult.Satisfiable: 'SAT'>, cumulative_statistics=Statistics(grounding_time=1.8249031999999987, solving_time=0.45054750000000077, total_time=2.2754506999999995, memory=Memory(rss=0.0, vms=0.0), step_range=range(0, 22), clingo_stats={}), increment_statistics=Statistics(grounding_time=0.09772360000000013, solving_time=0.04199039999999954, total_time=0.13971399999999967, memory=Memory(rss=176, vms=168), step_range=range(21, 22), clingo_stats={'problem': {'lp': {'atoms': 49038.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 305373.0, 'bodies_tr': 305373.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 3891.0, 'count_bodies_tr': 3891.0, 'sccs': 352.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 6797.0, 'rules': 616778.0, 'rules_normal': 613319.0, 'rules_choice': 3459.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 616778.0, 'rules_tr_normal': 613319.0, 'rules_tr_choice': 3459.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 105690.0, 'eqs_atom': 22200.0, 'eqs_body': 3958.0, 'eqs_other': 79532.0}, 'lpStep': {'atoms': 2200.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 15113.0, 'bodies_tr': 15113.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 183.0, 'count_bodies_tr': 183.0, 'sccs': 20.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 436.0, 'rules': 31652.0, 'rules_normal': 31496.0, 'rules_choice': 156.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 31652.0, 'rules_tr_normal': 31496.0, 'rules_tr_choice': 156.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 5312.0, 'eqs_atom': 1017.0, 'eqs_body': 64.0, 'eqs_other': 4231.0}, 'generator': {'vars': 25702.0, 'vars_eliminated': 0.0, 'vars_frozen': 17117.0, 'constraints': 6230.0, 'constraints_binary': 238602.0, 'constraints_ternary': 20971.0, 'acyc_edges': 0.0, 'complexity': 266858.0}}, 'solving': {'solvers': {'choices': 1388.0, 'conflicts': 33.0, 'conflicts_analyzed': 33.0, 'restarts': 0.0, 'restarts_last': 28.0, 'extra': {'domain_choices': 0.0, 'models': 1.0, 'models_level': 641.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 33.0, 'distributed_sum_lbd': 97.0, 'integrated': 186.0, 'lemmas': 257.0, 'lits_learnt': 5894.0, 'lemmas_binary': 0.0, 'lemmas_ternary': 5.0, 'cpu_time': 0.078125, 'integrated_imps': 29.0, 'integrated_jumps': 92.0, 'guiding_paths_lits': 3248.0, 'guiding_paths': 7.0, 'splits': 0.0, 'lemmas_conflict': 33.0, 'lemmas_loop': 38.0, 'lemmas_other': 186.0, 'lits_conflict': 819.0, 'lits_loop': 335.0, 'lits_other': 4740.0, 'jumps': {'jumps': 33.0, 'jumps_bounded': 1.0, 'levels': 48.0, 'levels_bounded': 1.0, 'max': 5.0, 'max_executed': 5.0, 'max_bounded': 1.0}}}}, 'summary': {'call': 21.0, 'result': 1.0, 'signal': 0.0, 'exhausted': 0.0, 'costs': [], 'lower': [], 'concurrency': 8.0, 'winner': 4.0, 'times': {'total': 0.1466083526611328, 'cpu': 0.1875, 'solve': 0.02593231201171875, 'unsat': 0.0, 'sat': 0.0109710693359375}, 'models': {'enumerated': 1.0, 'optimal': 0.0}}, 'accu': {'times': {'total': 2.3793869018554688, 'cpu': 3.359375, 'solve': 0.24371719360351562, 'unsat': 0.07399559020996094, 'sat': 0.07401847839355469}, 'models': {'enumerated': 8.0, 'optimal': 0.0}, 'solving': {'solvers': {'choices': 12999.0, 'conflicts': 1418.0, 'conflicts_analyzed': 1325.0, 'restarts': 0.0, 'restarts_last': 96.0, 'extra': {'domain_choices': 0.0, 'models': 8.0, 'models_level': 3376.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 1054.0, 'distributed_sum_lbd': 2870.0, 'integrated': 5480.0, 'lemmas': 9702.0, 'lits_learnt': 130723.0, 'lemmas_binary': 930.0, 'lemmas_ternary': 754.0, 'cpu_time': 1.296875, 'integrated_imps': 1316.0, 'integrated_jumps': 4565.0, 'guiding_paths_lits': 36941.0, 'guiding_paths': 152.0, 'splits': 0.0, 'lemmas_conflict': 1296.0, 'lemmas_loop': 3178.0, 'lemmas_other': 5228.0, 'lits_conflict': 25295.0, 'lits_loop': 26209.0, 'lits_other': 79219.0, 'jumps': {'jumps': 1325.0, 'jumps_bounded': 60.0, 'levels': 8018.0, 'levels_bounded': 5239.0, 'max': 429.0, 'max_executed': 429.0, 'max_bounded': 422.0}}}}}, 'user_step': {}, 'user_accu': {}}))

[15-09-2021_15-49-23] DEBUG :: ASH Planner Main #1 >> Goal at sequence index 7 achieved.

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Queueing external: External(symbol='current_last_sgoals(8, 21)', truth=True, inc_range=None)

[15-09-2021_15-49-24] DEBUG :: ASH Planner Main #1 >> Setting current sub-goal stage to index 8:sub_goal(3, talos, put(manipulator_arm_2,(block,3),puzzle_room_table), on((block,3)), puzzle_room_table, 8)

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [22]:
Running step bounds   | Previous =     21 : Current =     22
Incrementor step ends | Minimum  =   None : Maximum =    100

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(22)]), ('action_effects', [Number(22)]), ('action_preconditions', [Number(22)]), ('variable_relations', [Number(22)]), ('abstraction_mappings', [Number(22)]), ('state_module', [Number(22), Number(0)]), ('plan_module', [Number(22), Number(0), Function('false', [], True), Function('false', [], True)]), ('optimisation_module', [Number(22), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('conformance_module', [Number(22), Number(0), Number(1), Number(20), Function('sequential', [], True), Function('true', [], True)])]

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.101384s.

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Assigning queued external: original = External(symbol='current_last_sgoals(8, 21)', truth=True, inc_range=None), conversion = current_last_sgoals(8,21).

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Model found:
Model :: Total atoms = 10506, Cost = (), Optimality proven = False, Number = 1, Thread ID = 1, Model type = ModelType.StableModel

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.047455s with result Satisfiable.

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [22]:
Result = SolveResult.Satisfiable, Stop condition = None
Increment time = 0.14883860000000126, Incremental time limit = None
Running cumulative time = 2.4242893000000008, Cumulative time limit = 3600
(RSS = 184.000000b, VMS = 182.000000b)

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Incremental solving has found a model, current answer:
Result :: SATISFIABLE : SEARCH INTERRUPTED : Total models = 9
IncrementalStatistics :: Cumulative = (Statistics :: Grounding = 1.926287s, Solving = 0.498002s, Total = 2.424289s, Memory = (RSS = 0.000000b, VMS = 0.000000b)), Calls = 22
Final Model :: Total atoms = 10506, Cost = (), Optimality proven = False, Number = 1, Thread ID = 1, Model type = ModelType.StableModel

[15-09-2021_15-49-24] DEBUG :: ASH Planner Main #1 >> Increment feedback: Feedback(increment=22, start_step=22, end_step=23, solve_result=<SolveResult.Satisfiable: 'SAT'>, cumulative_statistics=Statistics(grounding_time=1.9262869999999994, solving_time=0.49800230000000134, total_time=2.4242893000000008, memory=Memory(rss=0.0, vms=0.0), step_range=range(0, 23), clingo_stats={}), increment_statistics=Statistics(grounding_time=0.10138380000000069, solving_time=0.047454800000000574, total_time=0.14883860000000126, memory=Memory(rss=184, vms=182), step_range=range(22, 23), clingo_stats={'problem': {'lp': {'atoms': 51238.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 320511.0, 'bodies_tr': 320511.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 4074.0, 'count_bodies_tr': 4074.0, 'sccs': 372.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 7233.0, 'rules': 648646.0, 'rules_normal': 645031.0, 'rules_choice': 3615.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 648646.0, 'rules_tr_normal': 645031.0, 'rules_tr_choice': 3615.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 111053.0, 'eqs_atom': 23218.0, 'eqs_body': 4021.0, 'eqs_other': 83814.0}, 'lpStep': {'atoms': 2200.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 15138.0, 'bodies_tr': 15138.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 183.0, 'count_bodies_tr': 183.0, 'sccs': 20.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 436.0, 'rules': 31868.0, 'rules_normal': 31712.0, 'rules_choice': 156.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 31868.0, 'rules_tr_normal': 31712.0, 'rules_tr_choice': 156.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 5363.0, 'eqs_atom': 1018.0, 'eqs_body': 63.0, 'eqs_other': 4282.0}, 'generator': {'vars': 27306.0, 'vars_eliminated': 0.0, 'vars_frozen': 18171.0, 'constraints': 6733.0, 'constraints_binary': 259101.0, 'constraints_ternary': 22759.0, 'acyc_edges': 0.0, 'complexity': 289721.0}}, 'solving': {'solvers': {'choices': 1303.0, 'conflicts': 0.0, 'conflicts_analyzed': 0.0, 'restarts': 0.0, 'restarts_last': 0.0, 'extra': {'domain_choices': 0.0, 'models': 1.0, 'models_level': 668.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 0.0, 'distributed_sum_lbd': 0.0, 'integrated': 0.0, 'lemmas': 18.0, 'lits_learnt': 192.0, 'lemmas_binary': 0.0, 'lemmas_ternary': 0.0, 'cpu_time': 0.15625, 'integrated_imps': 0.0, 'integrated_jumps': 0.0, 'guiding_paths_lits': 3395.0, 'guiding_paths': 7.0, 'splits': 0.0, 'lemmas_conflict': 0.0, 'lemmas_loop': 18.0, 'lemmas_other': 0.0, 'lits_conflict': 0.0, 'lits_loop': 192.0, 'lits_other': 0.0, 'jumps': {'jumps': 0.0, 'jumps_bounded': 0.0, 'levels': 0.0, 'levels_bounded': 0.0, 'max': 0.0, 'max_executed': 0.0, 'max_bounded': 0.0}}}}, 'summary': {'call': 22.0, 'result': 1.0, 'signal': 0.0, 'exhausted': 0.0, 'costs': [], 'lower': [], 'concurrency': 8.0, 'winner': 1.0, 'times': {'total': 0.1545886993408203, 'cpu': 0.28125, 'solve': 0.0299224853515625, 'unsat': 0.0, 'sat': 0.01197052001953125}, 'models': {'enumerated': 1.0, 'optimal': 0.0}}, 'accu': {'times': {'total': 2.533975601196289, 'cpu': 3.640625, 'solve': 0.2736396789550781, 'unsat': 0.07399559020996094, 'sat': 0.08598899841308594}, 'models': {'enumerated': 9.0, 'optimal': 0.0}, 'solving': {'solvers': {'choices': 14302.0, 'conflicts': 1418.0, 'conflicts_analyzed': 1325.0, 'restarts': 0.0, 'restarts_last': 96.0, 'extra': {'domain_choices': 0.0, 'models': 9.0, 'models_level': 4044.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 1054.0, 'distributed_sum_lbd': 2870.0, 'integrated': 5480.0, 'lemmas': 9720.0, 'lits_learnt': 130915.0, 'lemmas_binary': 930.0, 'lemmas_ternary': 754.0, 'cpu_time': 1.453125, 'integrated_imps': 1316.0, 'integrated_jumps': 4565.0, 'guiding_paths_lits': 40336.0, 'guiding_paths': 159.0, 'splits': 0.0, 'lemmas_conflict': 1296.0, 'lemmas_loop': 3196.0, 'lemmas_other': 5228.0, 'lits_conflict': 25295.0, 'lits_loop': 26401.0, 'lits_other': 79219.0, 'jumps': {'jumps': 1325.0, 'jumps_bounded': 60.0, 'levels': 8018.0, 'levels_bounded': 5239.0, 'max': 429.0, 'max_executed': 429.0, 'max_bounded': 422.0}}}}}, 'user_step': {}, 'user_accu': {}}))

[15-09-2021_15-49-24] DEBUG :: ASH Planner Main #1 >> Goal at sequence index 8 achieved.

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Queueing external: External(symbol='current_last_sgoals(9, 22)', truth=True, inc_range=None)

[15-09-2021_15-49-24] DEBUG :: ASH Planner Main #1 >> Setting current sub-goal stage to index 9:sub_goal(3, talos, release(manipulator_arm_2,(block,3)), grasping(manipulator_arm_2), nothing, 9)

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [23]:
Running step bounds   | Previous =     22 : Current =     23
Incrementor step ends | Minimum  =   None : Maximum =    100

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(23)]), ('action_effects', [Number(23)]), ('action_preconditions', [Number(23)]), ('variable_relations', [Number(23)]), ('abstraction_mappings', [Number(23)]), ('state_module', [Number(23), Number(0)]), ('plan_module', [Number(23), Number(0), Function('false', [], True), Function('false', [], True)]), ('optimisation_module', [Number(23), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('conformance_module', [Number(23), Number(0), Number(1), Number(20), Function('sequential', [], True), Function('true', [], True)])]

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.110558s.

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Assigning queued external: original = External(symbol='current_last_sgoals(9, 22)', truth=True, inc_range=None), conversion = current_last_sgoals(9,22).

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Model found:
Model :: Total atoms = 10852, Cost = (), Optimality proven = False, Number = 1, Thread ID = 3, Model type = ModelType.StableModel

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.069653s with result Satisfiable.

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [23]:
Result = SolveResult.Satisfiable, Stop condition = None
Increment time = 0.1802115000000004, Incremental time limit = None
Running cumulative time = 2.604500800000001, Cumulative time limit = 3600
(RSS = 187.000000b, VMS = 185.000000b)

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Incremental solving has found a model, current answer:
Result :: SATISFIABLE : SEARCH INTERRUPTED : Total models = 10
IncrementalStatistics :: Cumulative = (Statistics :: Grounding = 2.036845s, Solving = 0.567655s, Total = 2.604501s, Memory = (RSS = 0.000000b, VMS = 0.000000b)), Calls = 23
Final Model :: Total atoms = 10852, Cost = (), Optimality proven = False, Number = 1, Thread ID = 3, Model type = ModelType.StableModel

[15-09-2021_15-49-24] DEBUG :: ASH Planner Main #1 >> Increment feedback: Feedback(increment=23, start_step=23, end_step=24, solve_result=<SolveResult.Satisfiable: 'SAT'>, cumulative_statistics=Statistics(grounding_time=2.036845499999999, solving_time=0.567655300000002, total_time=2.604500800000001, memory=Memory(rss=0.0, vms=0.0), step_range=range(0, 24), clingo_stats={}), increment_statistics=Statistics(grounding_time=0.11055849999999978, solving_time=0.06965300000000063, total_time=0.1802115000000004, memory=Memory(rss=187, vms=185), step_range=range(23, 24), clingo_stats={'problem': {'lp': {'atoms': 53443.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 335675.0, 'bodies_tr': 335675.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 4257.0, 'count_bodies_tr': 4257.0, 'sccs': 392.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 7669.0, 'rules': 680732.0, 'rules_normal': 676961.0, 'rules_choice': 3771.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 680732.0, 'rules_tr_normal': 676961.0, 'rules_tr_choice': 3771.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 116469.0, 'eqs_atom': 24237.0, 'eqs_body': 4085.0, 'eqs_other': 88147.0}, 'lpStep': {'atoms': 2205.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 15164.0, 'bodies_tr': 15164.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 183.0, 'count_bodies_tr': 183.0, 'sccs': 20.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 436.0, 'rules': 32086.0, 'rules_normal': 31930.0, 'rules_choice': 156.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 32086.0, 'rules_tr_normal': 31930.0, 'rules_tr_choice': 156.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 5416.0, 'eqs_atom': 1019.0, 'eqs_body': 64.0, 'eqs_other': 4333.0}, 'generator': {'vars': 28915.0, 'vars_eliminated': 0.0, 'vars_frozen': 19229.0, 'constraints': 7237.0, 'constraints_binary': 279823.0, 'constraints_ternary': 24545.0, 'acyc_edges': 0.0, 'complexity': 312806.0}}, 'solving': {'solvers': {'choices': 1350.0, 'conflicts': 3.0, 'conflicts_analyzed': 3.0, 'restarts': 0.0, 'restarts_last': 0.0, 'extra': {'domain_choices': 0.0, 'models': 1.0, 'models_level': 697.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 3.0, 'distributed_sum_lbd': 3.0, 'integrated': 0.0, 'lemmas': 71.0, 'lits_learnt': 641.0, 'lemmas_binary': 0.0, 'lemmas_ternary': 0.0, 'cpu_time': 0.203125, 'integrated_imps': 0.0, 'integrated_jumps': 0.0, 'guiding_paths_lits': 3542.0, 'guiding_paths': 7.0, 'splits': 0.0, 'lemmas_conflict': 3.0, 'lemmas_loop': 68.0, 'lemmas_other': 0.0, 'lits_conflict': 3.0, 'lits_loop': 638.0, 'lits_other': 0.0, 'jumps': {'jumps': 3.0, 'jumps_bounded': 0.0, 'levels': 3.0, 'levels_bounded': 0.0, 'max': 1.0, 'max_executed': 1.0, 'max_bounded': 0.0}}}}, 'summary': {'call': 23.0, 'result': 1.0, 'signal': 0.0, 'exhausted': 0.0, 'costs': [], 'lower': [], 'concurrency': 8.0, 'winner': 3.0, 'times': {'total': 0.18721961975097656, 'cpu': 0.328125, 'solve': 0.05286216735839844, 'unsat': 0.0, 'sat': 0.008975982666015625}, 'models': {'enumerated': 1.0, 'optimal': 0.0}}, 'accu': {'times': {'total': 2.7211952209472656, 'cpu': 3.96875, 'solve': 0.32650184631347656, 'unsat': 0.07399559020996094, 'sat': 0.09496498107910156}, 'models': {'enumerated': 10.0, 'optimal': 0.0}, 'solving': {'solvers': {'choices': 15652.0, 'conflicts': 1421.0, 'conflicts_analyzed': 1328.0, 'restarts': 0.0, 'restarts_last': 96.0, 'extra': {'domain_choices': 0.0, 'models': 10.0, 'models_level': 4741.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 1057.0, 'distributed_sum_lbd': 2873.0, 'integrated': 5480.0, 'lemmas': 9791.0, 'lits_learnt': 131556.0, 'lemmas_binary': 930.0, 'lemmas_ternary': 754.0, 'cpu_time': 1.65625, 'integrated_imps': 1316.0, 'integrated_jumps': 4565.0, 'guiding_paths_lits': 43878.0, 'guiding_paths': 166.0, 'splits': 0.0, 'lemmas_conflict': 1299.0, 'lemmas_loop': 3264.0, 'lemmas_other': 5228.0, 'lits_conflict': 25298.0, 'lits_loop': 27039.0, 'lits_other': 79219.0, 'jumps': {'jumps': 1328.0, 'jumps_bounded': 60.0, 'levels': 8021.0, 'levels_bounded': 5239.0, 'max': 429.0, 'max_executed': 429.0, 'max_bounded': 422.0}}}}}, 'user_step': {}, 'user_accu': {}}))

[15-09-2021_15-49-24] DEBUG :: ASH Planner Main #1 >> Goal at sequence index 9 achieved.

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Queueing external: External(symbol='current_last_sgoals(10, 23)', truth=True, inc_range=None)

[15-09-2021_15-49-24] DEBUG :: ASH Planner Main #1 >> Setting current sub-goal stage to index 10:sub_goal(3, talos, put(manipulator_arm_1,(block,2),(block,3)), on((block,2)), (block,3), 10)

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [24]:
Running step bounds   | Previous =     23 : Current =     24
Incrementor step ends | Minimum  =   None : Maximum =    100

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(24)]), ('action_effects', [Number(24)]), ('action_preconditions', [Number(24)]), ('variable_relations', [Number(24)]), ('abstraction_mappings', [Number(24)]), ('state_module', [Number(24), Number(0)]), ('plan_module', [Number(24), Number(0), Function('false', [], True), Function('false', [], True)]), ('optimisation_module', [Number(24), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('conformance_module', [Number(24), Number(0), Number(1), Number(20), Function('sequential', [], True), Function('true', [], True)])]

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.117454s.

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Assigning queued external: original = External(symbol='current_last_sgoals(10, 23)', truth=True, inc_range=None), conversion = current_last_sgoals(10,23).

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Model found:
Model :: Total atoms = 11199, Cost = (), Optimality proven = False, Number = 1, Thread ID = 5, Model type = ModelType.StableModel

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.048417s with result Satisfiable.

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [24]:
Result = SolveResult.Satisfiable, Stop condition = None
Increment time = 0.165871000000001, Incremental time limit = None
Running cumulative time = 2.770371800000002, Cumulative time limit = 3600
(RSS = 232.000000b, VMS = 234.000000b)

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Incremental solving has found a model, current answer:
Result :: SATISFIABLE : SEARCH INTERRUPTED : Total models = 11
IncrementalStatistics :: Cumulative = (Statistics :: Grounding = 2.154299s, Solving = 0.616073s, Total = 2.770372s, Memory = (RSS = 0.000000b, VMS = 0.000000b)), Calls = 24
Final Model :: Total atoms = 11199, Cost = (), Optimality proven = False, Number = 1, Thread ID = 5, Model type = ModelType.StableModel

[15-09-2021_15-49-24] DEBUG :: ASH Planner Main #1 >> Increment feedback: Feedback(increment=24, start_step=24, end_step=25, solve_result=<SolveResult.Satisfiable: 'SAT'>, cumulative_statistics=Statistics(grounding_time=2.1542990999999985, solving_time=0.6160727000000037, total_time=2.770371800000002, memory=Memory(rss=0.0, vms=0.0), step_range=range(0, 25), clingo_stats={}), increment_statistics=Statistics(grounding_time=0.11745359999999927, solving_time=0.04841740000000172, total_time=0.165871000000001, memory=Memory(rss=232, vms=234), step_range=range(24, 25), clingo_stats={'problem': {'lp': {'atoms': 55653.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 350865.0, 'bodies_tr': 350865.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 4440.0, 'count_bodies_tr': 4440.0, 'sccs': 412.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 8105.0, 'rules': 713036.0, 'rules_normal': 709109.0, 'rules_choice': 3927.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 713036.0, 'rules_tr_normal': 709109.0, 'rules_tr_choice': 3927.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 121936.0, 'eqs_atom': 25257.0, 'eqs_body': 4148.0, 'eqs_other': 92531.0}, 'lpStep': {'atoms': 2210.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 15190.0, 'bodies_tr': 15190.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 183.0, 'count_bodies_tr': 183.0, 'sccs': 20.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 436.0, 'rules': 32304.0, 'rules_normal': 32148.0, 'rules_choice': 156.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 32304.0, 'rules_tr_normal': 32148.0, 'rules_tr_choice': 156.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 5467.0, 'eqs_atom': 1020.0, 'eqs_body': 63.0, 'eqs_other': 4384.0}, 'generator': {'vars': 30529.0, 'vars_eliminated': 0.0, 'vars_frozen': 20291.0, 'constraints': 7738.0, 'constraints_binary': 300743.0, 'constraints_ternary': 26296.0, 'acyc_edges': 0.0, 'complexity': 336049.0}}, 'solving': {'solvers': {'choices': 1407.0, 'conflicts': 0.0, 'conflicts_analyzed': 0.0, 'restarts': 0.0, 'restarts_last': 0.0, 'extra': {'domain_choices': 0.0, 'models': 1.0, 'models_level': 740.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 0.0, 'distributed_sum_lbd': 0.0, 'integrated': 0.0, 'lemmas': 8.0, 'lits_learnt': 78.0, 'lemmas_binary': 0.0, 'lemmas_ternary': 0.0, 'cpu_time': 0.046875, 'integrated_imps': 0.0, 'integrated_jumps': 0.0, 'guiding_paths_lits': 3689.0, 'guiding_paths': 7.0, 'splits': 0.0, 'lemmas_conflict': 0.0, 'lemmas_loop': 8.0, 'lemmas_other': 0.0, 'lits_conflict': 0.0, 'lits_loop': 78.0, 'lits_other': 0.0, 'jumps': {'jumps': 0.0, 'jumps_bounded': 0.0, 'levels': 0.0, 'levels_bounded': 0.0, 'max': 0.0, 'max_executed': 0.0, 'max_bounded': 0.0}}}}, 'summary': {'call': 24.0, 'result': 1.0, 'signal': 0.0, 'exhausted': 0.0, 'costs': [], 'lower': [], 'concurrency': 8.0, 'winner': 5.0, 'times': {'total': 0.17253875732421875, 'cpu': 0.359375, 'solve': 0.029893875122070312, 'unsat': 0.0, 'sat': 0.009946823120117188}, 'models': {'enumerated': 1.0, 'optimal': 0.0}}, 'accu': {'times': {'total': 2.8937339782714844, 'cpu': 4.328125, 'solve': 0.3563957214355469, 'unsat': 0.07399559020996094, 'sat': 0.10491180419921875}, 'models': {'enumerated': 11.0, 'optimal': 0.0}, 'solving': {'solvers': {'choices': 17059.0, 'conflicts': 1421.0, 'conflicts_analyzed': 1328.0, 'restarts': 0.0, 'restarts_last': 96.0, 'extra': {'domain_choices': 0.0, 'models': 11.0, 'models_level': 5481.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 1057.0, 'distributed_sum_lbd': 2873.0, 'integrated': 5480.0, 'lemmas': 9799.0, 'lits_learnt': 131634.0, 'lemmas_binary': 930.0, 'lemmas_ternary': 754.0, 'cpu_time': 1.703125, 'integrated_imps': 1316.0, 'integrated_jumps': 4565.0, 'guiding_paths_lits': 47567.0, 'guiding_paths': 173.0, 'splits': 0.0, 'lemmas_conflict': 1299.0, 'lemmas_loop': 3272.0, 'lemmas_other': 5228.0, 'lits_conflict': 25298.0, 'lits_loop': 27117.0, 'lits_other': 79219.0, 'jumps': {'jumps': 1328.0, 'jumps_bounded': 60.0, 'levels': 8021.0, 'levels_bounded': 5239.0, 'max': 429.0, 'max_executed': 429.0, 'max_bounded': 422.0}}}}}, 'user_step': {}, 'user_accu': {}}))

[15-09-2021_15-49-24] DEBUG :: ASH Planner Main #1 >> Goal at sequence index 10 achieved.

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Queueing external: External(symbol='current_last_sgoals(11, 24)', truth=True, inc_range=None)

[15-09-2021_15-49-24] DEBUG :: ASH Planner Main #1 >> Setting current sub-goal stage to index 11:sub_goal(3, talos, release(manipulator_arm_1,(block,2)), grasping(manipulator_arm_1), nothing, 11)

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [25]:
Running step bounds   | Previous =     24 : Current =     25
Incrementor step ends | Minimum  =   None : Maximum =    100

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(25)]), ('action_effects', [Number(25)]), ('action_preconditions', [Number(25)]), ('variable_relations', [Number(25)]), ('abstraction_mappings', [Number(25)]), ('state_module', [Number(25), Number(0)]), ('plan_module', [Number(25), Number(0), Function('false', [], True), Function('false', [], True)]), ('optimisation_module', [Number(25), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('conformance_module', [Number(25), Number(0), Number(1), Number(20), Function('sequential', [], True), Function('true', [], True)])]

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.116369s.

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Assigning queued external: original = External(symbol='current_last_sgoals(11, 24)', truth=True, inc_range=None), conversion = current_last_sgoals(11,24).

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Model found:
Model :: Total atoms = 11547, Cost = (), Optimality proven = False, Number = 1, Thread ID = 0, Model type = ModelType.StableModel

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.050714s with result Satisfiable.

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [25]:
Result = SolveResult.Satisfiable, Stop condition = None
Increment time = 0.16708369999999917, Incremental time limit = None
Running cumulative time = 2.9374555000000013, Cumulative time limit = 3600
(RSS = 265.000000b, VMS = 269.000000b)

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Incremental solving has found a model, current answer:
Result :: SATISFIABLE : SEARCH INTERRUPTED : Total models = 12
IncrementalStatistics :: Cumulative = (Statistics :: Grounding = 2.270668s, Solving = 0.666787s, Total = 2.937456s, Memory = (RSS = 0.000000b, VMS = 0.000000b)), Calls = 25
Final Model :: Total atoms = 11547, Cost = (), Optimality proven = False, Number = 1, Thread ID = 0, Model type = ModelType.StableModel

[15-09-2021_15-49-24] DEBUG :: ASH Planner Main #1 >> Increment feedback: Feedback(increment=25, start_step=25, end_step=26, solve_result=<SolveResult.Satisfiable: 'SAT'>, cumulative_statistics=Statistics(grounding_time=2.2706684999999984, solving_time=0.6667870000000029, total_time=2.9374555000000013, memory=Memory(rss=0.0, vms=0.0), step_range=range(0, 26), clingo_stats={}), increment_statistics=Statistics(grounding_time=0.11636939999999996, solving_time=0.05071429999999921, total_time=0.16708369999999917, memory=Memory(rss=265, vms=269), step_range=range(25, 26), clingo_stats={'problem': {'lp': {'atoms': 57868.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 366081.0, 'bodies_tr': 366081.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 4623.0, 'count_bodies_tr': 4623.0, 'sccs': 432.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 8541.0, 'rules': 745558.0, 'rules_normal': 741475.0, 'rules_choice': 4083.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 745558.0, 'rules_tr_normal': 741475.0, 'rules_tr_choice': 4083.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 127456.0, 'eqs_atom': 26278.0, 'eqs_body': 4212.0, 'eqs_other': 96966.0}, 'lpStep': {'atoms': 2215.0, 'atoms_aux': 0.0, 'disjunctions': 0.0, 'disjunctions_non_hcf': 0.0, 'bodies': 15216.0, 'bodies_tr': 15216.0, 'sum_bodies': 0.0, 'sum_bodies_tr': 0.0, 'count_bodies': 183.0, 'count_bodies_tr': 183.0, 'sccs': 20.0, 'sccs_non_hcf': 0.0, 'gammas': 0.0, 'ufs_nodes': 436.0, 'rules': 32522.0, 'rules_normal': 32366.0, 'rules_choice': 156.0, 'rules_minimize': 0.0, 'rules_acyc': 0.0, 'rules_heuristic': 0.0, 'rules_tr': 32522.0, 'rules_tr_normal': 32366.0, 'rules_tr_choice': 156.0, 'rules_tr_minimize': 0.0, 'rules_tr_acyc': 0.0, 'rules_tr_heuristic': 0.0, 'eqs': 5520.0, 'eqs_atom': 1021.0, 'eqs_body': 64.0, 'eqs_other': 4435.0}, 'generator': {'vars': 32148.0, 'vars_eliminated': 0.0, 'vars_frozen': 21357.0, 'constraints': 8244.0, 'constraints_binary': 321911.0, 'constraints_ternary': 28102.0, 'acyc_edges': 0.0, 'complexity': 359602.0}}, 'solving': {'solvers': {'choices': 1461.0, 'conflicts': 0.0, 'conflicts_analyzed': 0.0, 'restarts': 0.0, 'restarts_last': 0.0, 'extra': {'domain_choices': 0.0, 'models': 1.0, 'models_level': 751.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 0.0, 'distributed_sum_lbd': 0.0, 'integrated': 0.0, 'lemmas': 21.0, 'lits_learnt': 105.0, 'lemmas_binary': 0.0, 'lemmas_ternary': 0.0, 'cpu_time': 0.09375, 'integrated_imps': 0.0, 'integrated_jumps': 0.0, 'guiding_paths_lits': 3836.0, 'guiding_paths': 7.0, 'splits': 0.0, 'lemmas_conflict': 0.0, 'lemmas_loop': 21.0, 'lemmas_other': 0.0, 'lits_conflict': 0.0, 'lits_loop': 105.0, 'lits_other': 0.0, 'jumps': {'jumps': 0.0, 'jumps_bounded': 0.0, 'levels': 0.0, 'levels_bounded': 0.0, 'max': 0.0, 'max_executed': 0.0, 'max_bounded': 0.0}}}}, 'summary': {'call': 25.0, 'result': 1.0, 'signal': 0.0, 'exhausted': 0.0, 'costs': [], 'lower': [], 'concurrency': 8.0, 'winner': 0.0, 'times': {'total': 0.17404556274414062, 'cpu': 0.40625, 'solve': 0.0294342041015625, 'unsat': 0.0, 'sat': 0.009975433349609375}, 'models': {'enumerated': 1.0, 'optimal': 0.0}}, 'accu': {'times': {'total': 3.067779541015625, 'cpu': 4.734375, 'solve': 0.3858299255371094, 'unsat': 0.07399559020996094, 'sat': 0.11488723754882812}, 'models': {'enumerated': 12.0, 'optimal': 0.0}, 'solving': {'solvers': {'choices': 18520.0, 'conflicts': 1421.0, 'conflicts_analyzed': 1328.0, 'restarts': 0.0, 'restarts_last': 96.0, 'extra': {'domain_choices': 0.0, 'models': 12.0, 'models_level': 6232.0, 'hcc_tests': 0.0, 'hcc_partial': 0.0, 'lemmas_deleted': 0.0, 'distributed': 1057.0, 'distributed_sum_lbd': 2873.0, 'integrated': 5480.0, 'lemmas': 9820.0, 'lits_learnt': 131739.0, 'lemmas_binary': 930.0, 'lemmas_ternary': 754.0, 'cpu_time': 1.796875, 'integrated_imps': 1316.0, 'integrated_jumps': 4565.0, 'guiding_paths_lits': 51403.0, 'guiding_paths': 180.0, 'splits': 0.0, 'lemmas_conflict': 1299.0, 'lemmas_loop': 3293.0, 'lemmas_other': 5228.0, 'lits_conflict': 25298.0, 'lits_loop': 27222.0, 'lits_other': 79219.0, 'jumps': {'jumps': 1328.0, 'jumps_bounded': 60.0, 'levels': 8021.0, 'levels_bounded': 5239.0, 'max': 429.0, 'max_executed': 429.0, 'max_bounded': 422.0}}}}}, 'user_step': {}, 'user_accu': {}}))

[15-09-2021_15-49-24] DEBUG :: ASH Planner Main #1 >> Goal at sequence index 11 achieved.

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Queueing external: External(symbol='current_last_sgoals(12, 25)', truth=True, inc_range=None)

[15-09-2021_15-49-24] DEBUG :: ASH Planner Main #1 >> Setting current sub-goal stage to index 12:sub_goal(3, talos, move(store_room), in(talos), store_room, 12)

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [26]:
Running step bounds   | Previous =     25 : Current =     26
Incrementor step ends | Minimum  =   None : Maximum =    100

[15-09-2021_15-49-24] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(26)]), ('action_effects', [Number(26)]), ('action_preconditions', [Number(26)]), ('variable_relations', [Number(26)]), ('abstraction_mappings', [Number(26)]), ('state_module', [Number(26), Number(0)]), ('plan_module', [Number(26), Number(0), Function('false', [], True), Function('false', [], True)]), ('optimisation_module', [Number(26), Number(0), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('conformance_module', [Number(26), Number(0), Number(1), Number(20), Function('sequential', [], True), Function('true', [], True)])]

