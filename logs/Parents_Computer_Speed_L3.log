[09-09-2021_16-35-06] DEBUG :: __main__ >> 
  ####################################################################################################################  
                                                                                                                        
                                                ░█████╗░░██████╗██╗░░██╗                                                
                                                ██╔══██╗██╔════╝██║░░██║                                                
                                                ███████║╚█████╗░███████║                                                
                                                ██╔══██║░╚═══██╗██╔══██║                                                
                                                ██║░░██║██████╔╝██║░░██║                                                
                                                ╚═╝░░╚═╝╚═════╝░╚═╝░░╚═╝                                                
                                                                                                                        
                        =======================================================================                         
                            ASH - The ASP based Hierarchical Conformance Refinement Planner                             
                                      Copyright (C)  2021  Oliver Michael Kamperis                                      
                        =======================================================================                         
                                                                                                                        
          This program comes with ABSOLUTELY NO WARRANTY; for details use `--warranty'. This is free software,          
            and you are welcome to redistribute it under certain conditions; use `--conditions' for details.            
                    For help and usage instructions use `--help' and `--instructions' respectively.                     
                                                                                                                        
  ####################################################################################################################  

[09-09-2021_16-35-06] DEBUG :: __main__ >> 
                    ================================================================================                    
                                                                                                                        
                            THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY                            
                         APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT                         
                       HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY                        
                        OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,                        
                         THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR                         
                       PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM                       
                        IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF                        
                                     ALL NECESSARY SERVICING, REPAIR OR CORRECTION.                                     
                                                                                                                        
                    ================================================================================                    

[09-09-2021_16-35-06] DEBUG :: __main__ >> 
                    ================================================================================                    
                                                                                                                        
                            ASH - The ASP based Hierarchical Conformance Refinement Planner                             
                                      Copyright (C)  2021  Oliver Michael Kamperis                                      
                                             Email: o.m.kamperis@gmail.com                                              
                                                                                                                        
                          This program is free software: you can redistribute it and/or modify                          
                          it under the terms of the GNU General Public License as published by                          
                           the Free Software Foundation, either version 3 of the License, or                            
                                                   any later version.                                                   
                                                                                                                        
                            This program is distributed in the hope that it will be useful,                             
                             but WITHOUT ANY WARRANTY; without even the implied warranty of                             
                              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the                              
                                      GNU General Public License for more details.                                      
                                                                                                                        
                           You should have received a copy of the GNU General Public License                            
                         along with this program. If not, see <https://www.gnu.org/licenses/>.                          
                                                                                                                        
                    ================================================================================                    

[09-09-2021_16-35-06] DEBUG :: __main__ >> Command line arguments:
'./test_problems/blocks_world_plus/BWP_system_laws.lp'
'./test_problems/blocks_world_plus/BWP_problem_small_3.lp'
'-op'
'standard'
'-conc'
'False'
'-m'
'hcr'
'-yield'
'False'
'-strat'
'basic'
'-bound'
'2'
'-ll'
'100'
'--pause_on_level_change=True'
'--pause_on_increment_change=False'

[09-09-2021_16-35-06] DEBUG :: __main__ >> Parsed command line argumenys:
('files', ['./test_problems/blocks_world_plus/BWP_system_laws.lp', './test_problems/blocks_world_plus/BWP_problem_small_3.lp'])
('display_loader', None)
('domain_rules', None)
('domain_structure', None)
('problem_specifics', None)
('plan_file', './solutions/plans/ASH_Plan_09-09-2021_16-35-06.txt')
('log_file', './logs/ASH_Log_09-09-2021_16-35-06.log')
('excel_file', None)
('data_file', None)
('data_sep', ' ')
('data_end', '\n')
('warranty', False)
('conditions', False)
('instructions', False)
('ash_output', 'simple')
('clingo_output', False)
('console_logging', 'INFO')
('disable_logging', False)
('display_graph', True)
('operation', 'standard')
('experimental_runs', 1)
('initial_runs', 0)
('pause_on_run_completion', False)
('threads', 6)
('planning_time_limit', 3600)
('search_length_limit', 100)
('planning_mode', 'hcr')
('conformance_type', 'sequential')
('top_level', None)
('bottom_level', 1)
('enable_concurrency', False)
('sequential_yielding', False)
('detect_interleaving', False)
('minimum_search_length_bound', None)
('disable_pause_on_start', False)
('pause_on_level_change', True)
('pause_on_increment_change', False)
('minimise_length', None)
('minimise_actions', None)
('minimise_cost', None)
('online_method', 'ground-first')
('division_strategy', 'basic')
('division_strategy_bounds', 2)
('left_blend_quantities', 0)
('right_blend_quantities', 0)
('treat_tasks_as_independent', True)
('save_grounding', False)
('positive_final_goal_preemptive_achievement_heuristic', None)
('negative_final_goal_preemptive_achievement_heuristic', None)
('final_goal_intermediate_achievement_ordering_preferences', None)
('detect_dependencies', False)
('search_space_length', None)
('search_space_type', 'step_wise')
('search_space_level', 1)
('make_schema', None)
('load_schema', None)
('generate_solution_space', False)
('solution_space_type', None)

[09-09-2021_16-35-07] DEBUG :: core.Planner >> Instantiating new planning domain:
Name = None
Domain files = [./test_problems/blocks_world_plus/BWP_system_laws.lp
                ./test_problems/blocks_world_plus/BWP_problem_small_3.lp]

[09-09-2021_16-35-07] DEBUG :: core.Planner >> The domain files ['./test_problems/blocks_world_plus/BWP_system_laws.lp', './test_problems/blocks_world_plus/BWP_problem_small_3.lp'] were loaded successfully, contain all required program parts, and contain optional program parts: {'initial_state': True, 'static_state': True, 'entities': True, 'goal_state': True}.

[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Instantiating logic program...

[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Setting input storing variables:
	solver_options = []
	assumptions = []
	context = None
	incrementor = None
	base_parts = []
	inc_parts = []

[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Output storing variables reset.

[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Logic program instantiated.

[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Entering new one-shot solve call:
('self', LogicProgram(#program base.
#program abstraction_levels(planning_level, mode).
al((1..abstraction_max)).
pl(AL) :- AL = planning_level; al(AL).
sl(AL) :- AL = planning_level; mode = classical; al(AL).
sl(AL) :- AL >= planning_level; AL <= (planning_level+1); mode = refinement; al(AL).
sl(AL) :- AL >= planning_level; AL <= abstraction_max; mode = hierarchical; al(AL).
#program instance_module.
boolean(true;false).
insta_of(AL,CLS,EN) :- entity(CLS,EN); class(AL,CLS); al(AL).
insta_of(AL_3,CLS_1,EN) :- insta_of(AL_2,CLS_2,EN); super_class(CLS_1,CLS_2); entity(CLS_3,EN); class(AL_3,CLS_3); class(AL_1,CLS_1); AL_1 >= AL_2; al(AL_1); al(AL_2); al(AL_3).
insta_of((AL-1),CLS,EN) :- insta_of(AL,CLS,EN); not overridden((AL-1),CLS,EN); class(_,CLS); al(AL); al((AL-1)).
overridden((AL-1),CLS,EN_1) :- overridden_by((AL-1),CLS,EN_1,EN_2); insta_of(AL,CLS,EN_1); insta_of((AL-1),CLS,EN_2); class(_,CLS); al(AL); al((AL-1)).
overridden_by((AL-1),CLS_3,EN_1,EN_2) :- insta_of(AL,CLS_1,EN_1); insta_of((AL-1),CLS_2,EN_2); insta_of(AL,CLS_3,EN_1); insta_of((AL-1),CLS_3,EN_2); desce_of((AL-1),EN_1,EN_2); override_class(CLS_1,CLS_2,CLS_3); class(_,CLS_1); class(_,CLS_2); class(_,CLS_3); al(AL); al((AL-1)).
state_of(AL,EN,S) :- state(AL,CLS,S); insta_of(AL,CLS,EN); al(AL).
child_of(AL,EN,DESCE) :- ancestry_relation(EN,DESCE); insta_of(AL,_,EN); insta_of(AL,_,DESCE); al(AL).
desce_of(AL,EN,DESCE) :- child_of(AL,EN,DESCE); insta_of(AL,_,EN); insta_of(AL,_,DESCE); al(AL).
desce_of(AL,EN,DESCE_1) :- desce_of(AL,DESCE_2,DESCE_1); desce_of(AL,EN,DESCE_2); insta_of(AL,_,EN); insta_of(AL,_,DESCE_1); insta_of(AL,_,DESCE_2); al(AL).
has_desce(AL,EN) :- desce_of(AL,EN,DESCE); insta_of(AL,_,EN); insta_of(AL,_,DESCE); al(AL).
has_desce(AL,EN,CLS) :- desce_of(AL,EN,DESCE); insta_of(AL,_,EN); insta_of(AL,CLS,DESCE); al(AL).
siblings(AL,DESCE_1,DESCE_2) :- child_of(AL,EN,DESCE_1); child_of(AL,EN,DESCE_2); DESCE_1 != DESCE_2; insta_of(AL,_,EN); insta_of(AL,_,DESCE_1); insta_of(AL,_,DESCE_2); al(AL).
siblings(AL,DESCE_2,DESCE_1) :- siblings(AL,DESCE_1,DESCE_2); insta_of(AL,_,DESCE_1); insta_of(AL,_,DESCE_2); al(AL).
#program state_module(step, start).
{ holds(AL,F,V,step) } :- fluent(AL,inertial,F,V); sl(AL); step = start.
#false :- not 1 = { holds(AL,F,V,step): fluent(AL,_,F,V) }; fluent(AL,_,F,_); sl(AL).
holds(AL,F,V,step) :- holds(AL,F,V,(step-1)); not not holds(AL,F,V,step); fluent(AL,inertial,F,V); sl(AL); step > start.
holds(AL,F,false,step) :- not holds(AL,F,true,step); fluent(AL,defined,F,B); boolean(B); sl(AL).
#program plan_module(step, start, concurrency, achieve_fgoals).
{ occurs(AL,ROBOT,A,step): action(AL,_,ROBOT,A) } :- incomplete_plan((step-1)); pl(AL); step > start.
occurs(AL,ROBOT,step) :- occurs(AL,ROBOT,A,step); action(AL,_,ROBOT,A); pl(AL); step > start.
occurs(AL,step) :- occurs(AL,ROBOT,step); insta_of(AL,robot,ROBOT); pl(AL); step > start.
holds(AL,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V,step); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
holds(AL,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,true,step); not holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,true); not holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,false,step); holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,false); holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- not 1 = { occurs(AL,R,A,step): action(AL,_,ROBOT,A) }; incomplete_plan((step-1)); pl(AL); step > start; concurrency = false.
#false :- not 1 <= { occurs(AL,R,A,step): action(AL,_,ROBOT,A), A != do_nothing }; incomplete_plan((step-1)); pl(AL); step > start; concurrency = true.
#false :- not occurs(AL,ROBOT,(step-1)); occurs(AL,ROBOT,step); insta_of(AL,robot,ROBOT); incomplete_plan((step-1)); pl(AL); step > (start+1); concurrency = true.
has_affect(AL,ROBOT,A,step) :- effect(AL,ROBOT,A,F,V,step); not holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
has_affect(AL,ROBOT,A,step) :- effect(AL,ROBOT,A,F,V); not holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); not has_affect(AL,ROBOT,A,step); action(AL,_,ROBOT,A); A != do_nothing; pl(AL); step > start.
action(AL,sequential,ROBOT,do_nothing) :- insta_of(AL,robot,ROBOT); sl(AL); concurrency = true.
#false :- occurs(AL,ROBOT,A_1,step); occurs(AL,ROBOT,A_2,step); A_1 != A_2; action(AL,_,ROBOT,A_1); action(AL,_,ROBOT,A_2); pl(AL); step > start; concurrency = false.
#false :- occurs(AL,ROBOT,A_1,step); occurs(AL,ROBOT,A_2,step); A_1 != A_2; action(AL,sequential,ROBOT,A_1); action(AL,_,ROBOT,A_2); pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); effect(AL,ROBOT_2,A_2,F,V_2,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; ROBOT_1 != ROBOT_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); effect(AL,ROBOT_2,A_2,F,V_2); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; ROBOT_1 != ROBOT_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1); effect(AL,ROBOT_2,A_2,F,V_2); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; ROBOT_1 != ROBOT_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); precond(AL,ROBOT_2,A_2,F,V_2,true,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); precond(AL,ROBOT_2,A_2,F,V_2,true); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V,step); precond(AL,ROBOT_2,A_2,F,V,false,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V,step); precond(AL,ROBOT_2,A_2,F,V,false); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1); precond(AL,ROBOT_2,A_2,F,V_2,true,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1); precond(AL,ROBOT_2,A_2,F,V_2,true); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V); precond(AL,ROBOT_2,A_2,F,V,false,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V); precond(AL,ROBOT_2,A_2,F,V,false); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#external seq_achieve_fgoals(step). [false]
enforce_achieve_fgoals(step) :- achieve_fgoals = true.
enforce_achieve_fgoals(step) :- 0 <= S; S <= step; seq_achieve_fgoals(S).
goal_satisfied(AL,F,V,true,step) :- final_goal(AL,F,V,true); holds(AL,F,V,step); fluent(AL,_,F,V); pl(AL); enforce_achieve_fgoals(step).
goal_satisfied(AL,F,V,false,step) :- final_goal(AL,F,V,false); not holds(AL,F,V,step); fluent(AL,_,F,V); pl(AL); enforce_achieve_fgoals(step).
incomplete_plan(step) :- final_goal(AL,F,V,B); not goal_satisfied(AL,F,V,B,step); fluent(AL,_,F,V); pl(AL); boolean(B); enforce_achieve_fgoals(step).
sub_goal(AL,ROBOT,A,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V,step); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); AL != 1; step > start.
sub_goal(AL,ROBOT,A,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); AL != 1; step > start.
#program optimisation_module(step, start, minimise_length, minimise_actions, minimise_cost, preempt_pos_fgoals, preempt_neg_fgoals, order_fgoals_achievement).
:~ occurs(AL,step); incomplete_plan((step-1)); pl(AL); step > start; minimise_length = true. [1@3,step]
:~ occurs(AL,ROBOT,A,step); action(AL,_,ROBOT,A); incomplete_plan((step-1)); pl(AL); step > start; minimise_actions = true. [1@2,ROBOT,A,step]
#heuristic occurs(AL,ROBOT,A,step) : action(AL,_,ROBOT,A); effect(AL,ROBOT,A,F,V); fluent(AL,inertial,F,V); final_goal(AL,F,V,true); pl(AL); step > start; preempt_pos_fgoals = true. [10@1,true]
#heuristic occurs(AL,ROBOT,A,step) : action(AL,_,ROBOT,A); effect(AL,ROBOT,A,F,V); fluent(AL,inertial,F,V); final_goal(AL,F,V,false); pl(AL); step > start; preempt_neg_fgoals = true. [10@0,false]
#program check(step).
#external query(step). [false]
#false :- incomplete_plan(step); query(step).
#program conformance_module(step, start, first, last, type, yield).
#external current_last_sgoals(I,step) : sgoals_index(I); yield = true. [false]
include_sgoals(I,step) :- I <= I_L; S <= step; current_last_sgoals(I_L,S); sgoals_index(I).
include_sgoals(I,step) :- sgoals_index(I); yield = false.
sgoals_index((first..last)).
current_sub_goal((AL+1),ROBOT,A,F,V,first,start) :- sub_goal((AL+1),ROBOT,A,F,V,first); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
sub_goal_satisfied((AL+1),ROBOT,A,F,V,I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,(step-1)); holds((AL+1),F,V,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,(step-1)); not sub_goal_satisfied((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); type = sequential; pl(AL).
unachieved_sgoals((AL+1),I_SG,step) :- current_sub_goal_index((AL+1),I_SG,(step-1)); sub_goal((AL+1),ROBOT,A,F,V,I_SG); not sub_goal_satisfied((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,(step-1)); unachieved_sgoals((AL+1),I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); type = simultaneous; pl(AL).
current_sub_goal((AL+1),ROBOT_1,A_1,F_1,V_1,(I_SG+1),step) :- include_sgoals((I_SG+1),step); sub_goal((AL+1),ROBOT_1,A_1,F_1,V_1,(I_SG+1)); current_sub_goal_index((AL+1),I_SG,(step-1)); not current_sub_goal_index((AL+1),I_SG,step); action((AL+1),_,ROBOT_1,A_1); fluent((AL+1),inertial,F_1,V_1); pl(AL).
sgoals_ach_at((AL+1),I_SG,step) :- current_sub_goal_index((AL+1),I_SG,(step-1)); not current_sub_goal_index((AL+1),I_SG,step); pl(AL).
current_sub_goal_index((AL+1),I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
incomplete_plan(step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
#program goal_abstraction_module.
holds(AL,F,V,0) :- final_goal(AL,F,V,true); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
not holds(AL,F,V,0) :- final_goal(AL,F,V,false); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
final_goal(AL,F,V,true) :- holds(AL,F,V,0); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
final_goal(AL,F,V,false) :- not holds(AL,F,V,0); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
{ holds(AL,F,V,0) } :- goal_fluent(AL,F); fluent(AL,inertial,F,V); al(AL).
#false :- not 1 = { holds(AL,F,V,0): fluent(AL,_,F,V) }; goal_fluent(AL,F); fluent(AL,_,F,_); al(AL).
holds(AL,F,false,0) :- not holds(AL,F,true,0); goal_fluent(AL,F); fluent(AL,defined,F,B); boolean(B); al(AL).
#program domain_sorts.
#const abstraction_max = 3.
#const reduc = 3.
#const conde = 2.
#const groun = 1.
class(3,robot).
class(3,armed_robot).
class(3,location).
class(3,room).
class(3,object).
class(3,grounded).
class(3,graspable).
class(3,placeable).
class(3,block).
class(3,surface).
class(3,table).
class(3,colour).
class(3,manipulator_arm).
class(3,grasper).
class(2,door).
class(2,handle).
class(2,configurable).
class(2,extensible).
class(1,cell).
class(1,manipulator_limb).
class(1,manipulator_end).
class(1,side).
super_class(robot,armed_robot).
super_class(location,room).
super_class(location,cell).
super_class(object,robot).
super_class(object,manipulator_arm).
super_class(object,manipulator_limb).
super_class(object,manipulator_end).
super_class(object,table).
super_class(object,side).
super_class(object,block).
super_class(object,grounded).
super_class(grounded,handle).
super_class(configurable,extensible).
super_class(configurable,grasper).
super_class(configurable,door).
super_class(extensible,manipulator_arm).
super_class(extensible,manipulator_limb).
super_class(grasper,manipulator_arm).
super_class(grasper,manipulator_end).
super_class(graspable,block).
super_class(graspable,handle).
super_class(placeable,block).
super_class(surface,table).
super_class(surface,side).
super_class(surface,block).
override_class(manipulator_arm,manipulator_end,grasper).
override_class(manipulator_arm,manipulator_limb,extensible).
override_class(room,cell,location).
override_class(table,side,surface).
state(AL,extensible,extended) :- AL < reduc; al(AL).
state(AL,extensible,retracted) :- AL < reduc; al(AL).
state(AL,manipulator_end,aligned_with(OBJ)) :- insta_of(AL,graspable,OBJ); class(AL,manipulator_end); AL < reduc; al(AL).
state(AL,manipulator_end,aligned_with(nothing)) :- AL < reduc; al(AL).
state(AL,door,open) :- AL < reduc; al(AL).
state(AL,door,closed) :- AL < reduc; al(AL).
static(AL,connected(L_1,L_2)) :- insta_of(AL,location,L_1); insta_of(AL,location,L_2); al(AL).
static(AL,connected_by_door(D,L_1,L_2)) :- insta_of(AL,door,D); insta_of(AL,location,L_1); insta_of(AL,location,L_2); AL < reduc; al(AL).
static(AL,in(OBJ,L)) :- insta_of(AL,object,OBJ); insta_of(AL,grounded,OBJ); insta_of(AL,location,L); AL < reduc; al(AL).
static(AL,colour_of(BLOCK,COLOUR)) :- insta_of(AL,block,BLOCK); insta_of(AL,colour,COLOUR); al(AL).
fluent(AL_1,inertial,in(OBJ),L) :- insta_of(AL_1,location,L); insta_of(AL_2,object,OBJ); OBJ != nothing; not insta_of(AL_2,grounded,OBJ); sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,on(OBJ),SURFACE) :- OBJ != SURFACE; insta_of(AL_1,surface,SURFACE); insta_of(AL_2,placeable,OBJ); sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,grasping(DESC),OBJ) :- insta_of(AL_1,graspable,OBJ); insta_of(AL_2,grasper,DESC); sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,configuration(DESC),STATE) :- state_of(AL_1,DESC,STATE); insta_of(AL_2,configurable,DESC); AL_1 < reduc; AL_2 < reduc; sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,configuration(D),STATE) :- state_of(AL_1,D,STATE); insta_of(AL_2,door,D); AL_1 < reduc; AL_2 < reduc; sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL,defined,tower_base(BASE),B) :- insta_of(AL,block,BASE); sl(AL); boolean(B).
fluent(AL,defined,in_tower(BASE,BLOCK),B) :- insta_of(AL,block,BASE); insta_of(AL,block,BLOCK); sl(AL); boolean(B).
fluent(AL,defined,unordered_tower(BASE),B) :- insta_of(AL,block,BASE); sl(AL); boolean(B).
fluent(AL,defined,complete(COLOUR),B) :- insta_of(AL,colour,COLOUR); sl(AL); boolean(B).
action(AL,sequential,ROBO,move(L)) :- insta_of(AL,robot,ROBO); insta_of(AL,location,L); sl(AL).
action(AL,concurrent,ROBO,grasp(DESC,OBJ)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; sl(AL).
action(AL,concurrent,ROBO,release(DESC,OBJ)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; sl(AL).
action(AL,concurrent,ROBO,configure(DESC,STATE)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,configurable,DESC); state_of(AL,DESC,STATE); AL < reduc; sl(AL).
action(AL,concurrent,ROBO,put(DESC,OBJ,SURFACE)) :- OBJ != SURFACE; SURFACE != nothing; desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); sl(AL).
action(AL,concurrent,ROBO,lift(DESC,OBJ)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); sl(AL).
action(AL,sequential,ROBO,actuate(DESC,D)) :- insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,door,D); AL < reduc; sl(AL).
#program action_effects(t).
effect(AL,ROBO,move(L),in(ROBO),L) :- action(AL,_,ROBO,move(L)); fluent(AL,inertial,in(ROBO),L); insta_of(AL,robot,ROBO); insta_of(AL,location,L); pl(AL).
effect(AL,ROBO,grasp(DESC,OBJ),grasping(DESC),OBJ) :- action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; pl(AL).
effect(AL,ROBO,release(DESC,OBJ),grasping(DESC),nothing) :- action(AL,_,ROBO,release(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); pl(AL).
effect(AL,ROBO,release(END,OBJ),configuration(END),aligned_with(nothing)) :- action(AL,_,ROBO,release(END,OBJ)); fluent(AL,inertial,configuration(END),aligned_with(nothing)); desce_of(AL,ROBO,END); insta_of(AL,armed_robot,ROBO); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); state_of(AL,END,aligned_with(nothing)); AL < reduc; pl(AL).
effect(AL,ROBO,configure(DESC,STATE),configuration(DESC),STATE) :- action(AL,_,ROBO,configure(DESC,STATE)); fluent(AL,inertial,configuration(DESC),STATE); desce_of(AL,ROBO,DESC); insta_of(AL,robot,ROBO); insta_of(AL,configurable,DESC); state_of(AL,DESC,STATE); AL < reduc; pl(AL).
effect(AL,ROBO,configure(ARM,retracted),configuration(END),aligned_with(nothing),t) :- holds(AL,grasping(END),nothing,(t-1)); action(AL,_,ROBO,configure(ARM,retracted)); fluent(AL,inertial,configuration(END),aligned_with(nothing)); desce_of(AL,ROBO,ARM); desce_of(AL,ROBO,END); siblings(AL,ARM,END); insta_of(AL,armed_robot,ROBO); insta_of(AL,extensible,ARM); insta_of(AL,manipulator_end,END); state_of(AL,END,aligned_with(nothing)); AL < reduc; pl(AL).
effect(AL,ROBO,put(DESC,OBJ,SURFACE),on(OBJ),SURFACE) :- action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,on(OBJ),SURFACE); OBJ != SURFACE; SURFACE != nothing; desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); pl(AL).
effect(AL,ROBO,lift(DESC,OBJ),on(OBJ),nothing) :- action(AL,_,ROBO,lift(DESC,OBJ)); fluent(AL,inertial,on(OBJ),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); pl(AL).
effect(AL,ROBO,actuate(DESC,D),configuration(D),STATE_1,t) :- holds(AL,configuration(D),STATE_2,(t-1)); fluent(AL,inertial,configuration(D),STATE_1); fluent(AL,inertial,configuration(D),STATE_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,door,D); state_of(AL,D,STATE_1); state_of(AL,D,STATE_2); STATE_1 != STATE_2; AL < reduc; pl(AL).
#program action_preconditions(t).
1 = { precond(AL,ROBO,move(P_2),in(ROBO),P_1,true,t): is(AL,connected(P_1,P_2)), fluent(AL,inertial,in(ROBO),P_1), static(AL,connected(P_1,P_2)), P_1 != P_2, insta_of(AL,location,P_1) } :- action(AL,_,ROBO,move(P_2)); insta_of(AL,robot,ROBO); insta_of(AL,location,P_2); AL < reduc; pl(AL).
precond(AL,ROBO,move(L_2),configuration(D),open,true,t) :- holds(AL,in(ROBO),L_1,(t-1)); is(AL,connected_by_door(D,L_1,L_2)); L_1 != L_2; action(AL,_,ROBO,move(L_2)); fluent(AL,inertial,configuration(D),open); fluent(AL,_,in(ROBO),L_1); static(AL,connected_by_door(D,L_1,L_2)); insta_of(AL,robot,ROBO); insta_of(AL,location,L_1); insta_of(AL,location,L_2); insta_of(AL,door,D); AL < reduc; pl(AL).
1 = { precond(AL,ROBO,actuate(COMP,D),grasping(COMP),H,true,t): desce_of(AL,D,H), insta_of(AL,handle,H), action(AL,_,ROBO,actuate(COMP,D)), fluent(AL,inertial,grasping(COMP),H) } :- desce_of(AL,ROBO,COMP); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,COMP); insta_of(AL,door,D); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),in(ROBO),L,true) :- is(AL,in(OBJ,L)); action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,in(ROBO),L); static(AL,in(OBJ,L)); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,grounded,OBJ); insta_of(AL,location,L); AL < reduc; pl(AL).
precond(AL,ROBO,move(L),configuration(DESC),retracted,true) :- action(AL,_,ROBO,move(L)); fluent(AL,inertial,configuration(DESC),retracted); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,extensible,DESC); insta_of(AL,location,L); state_of(AL,DESC,retracted); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),in(OBJ),L,true,t) :- holds(AL,in(ROBO),L,(t-1)); OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,in(OBJ),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),in(ROBO),L,true,t) :- holds(AL,in(OBJ),L,(t-1)); OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,in(OBJ),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),grasping(DESC),nothing,true) :- OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ_1),on(OBJ_2),OBJ_1,false) :- OBJ_1 != OBJ_2; OBJ_1 != nothing; action(AL,_,ROBO,grasp(DESC,OBJ_1)); fluent(AL,inertial,on(OBJ_2),OBJ_1); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ_1); insta_of(AL,surface,OBJ_1); insta_of(AL,placeable,OBJ_2); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),configuration(DESC),extended,true) :- OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,configuration(DESC),extended); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,extensible,DESC); insta_of(AL,graspable,OBJ); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(DESC_1,OBJ),configuration(DESC_2),extended,true) :- OBJ != nothing; action(AL,_,ROBO,grasp(DESC_1,OBJ)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC_1); not insta_of(AL,extensible,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,graspable,OBJ); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(END,OBJ),configuration(END),aligned_with(OBJ),true) :- OBJ != nothing; action(AL,_,ROBO,grasp(END,OBJ)); fluent(AL,inertial,configuration(END),aligned_with(OBJ)); desce_of(AL,ROBO,END); insta_of(AL,armed_robot,ROBO); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); state_of(AL,END,aligned_with(OBJ)); AL < reduc; pl(AL).
precond(AL,ROBO,release(DESC,OBJ),grasping(DESC),OBJ,true) :- OBJ != nothing; action(AL,_,ROBO,release(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); pl(AL).
precond(AL,ROBO,release(DESC,OBJ),configuration(DESC),extended,true) :- OBJ != nothing; action(AL,_,ROBO,release(DESC,OBJ)); fluent(AL,inertial,configuration(DESC),extended); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); state_of(AL,DESC,extended); pl(AL); t > 0.
precond(AL,ROBO,release(DESC_1,OBJ),configuration(DESC_2),extended,true) :- OBJ != nothing; action(AL,_,ROBO,release(DESC_1,OBJ)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC_1); not insta_of(AL,extensible,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,graspable,OBJ); pl(AL).
precond(AL,ROBO,configure(DESC_1,STATE),configuration(DESC_2),extended,true) :- action(AL,_,ROBO,configure(DESC_1,STATE)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); desce_of(AL,ROBO,ARM); child_of(AL,ARM,DESC_1); child_of(AL,ARM,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,configurable,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,manipulator_arm,ARM); state_of(AL,DESC_1,STATE); AL < reduc; pl(AL).
precond(AL,ROBO,configure(DESC,aligned_with(OBJ)),grasping(DESC),nothing,true) :- action(AL,_,ROBO,configure(DESC,aligned_with(OBJ))); fluent(AL,inertial,grasping(DESC),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,manipulator_end,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; state_of(AL,DESC,aligned_with(OBJ)); AL < reduc; pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),in(SURFACE),L,true,t) :- holds(AL,in(ROBO),L,(t-1)); action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,in(SURFACE),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),in(ROBO),L,true,t) :- holds(AL,in(SURFACE),L,(t-1)); action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,in(SURFACE),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,put(DESC,OBJ_1,BLOCK),on(OBJ_2),BLOCK,false) :- OBJ_1 != OBJ_2; action(AL,_,ROBO,put(DESC,OBJ_1,SURFACE)); fluent(AL,inertial,on(OBJ_2),BLOCK); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ_1); insta_of(AL,placeable,OBJ_2); insta_of(AL,block,BLOCK); pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),grasping(DESC),OBJ,true) :- OBJ != SURFACE; OBJ != nothing; SURFACE != nothing; action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); pl(AL).
precond(AL,ROBO_1,put(DESC_1,OBJ_1,OBJ_2),grasping(DESC_2),OBJ_2,false) :- OBJ_1 != OBJ_2; DESC_1 != DESC_2; action(AL,_,ROBO,put(DESC_1,OBJ_1,OBJ_2)); fluent(AL,inertial,grasping(DESC_2),OBJ_2); desce_of(AL,ROBO_1,DESC_1); desce_of(AL,ROBO_2,DESC_2); insta_of(AL,armed_robot,ROBO_1); insta_of(AL,armed_robot,ROBO_2); insta_of(AL,grasper,DESC_1); insta_of(AL,grasper,DESC_2); insta_of(AL,placeable,OBJ_1); insta_of(AL,surface,OBJ_2); insta_of(AL,graspable,OBJ_2); pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),configuration(DESC),extended,true) :- action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,configuration(DESC),extended); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,extensible,DESC); insta_of(AL,graspable,OBJ); insta_of(AL,surface,SURFACE); AL < reduc; pl(AL).
precond(AL,ROBO,put(DESC_1,OBJ,SURFACE),configuration(DESC_2),extended,true) :- action(AL,_,ROBO,put(DESC_1,OBJ,SURFACE)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC_1); not insta_of(AL,extensible,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,graspable,OBJ); insta_of(AL,surface,SURFACE); AL < reduc; pl(AL).
precond(AL,ROBO,lift(DESC,OBJ_1),on(OBJ_2),OBJ_1,false) :- OBJ_1 != OBJ_2; action(AL,_,ROBO,lift(DESC,OBJ_1)); fluent(AL,inertial,on(OBJ_2),OBJ_1); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ_1); insta_of(AL,surface,OBJ_1); insta_of(AL,placeable,OBJ_2); pl(AL).
precond(AL,ROBO,lift(DESC,OBJ),grasping(DESC),OBJ,true) :- OBJ != SURFACE; action(AL,_,ROBO,lift(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,surface,SURFACE); pl(AL).
#program variable_relations(t).
#false :- holds(AL,grasping(DESC),OBJ,t); holds(AL,in(ROBO),L,t); not holds(AL,in(OBJ),L,t): not insta_of(AL,grounded,OBJ), fluent(AL,inertial,in(OBJ),L); not is(AL,in(OBJ,L)): insta_of(AL,grounded,OBJ), static(AL,in(OBJ,L)); fluent(AL,inertial,grasping(DESC),OBJ); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,location,L); sl(AL).
#false :- holds(AL,configuration(END),aligned_with(OBJ),t); holds(AL,in(ROBO),L,t); not holds(AL,in(OBJ),L,t): not insta_of(AL,grounded,OBJ), fluent(AL,inertial,in(OBJ),L); not is(AL,in(OBJ,L)): insta_of(AL,grounded,OBJ), static(AL,in(OBJ,L)); fluent(AL,inertial,configuration(END),aligned_with(OBJ)); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,END); insta_of(AL,robot,ROBO); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,location,L); state_of(AL,END,aligned_with(OBJ)); sl(AL).
#false :- holds(AL,grasping(END),OBJ,t); not holds(AL,configuration(END),aligned_with(OBJ),t); fluent(AL,inertial,grasping(END),OBJ); fluent(AL,inertial,configuration(END),aligned_with(OBJ)); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); OBJ != nothing; state_of(AL,END,aligned_with(OBJ)); sl(AL).
#false :- holds(AL,grasping(DESC),OBJ_1,t); holds(AL,on(OBJ_2),OBJ_1,t); fluent(AL,inertial,grasping(DESC),OBJ_1); fluent(AL,inertial,on(OBJ_2),OBJ_1); desce_of(AL,ROBO,DESC); insta_of(AL,robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ_1); OBJ_1 != nothing; insta_of(AL,surface,OBJ_1); insta_of(AL,placeable,OBJ_2); sl(AL).
#false :- holds(AL,on(OBJ),SURFACE,t); holds(AL,in(SURFACE),L,t); not holds(AL,in(OBJ),L,t); fluent(AL,inertial,on(OBJ),SURFACE); fluent(AL,inertial,in(SURFACE),L); fluent(AL,inertial,in(OBJ),L); insta_of(AL,location,L); insta_of(AL,location,L); insta_of(AL,surface,SURFACE); insta_of(AL,object,OBJ); sl(AL).
#false :- holds(AL,on(BLOCK_1),BLOCK_2,t); holds(AL,on(BLOCK_2),nothing,t); fluent(AL,inertial,on(BLOCK_1),BLOCK_2); fluent(AL,inertial,on(BLOCK_2),nothing); insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); sl(AL).
#false :- holds(AL,on(BLOCK_1),BLOCK_3,t); holds(AL,on(BLOCK_2),BLOCK_3,t); fluent(AL,inertial,on(BLOCK_1),BLOCK_3); fluent(AL,inertial,on(BLOCK_2),BLOCK_3); BLOCK_1 != BLOCK_2; insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); insta_of(AL,block,BLOCK_3); sl(AL).
holds(AL,tower_base(BASE),true,t) :- holds(AL,on(BASE),TABLE,t); fluent(AL,defined,tower_base(BASE),true); fluent(AL,inertial,on(BASE),TABLE); insta_of(AL,block,BASE); insta_of(AL,table,TABLE); sl(AL).
holds(AL,tower_base(BASE),true,t) :- holds(AL,on(BASE),SURFACE,t); fluent(AL,defined,tower_base(BASE),true); fluent(AL,inertial,on(BASE),SURFACE); desce_of(AL,TABLE,SURFACE); insta_of(AL,block,BASE); insta_of(AL,surface,SURFACE); insta_of(AL,table,TABLE); sl(AL).
holds(AL,in_tower(BASE,BASE),true,t) :- holds(AL,tower_base(BASE),true,t); fluent(AL,defined,in_tower(BASE,BASE),true); fluent(AL,defined,tower_base(BASE),true); insta_of(AL,block,BASE); sl(AL).
holds(AL,in_tower(BLOCK_1,BLOCK_2),true,t) :- holds(AL,on(BLOCK_2),BLOCK_3,t); holds(AL,in_tower(BLOCK_1,BLOCK_3),true,t); fluent(AL,defined,in_tower(BLOCK_1,BLOCK_2),true); fluent(AL,defined,in_tower(BLOCK_1,BLOCK_3),true); fluent(AL,inertial,on(BLOCK_2),BLOCK_3); BLOCK_1 != BLOCK_2; insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); insta_of(AL,block,BLOCK_3); sl(AL).
holds(AL,unordered_tower(BASE),true,t) :- holds(AL,on(BLOCK_1),BLOCK_2,t); holds(AL,in_tower(BASE,BLOCK_1),true,t); holds(AL,in_tower(BASE,BLOCK_2),true,t); holds(AL,tower_base(BASE),true,t); fluent(AL,defined,unordered_tower(BASE),true); fluent(AL,defined,in_tower(BASE,BLOCK_1),true); fluent(AL,defined,in_tower(BASE,BLOCK_2),true); fluent(AL,defined,tower_base(BASE),true); fluent(AL,inertial,on(BLOCK_1),BLOCK_2); BLOCK_1 = (block,N_1); number(N_1); BLOCK_2 = (block,N_2); number(N_2); BLOCK_1 != BLOCK_2; N_1 > N_2; insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); insta_of(AL,block,BASE); sl(AL).
holds(AL,complete(COLOUR),true,t) :- N = #count { BLOCK: holds(AL,in_tower(BASE,BLOCK),true,t), is(AL,colour_of(BLOCK,COLOUR)), fluent(AL,defined,in_tower(BASE,BLOCK),true), static(AL,colour_of(BLOCK,COLOUR)), insta_of(AL,block,BLOCK) }; N = #count { BLOCK: is(AL,colour_of(BLOCK,COLOUR)), static(AL,colour_of(BLOCK,COLOUR)), insta_of(AL,block,BLOCK) }; holds(AL,unordered_tower(BASE),false,t); holds(AL,tower_base(BASE),true,t); fluent(AL,defined,unordered_tower(BASE),true); fluent(AL,defined,tower_base(BASE),true); is(AL,colour_of(BASE,COLOUR)); static(AL,colour_of(BASE,COLOUR)); insta_of(AL,colour,COLOUR); insta_of(AL,block,BASE); sl(AL).
#program abstraction_mappings(t).
is(AL_1,connected(L_1,L_2)) :- is(AL_2,connected(L_1_C,L_2_C)); static(AL_1,connected(L_1,L_2)); static(AL_2,connected(L_1_C,L_2_C)); L_1 != L_2; desce_of(AL_2,L_1,L_1_C); desce_of(AL_2,L_2,L_2_C); insta_of(AL_1,location,L_1); insta_of(AL_1,location,L_2); insta_of(AL_2,location,L_1_C); insta_of(AL_2,location,L_2_C); al(AL_1); al(AL_2); AL_1 >= AL_2.
is(AL_1,connected(L_1,L_2)) :- is(AL_2,connected(L_1,L_2)); static(AL_1,connected(L_1,L_2)); static(AL_2,connected(L_1,L_2)); L_1 != L_2; insta_of(AL_1,location,L_1); insta_of(AL_1,location,L_2); insta_of(AL_2,location,L_1); insta_of(AL_2,location,L_2); al(AL_1); al(AL_2); AL_1 >= AL_2.
is(AL_1,connected_by_door(D,L_1,L_2)) :- is(AL_2,connected_by_door(D,L_1_C,L_2_C)); static(AL_1,connected_by_door(D,L_1,L_2)); static(AL_2,connected_by_door(D,L_1_C,L_2_C)); L_1 != L_2; desce_of(AL_2,L_1,L_1_C); desce_of(AL_2,L_2,L_2_C); insta_of(AL_1,door,D); insta_of(AL_2,door,D); insta_of(AL_1,location,L_1); insta_of(AL_1,location,L_2); insta_of(AL_2,location,L_1_C); insta_of(AL_2,location,L_2_C); al(AL_1); al(AL_2); AL_1 >= AL_2.
is(AL_1,in(OBJ,L_1)) :- is(AL_2,in(OBJ,L_2)); static(AL_1,in(OBJ,L_1)); static(AL_2,in(OBJ,L_2)); desce_of(AL_2,L_1,L_2); insta_of(AL_1,location,L_1); insta_of(AL_1,object,OBJ); insta_of(AL_1,grounded,OBJ); insta_of(AL_1,location,L_1); insta_of(AL_2,location,L_2); al(AL_1); al(AL_2); AL_1 >= AL_2.
holds(AL_1,in(OBJ),L_1,t) :- holds(AL_2,in(OBJ),L_2,t); fluent(AL_1,inertial,in(OBJ),L_1); fluent(AL_2,inertial,in(OBJ),L_2); desce_of(AL_2,L_1,L_2); insta_of(AL_1,location,L_1); insta_of(AL_2,location,L_2); insta_of(AL_3,object,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
holds(AL_1,in(OBJ),L,t) :- holds(AL_2,in(OBJ),L,t); fluent(AL_1,inertial,in(OBJ),L); fluent(AL_2,inertial,in(OBJ),L); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,object,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
holds(AL_1,in(DESC),L,t) :- holds(AL_2,in(OBJ),L,t); fluent(AL_1,inertial,in(DESC),L); fluent(AL_2,inertial,in(OBJ),L); desce_of(AL_2,OBJ,DESC); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,object,OBJ); insta_of(AL_4,_,DESC); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_2; sl(AL_4); AL_4 >= AL_1.
holds(AL_1,in(OBJ),L,t) :- holds(AL_2,in(DESC),L,t); fluent(AL_1,inertial,in(OBJ),L); fluent(AL_2,inertial,in(DESC),L); desce_of(AL_2,OBJ,DESC); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,object,OBJ); insta_of(AL_4,_,DESC); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_2.
holds(AL_1,in(OBJ),L,t) :- holds(AL_2,in(ROBO),L,t); holds(AL_3,grasping(DESC),OBJ,t); fluent(AL_1,inertial,in(OBJ),L); fluent(AL_2,inertial,in(ROBO),L); fluent(AL_3,inertial,grasping(DESC),OBJ); desce_of(AL_2,ROBO,DESC); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,graspable,OBJ); OBJ != nothing; insta_of(AL_4,grasper,DESC); insta_of(AL_5,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_3; sl(AL_5); AL_5 >= AL_3.
holds(AL_1,grasping(DESC),OBJ_1,t) :- holds(AL_2,grasping(DESC),OBJ_2,t); fluent(AL_1,inertial,grasping(DESC),OBJ_1); fluent(AL_2,inertial,grasping(DESC),OBJ_2); desce_of(AL_2,ROBO,DESC); desce_of(AL_2,OBJ_1,OBJ_2); insta_of(AL_1,graspable,OBJ_1); insta_of(AL_2,graspable,OBJ_2); insta_of(AL_3,grasper,DESC); insta_of(AL_4,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_1.
holds(AL_1,grasping(DESC_1),OBJ,t) :- holds(AL_2,grasping(DESC_2),OBJ,t); fluent(AL_1,inertial,grasping(DESC_1),OBJ); fluent(AL_2,inertial,grasping(DESC_2),OBJ); desce_of(AL_2,ROBO,DESC_1); desce_of(AL_2,ROBO,DESC_2); desce_of(AL_2,DESC_1,DESC_2); insta_of(AL_1,graspable,OBJ); insta_of(AL_2,graspable,OBJ); insta_of(AL_3,grasper,DESC_1); insta_of(AL_4,grasper,DESC_2); insta_of(AL_5,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_2; sl(AL_5); AL_5 >= AL_1.
holds(AL_1,grasping(DESC),OBJ,t) :- holds(AL_2,grasping(DESC),OBJ,t); fluent(AL_1,inertial,grasping(DESC),OBJ); fluent(AL_2,inertial,grasping(DESC),OBJ); desce_of(AL_2,ROBO,DESC); insta_of(AL_1,graspable,OBJ); insta_of(AL_2,graspable,OBJ); insta_of(AL_3,grasper,DESC); insta_of(AL_4,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_1; boolean(B).
holds(AL_1,configuration(DESC_1),STATE,t) :- holds(AL_2,configuration(DESC_2),STATE,t); fluent(AL_1,inertial,configuration(DESC_1),STATE); fluent(AL_2,inertial,configuration(DESC_2),STATE); desce_of(AL_2,DESC_1,DESC_2); state_of(AL_1,DESC_1,STATE); state_of(AL_2,DESC_2,STATE); insta_of(AL_1,configurable,DESC_1); insta_of(AL_2,configurable,DESC_2); sl(AL_1); sl(AL_2); AL_1 >= AL_2.
holds(AL_1,configuration(DESC),STATE,t) :- holds(AL_2,configuration(DESC),STATE,t); fluent(AL_1,inertial,configuration(DESC),STATE); fluent(AL_2,inertial,configuration(DESC),STATE); state_of(AL_1,DESC,STATE); state_of(AL_2,DESC,STATE); insta_of(AL_1,configurable,DESC); insta_of(AL_2,configurable,DESC); sl(AL_1); sl(AL_2); AL_1 >= AL_2.
holds(AL_1,on(OBJ),SURFACE_1,t) :- holds(AL_2,on(OBJ),SURFACE_2,t); fluent(AL_1,inertial,on(OBJ),SURFACE_1); fluent(AL_2,inertial,on(OBJ),SURFACE_2); desce_of(AL_2,SURFACE_1,SURFACE_2); insta_of(AL_1,surface,SURFACE_1); insta_of(AL_2,surface,SURFACE_2); insta_of(AL_3,placeable,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
holds(AL_1,on(OBJ),SURFACE,t) :- holds(AL_2,on(OBJ),SURFACE,t); fluent(AL_1,inertial,on(OBJ),SURFACE); fluent(AL_2,inertial,on(OBJ),SURFACE); insta_of(AL_1,surface,SURFACE); insta_of(AL_2,surface,SURFACE); insta_of(AL_3,placeable,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
#program static_state.
is(1,connected((starting_room,1),(hallway,1))).
is(1,connected((store_room,1),(hallway,0))).
is(1,connected((hallway,2),(puzzle_room,0))).
is(1,connected_by_door(store_room_door,(store_room,1),(hallway,0))).
is(1,connected_by_door(puzzle_room_door,(hallway,2),(puzzle_room,0))).
is(1,in(store_room_door_handle_inner,(store_room,1))).
is(1,in(store_room_door_handle_outer,(hallway,0))).
is(1,in(starting_room_door_handle_inner,(starting_room,1))).
is(1,in(starting_room_door_handle_outer,(hallway,1))).
is(1,in(puzzle_room_door_handle_inner,(puzzle_room,0))).
is(1,in(puzzle_room_door_handle_outer,(hallway,2))).
is(AL,colour_of((BLOCK,N),red)) :- static(AL,colour_of((BLOCK,N),red)); insta_of(AL,block,(BLOCK,N)); N <= 3; al(AL).
is(AL,colour_of((BLOCK,N),blue)) :- static(AL,colour_of((BLOCK,N),blue)); insta_of(AL,block,(BLOCK,N)); N > 3; N <= 6; al(AL).
is(1,connected((A,X_1),(A,X_2))) :- insta_of(1,cell,(A,X_1)); insta_of(1,cell,(A,X_2)); X_2 = (X_1+1).
is(1,connected(C_1,C_2)) :- is(1,connected(C_2,C_1)); insta_of(1,cell,C_1); insta_of(1,cell,C_2).
is(1,connected_by_door(D,C_1,C_2)) :- is(1,connected_by_door(D,C_2,C_1)); insta_of(1,door,D); insta_of(1,cell,C_1); insta_of(1,cell,C_2).
#program initial_state.
holds(1,in(talos),(starting_room,0),0).
holds(AL,grasping(DESC),nothing,0) :- fluent(AL,inertial,grasping(DESC),nothing); insta_of(AL,grasper,DESC); al(AL).
holds(AL,configuration(DESC),retracted,0) :- fluent(AL,inertial,configuration(DESC),retracted); insta_of(AL,extensible,DESC); sl(AL).
holds(1,configuration(END),aligned_with(nothing),0) :- fluent(AL,inertial,configuration(END),aligned_with(nothing)); insta_of(AL,manipulator_end,END); state_of(AL,END,aligned_with(nothing)); sl(AL).
holds(1,configuration(DOOR),closed,0) :- fluent(AL,inertial,configuration(DOOR),closed); insta_of(AL,door,DOOR); state_of(AL,DOOR,closed); sl(AL).
holds(1,in(puzzle_room_table),(puzzle_room,1),0).
holds(1,on((block,1)),puzzle_room_table_left,0).
holds(1,on((block,2)),puzzle_room_table_right,0).
holds(1,on((block,3)),(block,1),0).
holds(1,in((block,4)),(store_room,0),0).
holds(1,in((block,5)),(store_room,0),0).
holds(1,in((block,6)),(store_room,0),0).
holds(1,on((block,4)),nothing,0).
holds(1,on((block,5)),nothing,0).
holds(1,on((block,6)),nothing,0).
#program goal_state.
goal_fluent(AL,complete(COLOUR)) :- insta_of(AL,colour,COLOUR); al(AL).
goal_fluent(AL,on((block,3))) :- al(AL).
goal_fluent(AL,on((block,6))) :- al(AL).
final_goal(AL,complete(COLOUR),true,true) :- insta_of(AL,colour,COLOUR); al(AL).
final_goal(1,on((block,3)),puzzle_room_table_left,true).
final_goal(1,on((block,6)),puzzle_room_table_right,true).
#program entities.
entity(armed_robot,talos).
entity(manipulator_arm,manipulator_arm_1).
entity(manipulator_limb,manipulator_limb_1).
entity(manipulator_end,manipulator_end_1).
entity(manipulator_arm,manipulator_arm_2).
entity(manipulator_limb,manipulator_limb_2).
entity(manipulator_end,manipulator_end_2).
number((1..6)).
entity(block,(block,N)) :- number(N).
entity(room,starting_room).
entity(room,store_room).
entity(room,puzzle_room).
entity(room,hallway).
x((0..3)).
size(starting_room,2).
size(store_room,2).
size(hallway,3).
size(puzzle_room,2).
entity(cell,(ROOM,X)) :- entity(room,ROOM); size(ROOM,MAX); X < MAX; x(X).
entity(door,store_room_door).
entity(door,starting_room_door).
entity(door,puzzle_room_door).
entity(handle,store_room_door_handle_inner).
entity(handle,store_room_door_handle_outer).
entity(handle,starting_room_door_handle_inner).
entity(handle,starting_room_door_handle_outer).
entity(handle,puzzle_room_door_handle_inner).
entity(handle,puzzle_room_door_handle_outer).
entity(table,puzzle_room_table).
entity(side,puzzle_room_table_left).
entity(side,puzzle_room_table_right).
entity(colour,red).
entity(colour,blue).
entity(surface,nothing).
entity(graspable,nothing).
ancestry_relation(talos,manipulator_arm_1).
ancestry_relation(talos,manipulator_arm_2).
ancestry_relation(manipulator_arm_1,manipulator_limb_1).
ancestry_relation(manipulator_arm_2,manipulator_limb_2).
ancestry_relation(manipulator_arm_1,manipulator_end_1).
ancestry_relation(manipulator_arm_2,manipulator_end_2).
ancestry_relation(ROOM,(ROOM,X)) :- entity(room,ROOM); entity(cell,(ROOM,X)); x(X).
ancestry_relation(store_room_door,store_room_door_handle_inner).
ancestry_relation(store_room_door,store_room_door_handle_outer).
ancestry_relation(starting_room_door,starting_room_door_handle_inner).
ancestry_relation(starting_room_door,starting_room_door_handle_outer).
ancestry_relation(puzzle_room_door,puzzle_room_door_handle_inner).
ancestry_relation(puzzle_room_door,puzzle_room_door_handle_outer).
ancestry_relation(puzzle_room_table,puzzle_room_table_left).
ancestry_relation(puzzle_room_table,puzzle_room_table_right)., Anonymous #1))
	('solver_options', ['--parallel-mode=1,compete'])
	('assumptions', [])
	('context', None)
	('solve_incrementor', None)
	('base_parts', [BasePart(name='abstraction_levels', args=[0, 'hierarchical']), BasePart(name='domain_sorts', args=())])
	('inc_parts', [IncPart(name='step', args=['#inc'], range_=None)])
	('incremental', False)

[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Setting input storing variables:
	solver_options = ['--parallel-mode=1,compete']
	assumptions = []
	context = None
	incrementor = None
	base_parts = [BasePart(name='abstraction_levels', args=[0, 'hierarchical']), BasePart(name='domain_sorts', args=())]
	inc_parts = [IncPart(name='step', args=['#inc'], range_=None)]

[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Output storing variables reset.

[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Program building started :: Processing 336 rules

[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Program building completed in 0.003024300000000091s

[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Running one-shot ground and solve of program parts:
[BasePart(name='abstraction_levels', args=[0, 'hierarchical']), BasePart(name='domain_sorts', args=())]

[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Grounding program parts:
[('abstraction_levels', [Number(0), Function('hierarchical', [], True)]), ('domain_sorts', [])]

[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:91:58-77: info: atom does not occur in any rule head:
  insta_of(#X0,#P1,#X2)


[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:582:50-78: info: atom does not occur in any rule head:
  insta_of(AL,graspable,OBJ)


[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:595:36-63: info: atom does not occur in any rule head:
  insta_of(AL,location,L_1)


[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:596:36-63: info: atom does not occur in any rule head:
  insta_of(AL,location,L_2)


[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:600:47-68: info: atom does not occur in any rule head:
  insta_of(AL,door,D)


[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:601:47-74: info: atom does not occur in any rule head:
  insta_of(AL,location,L_1)


[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:602:47-74: info: atom does not occur in any rule head:
  insta_of(AL,location,L_2)


[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:606:27-52: info: atom does not occur in any rule head:
  insta_of(AL,object,OBJ)


[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:607:27-54: info: atom does not occur in any rule head:
  insta_of(AL,grounded,OBJ)


[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:608:27-52: info: atom does not occur in any rule head:
  insta_of(AL,location,L)


[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:612:41-67: info: atom does not occur in any rule head:
  insta_of(AL,block,BLOCK)


[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:613:41-69: info: atom does not occur in any rule head:
  insta_of(AL,colour,COLOUR)


[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:625:39-66: info: atom does not occur in any rule head:
  insta_of(AL_1,location,L)


[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:626:39-66: info: atom does not occur in any rule head:
  insta_of(AL_2,object,OBJ)


[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:627:43-72: info: atom does not occur in any rule head:
  insta_of(AL_2,grounded,OBJ)


[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:633:45-77: info: atom does not occur in any rule head:
  insta_of(AL_1,surface,SURFACE)


[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:634:45-75: info: atom does not occur in any rule head:
  insta_of(AL_2,placeable,OBJ)


[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:639:48-78: info: atom does not occur in any rule head:
  insta_of(AL_1,graspable,OBJ)


[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:640:48-77: info: atom does not occur in any rule head:
  insta_of(AL_2,grasper,DESC)


[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Clingo warning MessageCode.AtomUndefined: <string>:645:55-82: info: atom does not occur in any rule head:
  state_of(AL_1,DESC,STATE)


[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Grounding completed in 0.007964s.

[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Solving program.

[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Model found:
Model :: Total atoms = 67, Cost = (), Optimality proven = False, Number = 1, Thread ID = 0, Model type = ModelType.StableModel

[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Solving completed in 0.001215s with result Satisfiable.

[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Freeing held grounding...

[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Setting input storing variables:
	solver_options = []
	assumptions = []
	context = None
	incrementor = None
	base_parts = []
	inc_parts = []

[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Held grounding freed.

[09-09-2021_16-35-07] DEBUG :: Logic Program Anonymous #1 >> Returning from standard solve call:
Result :: SATISFIABLE : SEARCH INTERRUPTED : Total models = 1
Statistics :: Grounding = 0.007964s, Solving = 0.001215s, Total = 0.009178s, Memory = (RSS = 47, VMS = 43)
Final Model :: Total atoms = 67, Cost = (), Optimality proven = False, Number = 1, Thread ID = 0, Model type = ModelType.StableModel

[09-09-2021_16-35-07] DEBUG :: core.Planner >> Planning Domain Anon #1 :: Abstraction range = [1-3] instantiated successfully

[09-09-2021_16-35-07] DEBUG :: Logic Program ASH #1 >> Instantiating logic program...

[09-09-2021_16-35-07] DEBUG :: Logic Program ASH #1 >> Setting input storing variables:
	solver_options = []
	assumptions = []
	context = None
	incrementor = None
	base_parts = []
	inc_parts = []

[09-09-2021_16-35-07] DEBUG :: Logic Program ASH #1 >> Output storing variables reset.

[09-09-2021_16-35-07] DEBUG :: Logic Program ASH #1 >> Logic program instantiated.

[09-09-2021_16-35-07] DEBUG :: ASH Planner Main #1 >> Instantiated with program:
LogicProgram(#program base.
#program abstraction_levels(planning_level, mode).
al((1..abstraction_max)).
pl(AL) :- AL = planning_level; al(AL).
sl(AL) :- AL = planning_level; mode = classical; al(AL).
sl(AL) :- AL >= planning_level; AL <= (planning_level+1); mode = refinement; al(AL).
sl(AL) :- AL >= planning_level; AL <= abstraction_max; mode = hierarchical; al(AL).
#program instance_module.
boolean(true;false).
insta_of(AL,CLS,EN) :- entity(CLS,EN); class(AL,CLS); al(AL).
insta_of(AL_3,CLS_1,EN) :- insta_of(AL_2,CLS_2,EN); super_class(CLS_1,CLS_2); entity(CLS_3,EN); class(AL_3,CLS_3); class(AL_1,CLS_1); AL_1 >= AL_2; al(AL_1); al(AL_2); al(AL_3).
insta_of((AL-1),CLS,EN) :- insta_of(AL,CLS,EN); not overridden((AL-1),CLS,EN); class(_,CLS); al(AL); al((AL-1)).
overridden((AL-1),CLS,EN_1) :- overridden_by((AL-1),CLS,EN_1,EN_2); insta_of(AL,CLS,EN_1); insta_of((AL-1),CLS,EN_2); class(_,CLS); al(AL); al((AL-1)).
overridden_by((AL-1),CLS_3,EN_1,EN_2) :- insta_of(AL,CLS_1,EN_1); insta_of((AL-1),CLS_2,EN_2); insta_of(AL,CLS_3,EN_1); insta_of((AL-1),CLS_3,EN_2); desce_of((AL-1),EN_1,EN_2); override_class(CLS_1,CLS_2,CLS_3); class(_,CLS_1); class(_,CLS_2); class(_,CLS_3); al(AL); al((AL-1)).
state_of(AL,EN,S) :- state(AL,CLS,S); insta_of(AL,CLS,EN); al(AL).
child_of(AL,EN,DESCE) :- ancestry_relation(EN,DESCE); insta_of(AL,_,EN); insta_of(AL,_,DESCE); al(AL).
desce_of(AL,EN,DESCE) :- child_of(AL,EN,DESCE); insta_of(AL,_,EN); insta_of(AL,_,DESCE); al(AL).
desce_of(AL,EN,DESCE_1) :- desce_of(AL,DESCE_2,DESCE_1); desce_of(AL,EN,DESCE_2); insta_of(AL,_,EN); insta_of(AL,_,DESCE_1); insta_of(AL,_,DESCE_2); al(AL).
has_desce(AL,EN) :- desce_of(AL,EN,DESCE); insta_of(AL,_,EN); insta_of(AL,_,DESCE); al(AL).
has_desce(AL,EN,CLS) :- desce_of(AL,EN,DESCE); insta_of(AL,_,EN); insta_of(AL,CLS,DESCE); al(AL).
siblings(AL,DESCE_1,DESCE_2) :- child_of(AL,EN,DESCE_1); child_of(AL,EN,DESCE_2); DESCE_1 != DESCE_2; insta_of(AL,_,EN); insta_of(AL,_,DESCE_1); insta_of(AL,_,DESCE_2); al(AL).
siblings(AL,DESCE_2,DESCE_1) :- siblings(AL,DESCE_1,DESCE_2); insta_of(AL,_,DESCE_1); insta_of(AL,_,DESCE_2); al(AL).
#program state_module(step, start).
{ holds(AL,F,V,step) } :- fluent(AL,inertial,F,V); sl(AL); step = start.
#false :- not 1 = { holds(AL,F,V,step): fluent(AL,_,F,V) }; fluent(AL,_,F,_); sl(AL).
holds(AL,F,V,step) :- holds(AL,F,V,(step-1)); not not holds(AL,F,V,step); fluent(AL,inertial,F,V); sl(AL); step > start.
holds(AL,F,false,step) :- not holds(AL,F,true,step); fluent(AL,defined,F,B); boolean(B); sl(AL).
#program plan_module(step, start, concurrency, achieve_fgoals).
{ occurs(AL,ROBOT,A,step): action(AL,_,ROBOT,A) } :- incomplete_plan((step-1)); pl(AL); step > start.
occurs(AL,ROBOT,step) :- occurs(AL,ROBOT,A,step); action(AL,_,ROBOT,A); pl(AL); step > start.
occurs(AL,step) :- occurs(AL,ROBOT,step); insta_of(AL,robot,ROBOT); pl(AL); step > start.
holds(AL,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V,step); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
holds(AL,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,true,step); not holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,true); not holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,false,step); holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,false); holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- not 1 = { occurs(AL,R,A,step): action(AL,_,ROBOT,A) }; incomplete_plan((step-1)); pl(AL); step > start; concurrency = false.
#false :- not 1 <= { occurs(AL,R,A,step): action(AL,_,ROBOT,A), A != do_nothing }; incomplete_plan((step-1)); pl(AL); step > start; concurrency = true.
#false :- not occurs(AL,ROBOT,(step-1)); occurs(AL,ROBOT,step); insta_of(AL,robot,ROBOT); incomplete_plan((step-1)); pl(AL); step > (start+1); concurrency = true.
has_affect(AL,ROBOT,A,step) :- effect(AL,ROBOT,A,F,V,step); not holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
has_affect(AL,ROBOT,A,step) :- effect(AL,ROBOT,A,F,V); not holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); not has_affect(AL,ROBOT,A,step); action(AL,_,ROBOT,A); A != do_nothing; pl(AL); step > start.
action(AL,sequential,ROBOT,do_nothing) :- insta_of(AL,robot,ROBOT); sl(AL); concurrency = true.
#false :- occurs(AL,ROBOT,A_1,step); occurs(AL,ROBOT,A_2,step); A_1 != A_2; action(AL,_,ROBOT,A_1); action(AL,_,ROBOT,A_2); pl(AL); step > start; concurrency = false.
#false :- occurs(AL,ROBOT,A_1,step); occurs(AL,ROBOT,A_2,step); A_1 != A_2; action(AL,sequential,ROBOT,A_1); action(AL,_,ROBOT,A_2); pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); effect(AL,ROBOT_2,A_2,F,V_2,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; ROBOT_1 != ROBOT_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); effect(AL,ROBOT_2,A_2,F,V_2); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; ROBOT_1 != ROBOT_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1); effect(AL,ROBOT_2,A_2,F,V_2); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; ROBOT_1 != ROBOT_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); precond(AL,ROBOT_2,A_2,F,V_2,true,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); precond(AL,ROBOT_2,A_2,F,V_2,true); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V,step); precond(AL,ROBOT_2,A_2,F,V,false,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V,step); precond(AL,ROBOT_2,A_2,F,V,false); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1); precond(AL,ROBOT_2,A_2,F,V_2,true,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1); precond(AL,ROBOT_2,A_2,F,V_2,true); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V); precond(AL,ROBOT_2,A_2,F,V,false,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V); precond(AL,ROBOT_2,A_2,F,V,false); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#external seq_achieve_fgoals(step). [false]
enforce_achieve_fgoals(step) :- achieve_fgoals = true.
enforce_achieve_fgoals(step) :- 0 <= S; S <= step; seq_achieve_fgoals(S).
goal_satisfied(AL,F,V,true,step) :- final_goal(AL,F,V,true); holds(AL,F,V,step); fluent(AL,_,F,V); pl(AL); enforce_achieve_fgoals(step).
goal_satisfied(AL,F,V,false,step) :- final_goal(AL,F,V,false); not holds(AL,F,V,step); fluent(AL,_,F,V); pl(AL); enforce_achieve_fgoals(step).
incomplete_plan(step) :- final_goal(AL,F,V,B); not goal_satisfied(AL,F,V,B,step); fluent(AL,_,F,V); pl(AL); boolean(B); enforce_achieve_fgoals(step).
sub_goal(AL,ROBOT,A,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V,step); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); AL != 1; step > start.
sub_goal(AL,ROBOT,A,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); AL != 1; step > start.
#program optimisation_module(step, start, minimise_length, minimise_actions, minimise_cost, preempt_pos_fgoals, preempt_neg_fgoals, order_fgoals_achievement).
:~ occurs(AL,step); incomplete_plan((step-1)); pl(AL); step > start; minimise_length = true. [1@3,step]
:~ occurs(AL,ROBOT,A,step); action(AL,_,ROBOT,A); incomplete_plan((step-1)); pl(AL); step > start; minimise_actions = true. [1@2,ROBOT,A,step]
#heuristic occurs(AL,ROBOT,A,step) : action(AL,_,ROBOT,A); effect(AL,ROBOT,A,F,V); fluent(AL,inertial,F,V); final_goal(AL,F,V,true); pl(AL); step > start; preempt_pos_fgoals = true. [10@1,true]
#heuristic occurs(AL,ROBOT,A,step) : action(AL,_,ROBOT,A); effect(AL,ROBOT,A,F,V); fluent(AL,inertial,F,V); final_goal(AL,F,V,false); pl(AL); step > start; preempt_neg_fgoals = true. [10@0,false]
#program check(step).
#external query(step). [false]
#false :- incomplete_plan(step); query(step).
#program conformance_module(step, start, first, last, type, yield).
#external current_last_sgoals(I,step) : sgoals_index(I); yield = true. [false]
include_sgoals(I,step) :- I <= I_L; S <= step; current_last_sgoals(I_L,S); sgoals_index(I).
include_sgoals(I,step) :- sgoals_index(I); yield = false.
sgoals_index((first..last)).
current_sub_goal((AL+1),ROBOT,A,F,V,first,start) :- sub_goal((AL+1),ROBOT,A,F,V,first); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
sub_goal_satisfied((AL+1),ROBOT,A,F,V,I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,(step-1)); holds((AL+1),F,V,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,(step-1)); not sub_goal_satisfied((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); type = sequential; pl(AL).
unachieved_sgoals((AL+1),I_SG,step) :- current_sub_goal_index((AL+1),I_SG,(step-1)); sub_goal((AL+1),ROBOT,A,F,V,I_SG); not sub_goal_satisfied((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,(step-1)); unachieved_sgoals((AL+1),I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); type = simultaneous; pl(AL).
current_sub_goal((AL+1),ROBOT_1,A_1,F_1,V_1,(I_SG+1),step) :- include_sgoals((I_SG+1),step); sub_goal((AL+1),ROBOT_1,A_1,F_1,V_1,(I_SG+1)); current_sub_goal_index((AL+1),I_SG,(step-1)); not current_sub_goal_index((AL+1),I_SG,step); action((AL+1),_,ROBOT_1,A_1); fluent((AL+1),inertial,F_1,V_1); pl(AL).
sgoals_ach_at((AL+1),I_SG,step) :- current_sub_goal_index((AL+1),I_SG,(step-1)); not current_sub_goal_index((AL+1),I_SG,step); pl(AL).
current_sub_goal_index((AL+1),I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
incomplete_plan(step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
#program goal_abstraction_module.
holds(AL,F,V,0) :- final_goal(AL,F,V,true); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
not holds(AL,F,V,0) :- final_goal(AL,F,V,false); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
final_goal(AL,F,V,true) :- holds(AL,F,V,0); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
final_goal(AL,F,V,false) :- not holds(AL,F,V,0); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
{ holds(AL,F,V,0) } :- goal_fluent(AL,F); fluent(AL,inertial,F,V); al(AL).
#false :- not 1 = { holds(AL,F,V,0): fluent(AL,_,F,V) }; goal_fluent(AL,F); fluent(AL,_,F,_); al(AL).
holds(AL,F,false,0) :- not holds(AL,F,true,0); goal_fluent(AL,F); fluent(AL,defined,F,B); boolean(B); al(AL).
#program domain_sorts.
#const abstraction_max = 3.
#const reduc = 3.
#const conde = 2.
#const groun = 1.
class(3,robot).
class(3,armed_robot).
class(3,location).
class(3,room).
class(3,object).
class(3,grounded).
class(3,graspable).
class(3,placeable).
class(3,block).
class(3,surface).
class(3,table).
class(3,colour).
class(3,manipulator_arm).
class(3,grasper).
class(2,door).
class(2,handle).
class(2,configurable).
class(2,extensible).
class(1,cell).
class(1,manipulator_limb).
class(1,manipulator_end).
class(1,side).
super_class(robot,armed_robot).
super_class(location,room).
super_class(location,cell).
super_class(object,robot).
super_class(object,manipulator_arm).
super_class(object,manipulator_limb).
super_class(object,manipulator_end).
super_class(object,table).
super_class(object,side).
super_class(object,block).
super_class(object,grounded).
super_class(grounded,handle).
super_class(configurable,extensible).
super_class(configurable,grasper).
super_class(configurable,door).
super_class(extensible,manipulator_arm).
super_class(extensible,manipulator_limb).
super_class(grasper,manipulator_arm).
super_class(grasper,manipulator_end).
super_class(graspable,block).
super_class(graspable,handle).
super_class(placeable,block).
super_class(surface,table).
super_class(surface,side).
super_class(surface,block).
override_class(manipulator_arm,manipulator_end,grasper).
override_class(manipulator_arm,manipulator_limb,extensible).
override_class(room,cell,location).
override_class(table,side,surface).
state(AL,extensible,extended) :- AL < reduc; al(AL).
state(AL,extensible,retracted) :- AL < reduc; al(AL).
state(AL,manipulator_end,aligned_with(OBJ)) :- insta_of(AL,graspable,OBJ); class(AL,manipulator_end); AL < reduc; al(AL).
state(AL,manipulator_end,aligned_with(nothing)) :- AL < reduc; al(AL).
state(AL,door,open) :- AL < reduc; al(AL).
state(AL,door,closed) :- AL < reduc; al(AL).
static(AL,connected(L_1,L_2)) :- insta_of(AL,location,L_1); insta_of(AL,location,L_2); al(AL).
static(AL,connected_by_door(D,L_1,L_2)) :- insta_of(AL,door,D); insta_of(AL,location,L_1); insta_of(AL,location,L_2); AL < reduc; al(AL).
static(AL,in(OBJ,L)) :- insta_of(AL,object,OBJ); insta_of(AL,grounded,OBJ); insta_of(AL,location,L); AL < reduc; al(AL).
static(AL,colour_of(BLOCK,COLOUR)) :- insta_of(AL,block,BLOCK); insta_of(AL,colour,COLOUR); al(AL).
fluent(AL_1,inertial,in(OBJ),L) :- insta_of(AL_1,location,L); insta_of(AL_2,object,OBJ); OBJ != nothing; not insta_of(AL_2,grounded,OBJ); sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,on(OBJ),SURFACE) :- OBJ != SURFACE; insta_of(AL_1,surface,SURFACE); insta_of(AL_2,placeable,OBJ); sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,grasping(DESC),OBJ) :- insta_of(AL_1,graspable,OBJ); insta_of(AL_2,grasper,DESC); sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,configuration(DESC),STATE) :- state_of(AL_1,DESC,STATE); insta_of(AL_2,configurable,DESC); AL_1 < reduc; AL_2 < reduc; sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,configuration(D),STATE) :- state_of(AL_1,D,STATE); insta_of(AL_2,door,D); AL_1 < reduc; AL_2 < reduc; sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL,defined,tower_base(BASE),B) :- insta_of(AL,block,BASE); sl(AL); boolean(B).
fluent(AL,defined,in_tower(BASE,BLOCK),B) :- insta_of(AL,block,BASE); insta_of(AL,block,BLOCK); sl(AL); boolean(B).
fluent(AL,defined,unordered_tower(BASE),B) :- insta_of(AL,block,BASE); sl(AL); boolean(B).
fluent(AL,defined,complete(COLOUR),B) :- insta_of(AL,colour,COLOUR); sl(AL); boolean(B).
action(AL,sequential,ROBO,move(L)) :- insta_of(AL,robot,ROBO); insta_of(AL,location,L); sl(AL).
action(AL,concurrent,ROBO,grasp(DESC,OBJ)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; sl(AL).
action(AL,concurrent,ROBO,release(DESC,OBJ)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; sl(AL).
action(AL,concurrent,ROBO,configure(DESC,STATE)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,configurable,DESC); state_of(AL,DESC,STATE); AL < reduc; sl(AL).
action(AL,concurrent,ROBO,put(DESC,OBJ,SURFACE)) :- OBJ != SURFACE; SURFACE != nothing; desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); sl(AL).
action(AL,concurrent,ROBO,lift(DESC,OBJ)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); sl(AL).
action(AL,sequential,ROBO,actuate(DESC,D)) :- insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,door,D); AL < reduc; sl(AL).
#program action_effects(t).
effect(AL,ROBO,move(L),in(ROBO),L) :- action(AL,_,ROBO,move(L)); fluent(AL,inertial,in(ROBO),L); insta_of(AL,robot,ROBO); insta_of(AL,location,L); pl(AL).
effect(AL,ROBO,grasp(DESC,OBJ),grasping(DESC),OBJ) :- action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; pl(AL).
effect(AL,ROBO,release(DESC,OBJ),grasping(DESC),nothing) :- action(AL,_,ROBO,release(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); pl(AL).
effect(AL,ROBO,release(END,OBJ),configuration(END),aligned_with(nothing)) :- action(AL,_,ROBO,release(END,OBJ)); fluent(AL,inertial,configuration(END),aligned_with(nothing)); desce_of(AL,ROBO,END); insta_of(AL,armed_robot,ROBO); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); state_of(AL,END,aligned_with(nothing)); AL < reduc; pl(AL).
effect(AL,ROBO,configure(DESC,STATE),configuration(DESC),STATE) :- action(AL,_,ROBO,configure(DESC,STATE)); fluent(AL,inertial,configuration(DESC),STATE); desce_of(AL,ROBO,DESC); insta_of(AL,robot,ROBO); insta_of(AL,configurable,DESC); state_of(AL,DESC,STATE); AL < reduc; pl(AL).
effect(AL,ROBO,configure(ARM,retracted),configuration(END),aligned_with(nothing),t) :- holds(AL,grasping(END),nothing,(t-1)); action(AL,_,ROBO,configure(ARM,retracted)); fluent(AL,inertial,configuration(END),aligned_with(nothing)); desce_of(AL,ROBO,ARM); desce_of(AL,ROBO,END); siblings(AL,ARM,END); insta_of(AL,armed_robot,ROBO); insta_of(AL,extensible,ARM); insta_of(AL,manipulator_end,END); state_of(AL,END,aligned_with(nothing)); AL < reduc; pl(AL).
effect(AL,ROBO,put(DESC,OBJ,SURFACE),on(OBJ),SURFACE) :- action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,on(OBJ),SURFACE); OBJ != SURFACE; SURFACE != nothing; desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); pl(AL).
effect(AL,ROBO,lift(DESC,OBJ),on(OBJ),nothing) :- action(AL,_,ROBO,lift(DESC,OBJ)); fluent(AL,inertial,on(OBJ),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); pl(AL).
effect(AL,ROBO,actuate(DESC,D),configuration(D),STATE_1,t) :- holds(AL,configuration(D),STATE_2,(t-1)); fluent(AL,inertial,configuration(D),STATE_1); fluent(AL,inertial,configuration(D),STATE_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,door,D); state_of(AL,D,STATE_1); state_of(AL,D,STATE_2); STATE_1 != STATE_2; AL < reduc; pl(AL).
#program action_preconditions(t).
1 = { precond(AL,ROBO,move(P_2),in(ROBO),P_1,true,t): is(AL,connected(P_1,P_2)), fluent(AL,inertial,in(ROBO),P_1), static(AL,connected(P_1,P_2)), P_1 != P_2, insta_of(AL,location,P_1) } :- action(AL,_,ROBO,move(P_2)); insta_of(AL,robot,ROBO); insta_of(AL,location,P_2); AL < reduc; pl(AL).
precond(AL,ROBO,move(L_2),configuration(D),open,true,t) :- holds(AL,in(ROBO),L_1,(t-1)); is(AL,connected_by_door(D,L_1,L_2)); L_1 != L_2; action(AL,_,ROBO,move(L_2)); fluent(AL,inertial,configuration(D),open); fluent(AL,_,in(ROBO),L_1); static(AL,connected_by_door(D,L_1,L_2)); insta_of(AL,robot,ROBO); insta_of(AL,location,L_1); insta_of(AL,location,L_2); insta_of(AL,door,D); AL < reduc; pl(AL).
1 = { precond(AL,ROBO,actuate(COMP,D),grasping(COMP),H,true,t): desce_of(AL,D,H), insta_of(AL,handle,H), action(AL,_,ROBO,actuate(COMP,D)), fluent(AL,inertial,grasping(COMP),H) } :- desce_of(AL,ROBO,COMP); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,COMP); insta_of(AL,door,D); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),in(ROBO),L,true) :- is(AL,in(OBJ,L)); action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,in(ROBO),L); static(AL,in(OBJ,L)); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,grounded,OBJ); insta_of(AL,location,L); AL < reduc; pl(AL).
precond(AL,ROBO,move(L),configuration(DESC),retracted,true) :- action(AL,_,ROBO,move(L)); fluent(AL,inertial,configuration(DESC),retracted); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,extensible,DESC); insta_of(AL,location,L); state_of(AL,DESC,retracted); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),in(OBJ),L,true,t) :- holds(AL,in(ROBO),L,(t-1)); OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,in(OBJ),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),in(ROBO),L,true,t) :- holds(AL,in(OBJ),L,(t-1)); OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,in(OBJ),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),grasping(DESC),nothing,true) :- OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ_1),on(OBJ_2),OBJ_1,false) :- OBJ_1 != OBJ_2; OBJ_1 != nothing; action(AL,_,ROBO,grasp(DESC,OBJ_1)); fluent(AL,inertial,on(OBJ_2),OBJ_1); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ_1); insta_of(AL,surface,OBJ_1); insta_of(AL,placeable,OBJ_2); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),configuration(DESC),extended,true) :- OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,configuration(DESC),extended); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,extensible,DESC); insta_of(AL,graspable,OBJ); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(DESC_1,OBJ),configuration(DESC_2),extended,true) :- OBJ != nothing; action(AL,_,ROBO,grasp(DESC_1,OBJ)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC_1); not insta_of(AL,extensible,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,graspable,OBJ); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(END,OBJ),configuration(END),aligned_with(OBJ),true) :- OBJ != nothing; action(AL,_,ROBO,grasp(END,OBJ)); fluent(AL,inertial,configuration(END),aligned_with(OBJ)); desce_of(AL,ROBO,END); insta_of(AL,armed_robot,ROBO); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); state_of(AL,END,aligned_with(OBJ)); AL < reduc; pl(AL).
precond(AL,ROBO,release(DESC,OBJ),grasping(DESC),OBJ,true) :- OBJ != nothing; action(AL,_,ROBO,release(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); pl(AL).
precond(AL,ROBO,release(DESC,OBJ),configuration(DESC),extended,true) :- OBJ != nothing; action(AL,_,ROBO,release(DESC,OBJ)); fluent(AL,inertial,configuration(DESC),extended); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); state_of(AL,DESC,extended); pl(AL); t > 0.
precond(AL,ROBO,release(DESC_1,OBJ),configuration(DESC_2),extended,true) :- OBJ != nothing; action(AL,_,ROBO,release(DESC_1,OBJ)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC_1); not insta_of(AL,extensible,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,graspable,OBJ); pl(AL).
precond(AL,ROBO,configure(DESC_1,STATE),configuration(DESC_2),extended,true) :- action(AL,_,ROBO,configure(DESC_1,STATE)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); desce_of(AL,ROBO,ARM); child_of(AL,ARM,DESC_1); child_of(AL,ARM,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,configurable,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,manipulator_arm,ARM); state_of(AL,DESC_1,STATE); AL < reduc; pl(AL).
precond(AL,ROBO,configure(DESC,aligned_with(OBJ)),grasping(DESC),nothing,true) :- action(AL,_,ROBO,configure(DESC,aligned_with(OBJ))); fluent(AL,inertial,grasping(DESC),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,manipulator_end,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; state_of(AL,DESC,aligned_with(OBJ)); AL < reduc; pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),in(SURFACE),L,true,t) :- holds(AL,in(ROBO),L,(t-1)); action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,in(SURFACE),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),in(ROBO),L,true,t) :- holds(AL,in(SURFACE),L,(t-1)); action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,in(SURFACE),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,put(DESC,OBJ_1,BLOCK),on(OBJ_2),BLOCK,false) :- OBJ_1 != OBJ_2; action(AL,_,ROBO,put(DESC,OBJ_1,SURFACE)); fluent(AL,inertial,on(OBJ_2),BLOCK); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ_1); insta_of(AL,placeable,OBJ_2); insta_of(AL,block,BLOCK); pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),grasping(DESC),OBJ,true) :- OBJ != SURFACE; OBJ != nothing; SURFACE != nothing; action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); pl(AL).
precond(AL,ROBO_1,put(DESC_1,OBJ_1,OBJ_2),grasping(DESC_2),OBJ_2,false) :- OBJ_1 != OBJ_2; DESC_1 != DESC_2; action(AL,_,ROBO,put(DESC_1,OBJ_1,OBJ_2)); fluent(AL,inertial,grasping(DESC_2),OBJ_2); desce_of(AL,ROBO_1,DESC_1); desce_of(AL,ROBO_2,DESC_2); insta_of(AL,armed_robot,ROBO_1); insta_of(AL,armed_robot,ROBO_2); insta_of(AL,grasper,DESC_1); insta_of(AL,grasper,DESC_2); insta_of(AL,placeable,OBJ_1); insta_of(AL,surface,OBJ_2); insta_of(AL,graspable,OBJ_2); pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),configuration(DESC),extended,true) :- action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,configuration(DESC),extended); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,extensible,DESC); insta_of(AL,graspable,OBJ); insta_of(AL,surface,SURFACE); AL < reduc; pl(AL).
precond(AL,ROBO,put(DESC_1,OBJ,SURFACE),configuration(DESC_2),extended,true) :- action(AL,_,ROBO,put(DESC_1,OBJ,SURFACE)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC_1); not insta_of(AL,extensible,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,graspable,OBJ); insta_of(AL,surface,SURFACE); AL < reduc; pl(AL).
precond(AL,ROBO,lift(DESC,OBJ_1),on(OBJ_2),OBJ_1,false) :- OBJ_1 != OBJ_2; action(AL,_,ROBO,lift(DESC,OBJ_1)); fluent(AL,inertial,on(OBJ_2),OBJ_1); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ_1); insta_of(AL,surface,OBJ_1); insta_of(AL,placeable,OBJ_2); pl(AL).
precond(AL,ROBO,lift(DESC,OBJ),grasping(DESC),OBJ,true) :- OBJ != SURFACE; action(AL,_,ROBO,lift(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,surface,SURFACE); pl(AL).
#program variable_relations(t).
#false :- holds(AL,grasping(DESC),OBJ,t); holds(AL,in(ROBO),L,t); not holds(AL,in(OBJ),L,t): not insta_of(AL,grounded,OBJ), fluent(AL,inertial,in(OBJ),L); not is(AL,in(OBJ,L)): insta_of(AL,grounded,OBJ), static(AL,in(OBJ,L)); fluent(AL,inertial,grasping(DESC),OBJ); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,location,L); sl(AL).
#false :- holds(AL,configuration(END),aligned_with(OBJ),t); holds(AL,in(ROBO),L,t); not holds(AL,in(OBJ),L,t): not insta_of(AL,grounded,OBJ), fluent(AL,inertial,in(OBJ),L); not is(AL,in(OBJ,L)): insta_of(AL,grounded,OBJ), static(AL,in(OBJ,L)); fluent(AL,inertial,configuration(END),aligned_with(OBJ)); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,END); insta_of(AL,robot,ROBO); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,location,L); state_of(AL,END,aligned_with(OBJ)); sl(AL).
#false :- holds(AL,grasping(END),OBJ,t); not holds(AL,configuration(END),aligned_with(OBJ),t); fluent(AL,inertial,grasping(END),OBJ); fluent(AL,inertial,configuration(END),aligned_with(OBJ)); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); OBJ != nothing; state_of(AL,END,aligned_with(OBJ)); sl(AL).
#false :- holds(AL,grasping(DESC),OBJ_1,t); holds(AL,on(OBJ_2),OBJ_1,t); fluent(AL,inertial,grasping(DESC),OBJ_1); fluent(AL,inertial,on(OBJ_2),OBJ_1); desce_of(AL,ROBO,DESC); insta_of(AL,robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ_1); OBJ_1 != nothing; insta_of(AL,surface,OBJ_1); insta_of(AL,placeable,OBJ_2); sl(AL).
#false :- holds(AL,on(OBJ),SURFACE,t); holds(AL,in(SURFACE),L,t); not holds(AL,in(OBJ),L,t); fluent(AL,inertial,on(OBJ),SURFACE); fluent(AL,inertial,in(SURFACE),L); fluent(AL,inertial,in(OBJ),L); insta_of(AL,location,L); insta_of(AL,location,L); insta_of(AL,surface,SURFACE); insta_of(AL,object,OBJ); sl(AL).
#false :- holds(AL,on(BLOCK_1),BLOCK_2,t); holds(AL,on(BLOCK_2),nothing,t); fluent(AL,inertial,on(BLOCK_1),BLOCK_2); fluent(AL,inertial,on(BLOCK_2),nothing); insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); sl(AL).
#false :- holds(AL,on(BLOCK_1),BLOCK_3,t); holds(AL,on(BLOCK_2),BLOCK_3,t); fluent(AL,inertial,on(BLOCK_1),BLOCK_3); fluent(AL,inertial,on(BLOCK_2),BLOCK_3); BLOCK_1 != BLOCK_2; insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); insta_of(AL,block,BLOCK_3); sl(AL).
holds(AL,tower_base(BASE),true,t) :- holds(AL,on(BASE),TABLE,t); fluent(AL,defined,tower_base(BASE),true); fluent(AL,inertial,on(BASE),TABLE); insta_of(AL,block,BASE); insta_of(AL,table,TABLE); sl(AL).
holds(AL,tower_base(BASE),true,t) :- holds(AL,on(BASE),SURFACE,t); fluent(AL,defined,tower_base(BASE),true); fluent(AL,inertial,on(BASE),SURFACE); desce_of(AL,TABLE,SURFACE); insta_of(AL,block,BASE); insta_of(AL,surface,SURFACE); insta_of(AL,table,TABLE); sl(AL).
holds(AL,in_tower(BASE,BASE),true,t) :- holds(AL,tower_base(BASE),true,t); fluent(AL,defined,in_tower(BASE,BASE),true); fluent(AL,defined,tower_base(BASE),true); insta_of(AL,block,BASE); sl(AL).
holds(AL,in_tower(BLOCK_1,BLOCK_2),true,t) :- holds(AL,on(BLOCK_2),BLOCK_3,t); holds(AL,in_tower(BLOCK_1,BLOCK_3),true,t); fluent(AL,defined,in_tower(BLOCK_1,BLOCK_2),true); fluent(AL,defined,in_tower(BLOCK_1,BLOCK_3),true); fluent(AL,inertial,on(BLOCK_2),BLOCK_3); BLOCK_1 != BLOCK_2; insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); insta_of(AL,block,BLOCK_3); sl(AL).
holds(AL,unordered_tower(BASE),true,t) :- holds(AL,on(BLOCK_1),BLOCK_2,t); holds(AL,in_tower(BASE,BLOCK_1),true,t); holds(AL,in_tower(BASE,BLOCK_2),true,t); holds(AL,tower_base(BASE),true,t); fluent(AL,defined,unordered_tower(BASE),true); fluent(AL,defined,in_tower(BASE,BLOCK_1),true); fluent(AL,defined,in_tower(BASE,BLOCK_2),true); fluent(AL,defined,tower_base(BASE),true); fluent(AL,inertial,on(BLOCK_1),BLOCK_2); BLOCK_1 = (block,N_1); number(N_1); BLOCK_2 = (block,N_2); number(N_2); BLOCK_1 != BLOCK_2; N_1 > N_2; insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); insta_of(AL,block,BASE); sl(AL).
holds(AL,complete(COLOUR),true,t) :- N = #count { BLOCK: holds(AL,in_tower(BASE,BLOCK),true,t), is(AL,colour_of(BLOCK,COLOUR)), fluent(AL,defined,in_tower(BASE,BLOCK),true), static(AL,colour_of(BLOCK,COLOUR)), insta_of(AL,block,BLOCK) }; N = #count { BLOCK: is(AL,colour_of(BLOCK,COLOUR)), static(AL,colour_of(BLOCK,COLOUR)), insta_of(AL,block,BLOCK) }; holds(AL,unordered_tower(BASE),false,t); holds(AL,tower_base(BASE),true,t); fluent(AL,defined,unordered_tower(BASE),true); fluent(AL,defined,tower_base(BASE),true); is(AL,colour_of(BASE,COLOUR)); static(AL,colour_of(BASE,COLOUR)); insta_of(AL,colour,COLOUR); insta_of(AL,block,BASE); sl(AL).
#program abstraction_mappings(t).
is(AL_1,connected(L_1,L_2)) :- is(AL_2,connected(L_1_C,L_2_C)); static(AL_1,connected(L_1,L_2)); static(AL_2,connected(L_1_C,L_2_C)); L_1 != L_2; desce_of(AL_2,L_1,L_1_C); desce_of(AL_2,L_2,L_2_C); insta_of(AL_1,location,L_1); insta_of(AL_1,location,L_2); insta_of(AL_2,location,L_1_C); insta_of(AL_2,location,L_2_C); al(AL_1); al(AL_2); AL_1 >= AL_2.
is(AL_1,connected(L_1,L_2)) :- is(AL_2,connected(L_1,L_2)); static(AL_1,connected(L_1,L_2)); static(AL_2,connected(L_1,L_2)); L_1 != L_2; insta_of(AL_1,location,L_1); insta_of(AL_1,location,L_2); insta_of(AL_2,location,L_1); insta_of(AL_2,location,L_2); al(AL_1); al(AL_2); AL_1 >= AL_2.
is(AL_1,connected_by_door(D,L_1,L_2)) :- is(AL_2,connected_by_door(D,L_1_C,L_2_C)); static(AL_1,connected_by_door(D,L_1,L_2)); static(AL_2,connected_by_door(D,L_1_C,L_2_C)); L_1 != L_2; desce_of(AL_2,L_1,L_1_C); desce_of(AL_2,L_2,L_2_C); insta_of(AL_1,door,D); insta_of(AL_2,door,D); insta_of(AL_1,location,L_1); insta_of(AL_1,location,L_2); insta_of(AL_2,location,L_1_C); insta_of(AL_2,location,L_2_C); al(AL_1); al(AL_2); AL_1 >= AL_2.
is(AL_1,in(OBJ,L_1)) :- is(AL_2,in(OBJ,L_2)); static(AL_1,in(OBJ,L_1)); static(AL_2,in(OBJ,L_2)); desce_of(AL_2,L_1,L_2); insta_of(AL_1,location,L_1); insta_of(AL_1,object,OBJ); insta_of(AL_1,grounded,OBJ); insta_of(AL_1,location,L_1); insta_of(AL_2,location,L_2); al(AL_1); al(AL_2); AL_1 >= AL_2.
holds(AL_1,in(OBJ),L_1,t) :- holds(AL_2,in(OBJ),L_2,t); fluent(AL_1,inertial,in(OBJ),L_1); fluent(AL_2,inertial,in(OBJ),L_2); desce_of(AL_2,L_1,L_2); insta_of(AL_1,location,L_1); insta_of(AL_2,location,L_2); insta_of(AL_3,object,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
holds(AL_1,in(OBJ),L,t) :- holds(AL_2,in(OBJ),L,t); fluent(AL_1,inertial,in(OBJ),L); fluent(AL_2,inertial,in(OBJ),L); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,object,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
holds(AL_1,in(DESC),L,t) :- holds(AL_2,in(OBJ),L,t); fluent(AL_1,inertial,in(DESC),L); fluent(AL_2,inertial,in(OBJ),L); desce_of(AL_2,OBJ,DESC); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,object,OBJ); insta_of(AL_4,_,DESC); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_2; sl(AL_4); AL_4 >= AL_1.
holds(AL_1,in(OBJ),L,t) :- holds(AL_2,in(DESC),L,t); fluent(AL_1,inertial,in(OBJ),L); fluent(AL_2,inertial,in(DESC),L); desce_of(AL_2,OBJ,DESC); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,object,OBJ); insta_of(AL_4,_,DESC); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_2.
holds(AL_1,in(OBJ),L,t) :- holds(AL_2,in(ROBO),L,t); holds(AL_3,grasping(DESC),OBJ,t); fluent(AL_1,inertial,in(OBJ),L); fluent(AL_2,inertial,in(ROBO),L); fluent(AL_3,inertial,grasping(DESC),OBJ); desce_of(AL_2,ROBO,DESC); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,graspable,OBJ); OBJ != nothing; insta_of(AL_4,grasper,DESC); insta_of(AL_5,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_3; sl(AL_5); AL_5 >= AL_3.
holds(AL_1,grasping(DESC),OBJ_1,t) :- holds(AL_2,grasping(DESC),OBJ_2,t); fluent(AL_1,inertial,grasping(DESC),OBJ_1); fluent(AL_2,inertial,grasping(DESC),OBJ_2); desce_of(AL_2,ROBO,DESC); desce_of(AL_2,OBJ_1,OBJ_2); insta_of(AL_1,graspable,OBJ_1); insta_of(AL_2,graspable,OBJ_2); insta_of(AL_3,grasper,DESC); insta_of(AL_4,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_1.
holds(AL_1,grasping(DESC_1),OBJ,t) :- holds(AL_2,grasping(DESC_2),OBJ,t); fluent(AL_1,inertial,grasping(DESC_1),OBJ); fluent(AL_2,inertial,grasping(DESC_2),OBJ); desce_of(AL_2,ROBO,DESC_1); desce_of(AL_2,ROBO,DESC_2); desce_of(AL_2,DESC_1,DESC_2); insta_of(AL_1,graspable,OBJ); insta_of(AL_2,graspable,OBJ); insta_of(AL_3,grasper,DESC_1); insta_of(AL_4,grasper,DESC_2); insta_of(AL_5,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_2; sl(AL_5); AL_5 >= AL_1.
holds(AL_1,grasping(DESC),OBJ,t) :- holds(AL_2,grasping(DESC),OBJ,t); fluent(AL_1,inertial,grasping(DESC),OBJ); fluent(AL_2,inertial,grasping(DESC),OBJ); desce_of(AL_2,ROBO,DESC); insta_of(AL_1,graspable,OBJ); insta_of(AL_2,graspable,OBJ); insta_of(AL_3,grasper,DESC); insta_of(AL_4,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_1; boolean(B).
holds(AL_1,configuration(DESC_1),STATE,t) :- holds(AL_2,configuration(DESC_2),STATE,t); fluent(AL_1,inertial,configuration(DESC_1),STATE); fluent(AL_2,inertial,configuration(DESC_2),STATE); desce_of(AL_2,DESC_1,DESC_2); state_of(AL_1,DESC_1,STATE); state_of(AL_2,DESC_2,STATE); insta_of(AL_1,configurable,DESC_1); insta_of(AL_2,configurable,DESC_2); sl(AL_1); sl(AL_2); AL_1 >= AL_2.
holds(AL_1,configuration(DESC),STATE,t) :- holds(AL_2,configuration(DESC),STATE,t); fluent(AL_1,inertial,configuration(DESC),STATE); fluent(AL_2,inertial,configuration(DESC),STATE); state_of(AL_1,DESC,STATE); state_of(AL_2,DESC,STATE); insta_of(AL_1,configurable,DESC); insta_of(AL_2,configurable,DESC); sl(AL_1); sl(AL_2); AL_1 >= AL_2.
holds(AL_1,on(OBJ),SURFACE_1,t) :- holds(AL_2,on(OBJ),SURFACE_2,t); fluent(AL_1,inertial,on(OBJ),SURFACE_1); fluent(AL_2,inertial,on(OBJ),SURFACE_2); desce_of(AL_2,SURFACE_1,SURFACE_2); insta_of(AL_1,surface,SURFACE_1); insta_of(AL_2,surface,SURFACE_2); insta_of(AL_3,placeable,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
holds(AL_1,on(OBJ),SURFACE,t) :- holds(AL_2,on(OBJ),SURFACE,t); fluent(AL_1,inertial,on(OBJ),SURFACE); fluent(AL_2,inertial,on(OBJ),SURFACE); insta_of(AL_1,surface,SURFACE); insta_of(AL_2,surface,SURFACE); insta_of(AL_3,placeable,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
#program static_state.
is(1,connected((starting_room,1),(hallway,1))).
is(1,connected((store_room,1),(hallway,0))).
is(1,connected((hallway,2),(puzzle_room,0))).
is(1,connected_by_door(store_room_door,(store_room,1),(hallway,0))).
is(1,connected_by_door(puzzle_room_door,(hallway,2),(puzzle_room,0))).
is(1,in(store_room_door_handle_inner,(store_room,1))).
is(1,in(store_room_door_handle_outer,(hallway,0))).
is(1,in(starting_room_door_handle_inner,(starting_room,1))).
is(1,in(starting_room_door_handle_outer,(hallway,1))).
is(1,in(puzzle_room_door_handle_inner,(puzzle_room,0))).
is(1,in(puzzle_room_door_handle_outer,(hallway,2))).
is(AL,colour_of((BLOCK,N),red)) :- static(AL,colour_of((BLOCK,N),red)); insta_of(AL,block,(BLOCK,N)); N <= 3; al(AL).
is(AL,colour_of((BLOCK,N),blue)) :- static(AL,colour_of((BLOCK,N),blue)); insta_of(AL,block,(BLOCK,N)); N > 3; N <= 6; al(AL).
is(1,connected((A,X_1),(A,X_2))) :- insta_of(1,cell,(A,X_1)); insta_of(1,cell,(A,X_2)); X_2 = (X_1+1).
is(1,connected(C_1,C_2)) :- is(1,connected(C_2,C_1)); insta_of(1,cell,C_1); insta_of(1,cell,C_2).
is(1,connected_by_door(D,C_1,C_2)) :- is(1,connected_by_door(D,C_2,C_1)); insta_of(1,door,D); insta_of(1,cell,C_1); insta_of(1,cell,C_2).
#program initial_state.
holds(1,in(talos),(starting_room,0),0).
holds(AL,grasping(DESC),nothing,0) :- fluent(AL,inertial,grasping(DESC),nothing); insta_of(AL,grasper,DESC); al(AL).
holds(AL,configuration(DESC),retracted,0) :- fluent(AL,inertial,configuration(DESC),retracted); insta_of(AL,extensible,DESC); sl(AL).
holds(1,configuration(END),aligned_with(nothing),0) :- fluent(AL,inertial,configuration(END),aligned_with(nothing)); insta_of(AL,manipulator_end,END); state_of(AL,END,aligned_with(nothing)); sl(AL).
holds(1,configuration(DOOR),closed,0) :- fluent(AL,inertial,configuration(DOOR),closed); insta_of(AL,door,DOOR); state_of(AL,DOOR,closed); sl(AL).
holds(1,in(puzzle_room_table),(puzzle_room,1),0).
holds(1,on((block,1)),puzzle_room_table_left,0).
holds(1,on((block,2)),puzzle_room_table_right,0).
holds(1,on((block,3)),(block,1),0).
holds(1,in((block,4)),(store_room,0),0).
holds(1,in((block,5)),(store_room,0),0).
holds(1,in((block,6)),(store_room,0),0).
holds(1,on((block,4)),nothing,0).
holds(1,on((block,5)),nothing,0).
holds(1,on((block,6)),nothing,0).
#program goal_state.
goal_fluent(AL,complete(COLOUR)) :- insta_of(AL,colour,COLOUR); al(AL).
goal_fluent(AL,on((block,3))) :- al(AL).
goal_fluent(AL,on((block,6))) :- al(AL).
final_goal(AL,complete(COLOUR),true,true) :- insta_of(AL,colour,COLOUR); al(AL).
final_goal(1,on((block,3)),puzzle_room_table_left,true).
final_goal(1,on((block,6)),puzzle_room_table_right,true).
#program entities.
entity(armed_robot,talos).
entity(manipulator_arm,manipulator_arm_1).
entity(manipulator_limb,manipulator_limb_1).
entity(manipulator_end,manipulator_end_1).
entity(manipulator_arm,manipulator_arm_2).
entity(manipulator_limb,manipulator_limb_2).
entity(manipulator_end,manipulator_end_2).
number((1..6)).
entity(block,(block,N)) :- number(N).
entity(room,starting_room).
entity(room,store_room).
entity(room,puzzle_room).
entity(room,hallway).
x((0..3)).
size(starting_room,2).
size(store_room,2).
size(hallway,3).
size(puzzle_room,2).
entity(cell,(ROOM,X)) :- entity(room,ROOM); size(ROOM,MAX); X < MAX; x(X).
entity(door,store_room_door).
entity(door,starting_room_door).
entity(door,puzzle_room_door).
entity(handle,store_room_door_handle_inner).
entity(handle,store_room_door_handle_outer).
entity(handle,starting_room_door_handle_inner).
entity(handle,starting_room_door_handle_outer).
entity(handle,puzzle_room_door_handle_inner).
entity(handle,puzzle_room_door_handle_outer).
entity(table,puzzle_room_table).
entity(side,puzzle_room_table_left).
entity(side,puzzle_room_table_right).
entity(colour,red).
entity(colour,blue).
entity(surface,nothing).
entity(graspable,nothing).
ancestry_relation(talos,manipulator_arm_1).
ancestry_relation(talos,manipulator_arm_2).
ancestry_relation(manipulator_arm_1,manipulator_limb_1).
ancestry_relation(manipulator_arm_2,manipulator_limb_2).
ancestry_relation(manipulator_arm_1,manipulator_end_1).
ancestry_relation(manipulator_arm_2,manipulator_end_2).
ancestry_relation(ROOM,(ROOM,X)) :- entity(room,ROOM); entity(cell,(ROOM,X)); x(X).
ancestry_relation(store_room_door,store_room_door_handle_inner).
ancestry_relation(store_room_door,store_room_door_handle_outer).
ancestry_relation(starting_room_door,starting_room_door_handle_inner).
ancestry_relation(starting_room_door,starting_room_door_handle_outer).
ancestry_relation(puzzle_room_door,puzzle_room_door_handle_inner).
ancestry_relation(puzzle_room_door,puzzle_room_door_handle_outer).
ancestry_relation(puzzle_room_table,puzzle_room_table_left).
ancestry_relation(puzzle_room_table,puzzle_room_table_right)., ASH #1)

[09-09-2021_16-35-07] INFO :: ASH Planner Main #1 >> Attempting to initialise hierarchical planning problem...

[09-09-2021_16-35-07] DEBUG :: ASH Planner Main #1 >> Generating initial states...

[09-09-2021_16-35-07] DEBUG :: Logic Program ASH #1 >> Creating copy of self: rename = Main #1 || Generate Initial States

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Instantiating logic program...

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Setting input storing variables:
	solver_options = []
	assumptions = []
	context = None
	incrementor = None
	base_parts = []
	inc_parts = []

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Output storing variables reset.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Logic program instantiated.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Entering new one-shot solve call:
('self', LogicProgram(#program base.
#program abstraction_levels(planning_level, mode).
al((1..abstraction_max)).
pl(AL) :- AL = planning_level; al(AL).
sl(AL) :- AL = planning_level; mode = classical; al(AL).
sl(AL) :- AL >= planning_level; AL <= (planning_level+1); mode = refinement; al(AL).
sl(AL) :- AL >= planning_level; AL <= abstraction_max; mode = hierarchical; al(AL).
#program instance_module.
boolean(true;false).
insta_of(AL,CLS,EN) :- entity(CLS,EN); class(AL,CLS); al(AL).
insta_of(AL_3,CLS_1,EN) :- insta_of(AL_2,CLS_2,EN); super_class(CLS_1,CLS_2); entity(CLS_3,EN); class(AL_3,CLS_3); class(AL_1,CLS_1); AL_1 >= AL_2; al(AL_1); al(AL_2); al(AL_3).
insta_of((AL-1),CLS,EN) :- insta_of(AL,CLS,EN); not overridden((AL-1),CLS,EN); class(_,CLS); al(AL); al((AL-1)).
overridden((AL-1),CLS,EN_1) :- overridden_by((AL-1),CLS,EN_1,EN_2); insta_of(AL,CLS,EN_1); insta_of((AL-1),CLS,EN_2); class(_,CLS); al(AL); al((AL-1)).
overridden_by((AL-1),CLS_3,EN_1,EN_2) :- insta_of(AL,CLS_1,EN_1); insta_of((AL-1),CLS_2,EN_2); insta_of(AL,CLS_3,EN_1); insta_of((AL-1),CLS_3,EN_2); desce_of((AL-1),EN_1,EN_2); override_class(CLS_1,CLS_2,CLS_3); class(_,CLS_1); class(_,CLS_2); class(_,CLS_3); al(AL); al((AL-1)).
state_of(AL,EN,S) :- state(AL,CLS,S); insta_of(AL,CLS,EN); al(AL).
child_of(AL,EN,DESCE) :- ancestry_relation(EN,DESCE); insta_of(AL,_,EN); insta_of(AL,_,DESCE); al(AL).
desce_of(AL,EN,DESCE) :- child_of(AL,EN,DESCE); insta_of(AL,_,EN); insta_of(AL,_,DESCE); al(AL).
desce_of(AL,EN,DESCE_1) :- desce_of(AL,DESCE_2,DESCE_1); desce_of(AL,EN,DESCE_2); insta_of(AL,_,EN); insta_of(AL,_,DESCE_1); insta_of(AL,_,DESCE_2); al(AL).
has_desce(AL,EN) :- desce_of(AL,EN,DESCE); insta_of(AL,_,EN); insta_of(AL,_,DESCE); al(AL).
has_desce(AL,EN,CLS) :- desce_of(AL,EN,DESCE); insta_of(AL,_,EN); insta_of(AL,CLS,DESCE); al(AL).
siblings(AL,DESCE_1,DESCE_2) :- child_of(AL,EN,DESCE_1); child_of(AL,EN,DESCE_2); DESCE_1 != DESCE_2; insta_of(AL,_,EN); insta_of(AL,_,DESCE_1); insta_of(AL,_,DESCE_2); al(AL).
siblings(AL,DESCE_2,DESCE_1) :- siblings(AL,DESCE_1,DESCE_2); insta_of(AL,_,DESCE_1); insta_of(AL,_,DESCE_2); al(AL).
#program state_module(step, start).
{ holds(AL,F,V,step) } :- fluent(AL,inertial,F,V); sl(AL); step = start.
#false :- not 1 = { holds(AL,F,V,step): fluent(AL,_,F,V) }; fluent(AL,_,F,_); sl(AL).
holds(AL,F,V,step) :- holds(AL,F,V,(step-1)); not not holds(AL,F,V,step); fluent(AL,inertial,F,V); sl(AL); step > start.
holds(AL,F,false,step) :- not holds(AL,F,true,step); fluent(AL,defined,F,B); boolean(B); sl(AL).
#program plan_module(step, start, concurrency, achieve_fgoals).
{ occurs(AL,ROBOT,A,step): action(AL,_,ROBOT,A) } :- incomplete_plan((step-1)); pl(AL); step > start.
occurs(AL,ROBOT,step) :- occurs(AL,ROBOT,A,step); action(AL,_,ROBOT,A); pl(AL); step > start.
occurs(AL,step) :- occurs(AL,ROBOT,step); insta_of(AL,robot,ROBOT); pl(AL); step > start.
holds(AL,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V,step); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
holds(AL,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,true,step); not holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,true); not holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,false,step); holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,false); holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- not 1 = { occurs(AL,R,A,step): action(AL,_,ROBOT,A) }; incomplete_plan((step-1)); pl(AL); step > start; concurrency = false.
#false :- not 1 <= { occurs(AL,R,A,step): action(AL,_,ROBOT,A), A != do_nothing }; incomplete_plan((step-1)); pl(AL); step > start; concurrency = true.
#false :- not occurs(AL,ROBOT,(step-1)); occurs(AL,ROBOT,step); insta_of(AL,robot,ROBOT); incomplete_plan((step-1)); pl(AL); step > (start+1); concurrency = true.
has_affect(AL,ROBOT,A,step) :- effect(AL,ROBOT,A,F,V,step); not holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
has_affect(AL,ROBOT,A,step) :- effect(AL,ROBOT,A,F,V); not holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); not has_affect(AL,ROBOT,A,step); action(AL,_,ROBOT,A); A != do_nothing; pl(AL); step > start.
action(AL,sequential,ROBOT,do_nothing) :- insta_of(AL,robot,ROBOT); sl(AL); concurrency = true.
#false :- occurs(AL,ROBOT,A_1,step); occurs(AL,ROBOT,A_2,step); A_1 != A_2; action(AL,_,ROBOT,A_1); action(AL,_,ROBOT,A_2); pl(AL); step > start; concurrency = false.
#false :- occurs(AL,ROBOT,A_1,step); occurs(AL,ROBOT,A_2,step); A_1 != A_2; action(AL,sequential,ROBOT,A_1); action(AL,_,ROBOT,A_2); pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); effect(AL,ROBOT_2,A_2,F,V_2,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; ROBOT_1 != ROBOT_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); effect(AL,ROBOT_2,A_2,F,V_2); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; ROBOT_1 != ROBOT_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1); effect(AL,ROBOT_2,A_2,F,V_2); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; ROBOT_1 != ROBOT_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); precond(AL,ROBOT_2,A_2,F,V_2,true,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); precond(AL,ROBOT_2,A_2,F,V_2,true); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V,step); precond(AL,ROBOT_2,A_2,F,V,false,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V,step); precond(AL,ROBOT_2,A_2,F,V,false); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1); precond(AL,ROBOT_2,A_2,F,V_2,true,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1); precond(AL,ROBOT_2,A_2,F,V_2,true); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V); precond(AL,ROBOT_2,A_2,F,V,false,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V); precond(AL,ROBOT_2,A_2,F,V,false); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#external seq_achieve_fgoals(step). [false]
enforce_achieve_fgoals(step) :- achieve_fgoals = true.
enforce_achieve_fgoals(step) :- 0 <= S; S <= step; seq_achieve_fgoals(S).
goal_satisfied(AL,F,V,true,step) :- final_goal(AL,F,V,true); holds(AL,F,V,step); fluent(AL,_,F,V); pl(AL); enforce_achieve_fgoals(step).
goal_satisfied(AL,F,V,false,step) :- final_goal(AL,F,V,false); not holds(AL,F,V,step); fluent(AL,_,F,V); pl(AL); enforce_achieve_fgoals(step).
incomplete_plan(step) :- final_goal(AL,F,V,B); not goal_satisfied(AL,F,V,B,step); fluent(AL,_,F,V); pl(AL); boolean(B); enforce_achieve_fgoals(step).
sub_goal(AL,ROBOT,A,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V,step); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); AL != 1; step > start.
sub_goal(AL,ROBOT,A,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); AL != 1; step > start.
#program optimisation_module(step, start, minimise_length, minimise_actions, minimise_cost, preempt_pos_fgoals, preempt_neg_fgoals, order_fgoals_achievement).
:~ occurs(AL,step); incomplete_plan((step-1)); pl(AL); step > start; minimise_length = true. [1@3,step]
:~ occurs(AL,ROBOT,A,step); action(AL,_,ROBOT,A); incomplete_plan((step-1)); pl(AL); step > start; minimise_actions = true. [1@2,ROBOT,A,step]
#heuristic occurs(AL,ROBOT,A,step) : action(AL,_,ROBOT,A); effect(AL,ROBOT,A,F,V); fluent(AL,inertial,F,V); final_goal(AL,F,V,true); pl(AL); step > start; preempt_pos_fgoals = true. [10@1,true]
#heuristic occurs(AL,ROBOT,A,step) : action(AL,_,ROBOT,A); effect(AL,ROBOT,A,F,V); fluent(AL,inertial,F,V); final_goal(AL,F,V,false); pl(AL); step > start; preempt_neg_fgoals = true. [10@0,false]
#program check(step).
#external query(step). [false]
#false :- incomplete_plan(step); query(step).
#program conformance_module(step, start, first, last, type, yield).
#external current_last_sgoals(I,step) : sgoals_index(I); yield = true. [false]
include_sgoals(I,step) :- I <= I_L; S <= step; current_last_sgoals(I_L,S); sgoals_index(I).
include_sgoals(I,step) :- sgoals_index(I); yield = false.
sgoals_index((first..last)).
current_sub_goal((AL+1),ROBOT,A,F,V,first,start) :- sub_goal((AL+1),ROBOT,A,F,V,first); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
sub_goal_satisfied((AL+1),ROBOT,A,F,V,I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,(step-1)); holds((AL+1),F,V,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,(step-1)); not sub_goal_satisfied((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); type = sequential; pl(AL).
unachieved_sgoals((AL+1),I_SG,step) :- current_sub_goal_index((AL+1),I_SG,(step-1)); sub_goal((AL+1),ROBOT,A,F,V,I_SG); not sub_goal_satisfied((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,(step-1)); unachieved_sgoals((AL+1),I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); type = simultaneous; pl(AL).
current_sub_goal((AL+1),ROBOT_1,A_1,F_1,V_1,(I_SG+1),step) :- include_sgoals((I_SG+1),step); sub_goal((AL+1),ROBOT_1,A_1,F_1,V_1,(I_SG+1)); current_sub_goal_index((AL+1),I_SG,(step-1)); not current_sub_goal_index((AL+1),I_SG,step); action((AL+1),_,ROBOT_1,A_1); fluent((AL+1),inertial,F_1,V_1); pl(AL).
sgoals_ach_at((AL+1),I_SG,step) :- current_sub_goal_index((AL+1),I_SG,(step-1)); not current_sub_goal_index((AL+1),I_SG,step); pl(AL).
current_sub_goal_index((AL+1),I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
incomplete_plan(step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
#program goal_abstraction_module.
holds(AL,F,V,0) :- final_goal(AL,F,V,true); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
not holds(AL,F,V,0) :- final_goal(AL,F,V,false); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
final_goal(AL,F,V,true) :- holds(AL,F,V,0); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
final_goal(AL,F,V,false) :- not holds(AL,F,V,0); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
{ holds(AL,F,V,0) } :- goal_fluent(AL,F); fluent(AL,inertial,F,V); al(AL).
#false :- not 1 = { holds(AL,F,V,0): fluent(AL,_,F,V) }; goal_fluent(AL,F); fluent(AL,_,F,_); al(AL).
holds(AL,F,false,0) :- not holds(AL,F,true,0); goal_fluent(AL,F); fluent(AL,defined,F,B); boolean(B); al(AL).
#program domain_sorts.
#const abstraction_max = 3.
#const reduc = 3.
#const conde = 2.
#const groun = 1.
class(3,robot).
class(3,armed_robot).
class(3,location).
class(3,room).
class(3,object).
class(3,grounded).
class(3,graspable).
class(3,placeable).
class(3,block).
class(3,surface).
class(3,table).
class(3,colour).
class(3,manipulator_arm).
class(3,grasper).
class(2,door).
class(2,handle).
class(2,configurable).
class(2,extensible).
class(1,cell).
class(1,manipulator_limb).
class(1,manipulator_end).
class(1,side).
super_class(robot,armed_robot).
super_class(location,room).
super_class(location,cell).
super_class(object,robot).
super_class(object,manipulator_arm).
super_class(object,manipulator_limb).
super_class(object,manipulator_end).
super_class(object,table).
super_class(object,side).
super_class(object,block).
super_class(object,grounded).
super_class(grounded,handle).
super_class(configurable,extensible).
super_class(configurable,grasper).
super_class(configurable,door).
super_class(extensible,manipulator_arm).
super_class(extensible,manipulator_limb).
super_class(grasper,manipulator_arm).
super_class(grasper,manipulator_end).
super_class(graspable,block).
super_class(graspable,handle).
super_class(placeable,block).
super_class(surface,table).
super_class(surface,side).
super_class(surface,block).
override_class(manipulator_arm,manipulator_end,grasper).
override_class(manipulator_arm,manipulator_limb,extensible).
override_class(room,cell,location).
override_class(table,side,surface).
state(AL,extensible,extended) :- AL < reduc; al(AL).
state(AL,extensible,retracted) :- AL < reduc; al(AL).
state(AL,manipulator_end,aligned_with(OBJ)) :- insta_of(AL,graspable,OBJ); class(AL,manipulator_end); AL < reduc; al(AL).
state(AL,manipulator_end,aligned_with(nothing)) :- AL < reduc; al(AL).
state(AL,door,open) :- AL < reduc; al(AL).
state(AL,door,closed) :- AL < reduc; al(AL).
static(AL,connected(L_1,L_2)) :- insta_of(AL,location,L_1); insta_of(AL,location,L_2); al(AL).
static(AL,connected_by_door(D,L_1,L_2)) :- insta_of(AL,door,D); insta_of(AL,location,L_1); insta_of(AL,location,L_2); AL < reduc; al(AL).
static(AL,in(OBJ,L)) :- insta_of(AL,object,OBJ); insta_of(AL,grounded,OBJ); insta_of(AL,location,L); AL < reduc; al(AL).
static(AL,colour_of(BLOCK,COLOUR)) :- insta_of(AL,block,BLOCK); insta_of(AL,colour,COLOUR); al(AL).
fluent(AL_1,inertial,in(OBJ),L) :- insta_of(AL_1,location,L); insta_of(AL_2,object,OBJ); OBJ != nothing; not insta_of(AL_2,grounded,OBJ); sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,on(OBJ),SURFACE) :- OBJ != SURFACE; insta_of(AL_1,surface,SURFACE); insta_of(AL_2,placeable,OBJ); sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,grasping(DESC),OBJ) :- insta_of(AL_1,graspable,OBJ); insta_of(AL_2,grasper,DESC); sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,configuration(DESC),STATE) :- state_of(AL_1,DESC,STATE); insta_of(AL_2,configurable,DESC); AL_1 < reduc; AL_2 < reduc; sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,configuration(D),STATE) :- state_of(AL_1,D,STATE); insta_of(AL_2,door,D); AL_1 < reduc; AL_2 < reduc; sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL,defined,tower_base(BASE),B) :- insta_of(AL,block,BASE); sl(AL); boolean(B).
fluent(AL,defined,in_tower(BASE,BLOCK),B) :- insta_of(AL,block,BASE); insta_of(AL,block,BLOCK); sl(AL); boolean(B).
fluent(AL,defined,unordered_tower(BASE),B) :- insta_of(AL,block,BASE); sl(AL); boolean(B).
fluent(AL,defined,complete(COLOUR),B) :- insta_of(AL,colour,COLOUR); sl(AL); boolean(B).
action(AL,sequential,ROBO,move(L)) :- insta_of(AL,robot,ROBO); insta_of(AL,location,L); sl(AL).
action(AL,concurrent,ROBO,grasp(DESC,OBJ)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; sl(AL).
action(AL,concurrent,ROBO,release(DESC,OBJ)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; sl(AL).
action(AL,concurrent,ROBO,configure(DESC,STATE)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,configurable,DESC); state_of(AL,DESC,STATE); AL < reduc; sl(AL).
action(AL,concurrent,ROBO,put(DESC,OBJ,SURFACE)) :- OBJ != SURFACE; SURFACE != nothing; desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); sl(AL).
action(AL,concurrent,ROBO,lift(DESC,OBJ)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); sl(AL).
action(AL,sequential,ROBO,actuate(DESC,D)) :- insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,door,D); AL < reduc; sl(AL).
#program action_effects(t).
effect(AL,ROBO,move(L),in(ROBO),L) :- action(AL,_,ROBO,move(L)); fluent(AL,inertial,in(ROBO),L); insta_of(AL,robot,ROBO); insta_of(AL,location,L); pl(AL).
effect(AL,ROBO,grasp(DESC,OBJ),grasping(DESC),OBJ) :- action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; pl(AL).
effect(AL,ROBO,release(DESC,OBJ),grasping(DESC),nothing) :- action(AL,_,ROBO,release(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); pl(AL).
effect(AL,ROBO,release(END,OBJ),configuration(END),aligned_with(nothing)) :- action(AL,_,ROBO,release(END,OBJ)); fluent(AL,inertial,configuration(END),aligned_with(nothing)); desce_of(AL,ROBO,END); insta_of(AL,armed_robot,ROBO); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); state_of(AL,END,aligned_with(nothing)); AL < reduc; pl(AL).
effect(AL,ROBO,configure(DESC,STATE),configuration(DESC),STATE) :- action(AL,_,ROBO,configure(DESC,STATE)); fluent(AL,inertial,configuration(DESC),STATE); desce_of(AL,ROBO,DESC); insta_of(AL,robot,ROBO); insta_of(AL,configurable,DESC); state_of(AL,DESC,STATE); AL < reduc; pl(AL).
effect(AL,ROBO,configure(ARM,retracted),configuration(END),aligned_with(nothing),t) :- holds(AL,grasping(END),nothing,(t-1)); action(AL,_,ROBO,configure(ARM,retracted)); fluent(AL,inertial,configuration(END),aligned_with(nothing)); desce_of(AL,ROBO,ARM); desce_of(AL,ROBO,END); siblings(AL,ARM,END); insta_of(AL,armed_robot,ROBO); insta_of(AL,extensible,ARM); insta_of(AL,manipulator_end,END); state_of(AL,END,aligned_with(nothing)); AL < reduc; pl(AL).
effect(AL,ROBO,put(DESC,OBJ,SURFACE),on(OBJ),SURFACE) :- action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,on(OBJ),SURFACE); OBJ != SURFACE; SURFACE != nothing; desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); pl(AL).
effect(AL,ROBO,lift(DESC,OBJ),on(OBJ),nothing) :- action(AL,_,ROBO,lift(DESC,OBJ)); fluent(AL,inertial,on(OBJ),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); pl(AL).
effect(AL,ROBO,actuate(DESC,D),configuration(D),STATE_1,t) :- holds(AL,configuration(D),STATE_2,(t-1)); fluent(AL,inertial,configuration(D),STATE_1); fluent(AL,inertial,configuration(D),STATE_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,door,D); state_of(AL,D,STATE_1); state_of(AL,D,STATE_2); STATE_1 != STATE_2; AL < reduc; pl(AL).
#program action_preconditions(t).
1 = { precond(AL,ROBO,move(P_2),in(ROBO),P_1,true,t): is(AL,connected(P_1,P_2)), fluent(AL,inertial,in(ROBO),P_1), static(AL,connected(P_1,P_2)), P_1 != P_2, insta_of(AL,location,P_1) } :- action(AL,_,ROBO,move(P_2)); insta_of(AL,robot,ROBO); insta_of(AL,location,P_2); AL < reduc; pl(AL).
precond(AL,ROBO,move(L_2),configuration(D),open,true,t) :- holds(AL,in(ROBO),L_1,(t-1)); is(AL,connected_by_door(D,L_1,L_2)); L_1 != L_2; action(AL,_,ROBO,move(L_2)); fluent(AL,inertial,configuration(D),open); fluent(AL,_,in(ROBO),L_1); static(AL,connected_by_door(D,L_1,L_2)); insta_of(AL,robot,ROBO); insta_of(AL,location,L_1); insta_of(AL,location,L_2); insta_of(AL,door,D); AL < reduc; pl(AL).
1 = { precond(AL,ROBO,actuate(COMP,D),grasping(COMP),H,true,t): desce_of(AL,D,H), insta_of(AL,handle,H), action(AL,_,ROBO,actuate(COMP,D)), fluent(AL,inertial,grasping(COMP),H) } :- desce_of(AL,ROBO,COMP); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,COMP); insta_of(AL,door,D); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),in(ROBO),L,true) :- is(AL,in(OBJ,L)); action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,in(ROBO),L); static(AL,in(OBJ,L)); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,grounded,OBJ); insta_of(AL,location,L); AL < reduc; pl(AL).
precond(AL,ROBO,move(L),configuration(DESC),retracted,true) :- action(AL,_,ROBO,move(L)); fluent(AL,inertial,configuration(DESC),retracted); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,extensible,DESC); insta_of(AL,location,L); state_of(AL,DESC,retracted); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),in(OBJ),L,true,t) :- holds(AL,in(ROBO),L,(t-1)); OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,in(OBJ),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),in(ROBO),L,true,t) :- holds(AL,in(OBJ),L,(t-1)); OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,in(OBJ),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),grasping(DESC),nothing,true) :- OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ_1),on(OBJ_2),OBJ_1,false) :- OBJ_1 != OBJ_2; OBJ_1 != nothing; action(AL,_,ROBO,grasp(DESC,OBJ_1)); fluent(AL,inertial,on(OBJ_2),OBJ_1); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ_1); insta_of(AL,surface,OBJ_1); insta_of(AL,placeable,OBJ_2); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),configuration(DESC),extended,true) :- OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,configuration(DESC),extended); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,extensible,DESC); insta_of(AL,graspable,OBJ); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(DESC_1,OBJ),configuration(DESC_2),extended,true) :- OBJ != nothing; action(AL,_,ROBO,grasp(DESC_1,OBJ)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC_1); not insta_of(AL,extensible,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,graspable,OBJ); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(END,OBJ),configuration(END),aligned_with(OBJ),true) :- OBJ != nothing; action(AL,_,ROBO,grasp(END,OBJ)); fluent(AL,inertial,configuration(END),aligned_with(OBJ)); desce_of(AL,ROBO,END); insta_of(AL,armed_robot,ROBO); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); state_of(AL,END,aligned_with(OBJ)); AL < reduc; pl(AL).
precond(AL,ROBO,release(DESC,OBJ),grasping(DESC),OBJ,true) :- OBJ != nothing; action(AL,_,ROBO,release(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); pl(AL).
precond(AL,ROBO,release(DESC,OBJ),configuration(DESC),extended,true) :- OBJ != nothing; action(AL,_,ROBO,release(DESC,OBJ)); fluent(AL,inertial,configuration(DESC),extended); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); state_of(AL,DESC,extended); pl(AL); t > 0.
precond(AL,ROBO,release(DESC_1,OBJ),configuration(DESC_2),extended,true) :- OBJ != nothing; action(AL,_,ROBO,release(DESC_1,OBJ)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC_1); not insta_of(AL,extensible,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,graspable,OBJ); pl(AL).
precond(AL,ROBO,configure(DESC_1,STATE),configuration(DESC_2),extended,true) :- action(AL,_,ROBO,configure(DESC_1,STATE)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); desce_of(AL,ROBO,ARM); child_of(AL,ARM,DESC_1); child_of(AL,ARM,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,configurable,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,manipulator_arm,ARM); state_of(AL,DESC_1,STATE); AL < reduc; pl(AL).
precond(AL,ROBO,configure(DESC,aligned_with(OBJ)),grasping(DESC),nothing,true) :- action(AL,_,ROBO,configure(DESC,aligned_with(OBJ))); fluent(AL,inertial,grasping(DESC),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,manipulator_end,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; state_of(AL,DESC,aligned_with(OBJ)); AL < reduc; pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),in(SURFACE),L,true,t) :- holds(AL,in(ROBO),L,(t-1)); action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,in(SURFACE),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),in(ROBO),L,true,t) :- holds(AL,in(SURFACE),L,(t-1)); action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,in(SURFACE),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,put(DESC,OBJ_1,BLOCK),on(OBJ_2),BLOCK,false) :- OBJ_1 != OBJ_2; action(AL,_,ROBO,put(DESC,OBJ_1,SURFACE)); fluent(AL,inertial,on(OBJ_2),BLOCK); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ_1); insta_of(AL,placeable,OBJ_2); insta_of(AL,block,BLOCK); pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),grasping(DESC),OBJ,true) :- OBJ != SURFACE; OBJ != nothing; SURFACE != nothing; action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); pl(AL).
precond(AL,ROBO_1,put(DESC_1,OBJ_1,OBJ_2),grasping(DESC_2),OBJ_2,false) :- OBJ_1 != OBJ_2; DESC_1 != DESC_2; action(AL,_,ROBO,put(DESC_1,OBJ_1,OBJ_2)); fluent(AL,inertial,grasping(DESC_2),OBJ_2); desce_of(AL,ROBO_1,DESC_1); desce_of(AL,ROBO_2,DESC_2); insta_of(AL,armed_robot,ROBO_1); insta_of(AL,armed_robot,ROBO_2); insta_of(AL,grasper,DESC_1); insta_of(AL,grasper,DESC_2); insta_of(AL,placeable,OBJ_1); insta_of(AL,surface,OBJ_2); insta_of(AL,graspable,OBJ_2); pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),configuration(DESC),extended,true) :- action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,configuration(DESC),extended); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,extensible,DESC); insta_of(AL,graspable,OBJ); insta_of(AL,surface,SURFACE); AL < reduc; pl(AL).
precond(AL,ROBO,put(DESC_1,OBJ,SURFACE),configuration(DESC_2),extended,true) :- action(AL,_,ROBO,put(DESC_1,OBJ,SURFACE)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC_1); not insta_of(AL,extensible,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,graspable,OBJ); insta_of(AL,surface,SURFACE); AL < reduc; pl(AL).
precond(AL,ROBO,lift(DESC,OBJ_1),on(OBJ_2),OBJ_1,false) :- OBJ_1 != OBJ_2; action(AL,_,ROBO,lift(DESC,OBJ_1)); fluent(AL,inertial,on(OBJ_2),OBJ_1); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ_1); insta_of(AL,surface,OBJ_1); insta_of(AL,placeable,OBJ_2); pl(AL).
precond(AL,ROBO,lift(DESC,OBJ),grasping(DESC),OBJ,true) :- OBJ != SURFACE; action(AL,_,ROBO,lift(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,surface,SURFACE); pl(AL).
#program variable_relations(t).
#false :- holds(AL,grasping(DESC),OBJ,t); holds(AL,in(ROBO),L,t); not holds(AL,in(OBJ),L,t): not insta_of(AL,grounded,OBJ), fluent(AL,inertial,in(OBJ),L); not is(AL,in(OBJ,L)): insta_of(AL,grounded,OBJ), static(AL,in(OBJ,L)); fluent(AL,inertial,grasping(DESC),OBJ); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,location,L); sl(AL).
#false :- holds(AL,configuration(END),aligned_with(OBJ),t); holds(AL,in(ROBO),L,t); not holds(AL,in(OBJ),L,t): not insta_of(AL,grounded,OBJ), fluent(AL,inertial,in(OBJ),L); not is(AL,in(OBJ,L)): insta_of(AL,grounded,OBJ), static(AL,in(OBJ,L)); fluent(AL,inertial,configuration(END),aligned_with(OBJ)); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,END); insta_of(AL,robot,ROBO); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,location,L); state_of(AL,END,aligned_with(OBJ)); sl(AL).
#false :- holds(AL,grasping(END),OBJ,t); not holds(AL,configuration(END),aligned_with(OBJ),t); fluent(AL,inertial,grasping(END),OBJ); fluent(AL,inertial,configuration(END),aligned_with(OBJ)); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); OBJ != nothing; state_of(AL,END,aligned_with(OBJ)); sl(AL).
#false :- holds(AL,grasping(DESC),OBJ_1,t); holds(AL,on(OBJ_2),OBJ_1,t); fluent(AL,inertial,grasping(DESC),OBJ_1); fluent(AL,inertial,on(OBJ_2),OBJ_1); desce_of(AL,ROBO,DESC); insta_of(AL,robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ_1); OBJ_1 != nothing; insta_of(AL,surface,OBJ_1); insta_of(AL,placeable,OBJ_2); sl(AL).
#false :- holds(AL,on(OBJ),SURFACE,t); holds(AL,in(SURFACE),L,t); not holds(AL,in(OBJ),L,t); fluent(AL,inertial,on(OBJ),SURFACE); fluent(AL,inertial,in(SURFACE),L); fluent(AL,inertial,in(OBJ),L); insta_of(AL,location,L); insta_of(AL,location,L); insta_of(AL,surface,SURFACE); insta_of(AL,object,OBJ); sl(AL).
#false :- holds(AL,on(BLOCK_1),BLOCK_2,t); holds(AL,on(BLOCK_2),nothing,t); fluent(AL,inertial,on(BLOCK_1),BLOCK_2); fluent(AL,inertial,on(BLOCK_2),nothing); insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); sl(AL).
#false :- holds(AL,on(BLOCK_1),BLOCK_3,t); holds(AL,on(BLOCK_2),BLOCK_3,t); fluent(AL,inertial,on(BLOCK_1),BLOCK_3); fluent(AL,inertial,on(BLOCK_2),BLOCK_3); BLOCK_1 != BLOCK_2; insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); insta_of(AL,block,BLOCK_3); sl(AL).
holds(AL,tower_base(BASE),true,t) :- holds(AL,on(BASE),TABLE,t); fluent(AL,defined,tower_base(BASE),true); fluent(AL,inertial,on(BASE),TABLE); insta_of(AL,block,BASE); insta_of(AL,table,TABLE); sl(AL).
holds(AL,tower_base(BASE),true,t) :- holds(AL,on(BASE),SURFACE,t); fluent(AL,defined,tower_base(BASE),true); fluent(AL,inertial,on(BASE),SURFACE); desce_of(AL,TABLE,SURFACE); insta_of(AL,block,BASE); insta_of(AL,surface,SURFACE); insta_of(AL,table,TABLE); sl(AL).
holds(AL,in_tower(BASE,BASE),true,t) :- holds(AL,tower_base(BASE),true,t); fluent(AL,defined,in_tower(BASE,BASE),true); fluent(AL,defined,tower_base(BASE),true); insta_of(AL,block,BASE); sl(AL).
holds(AL,in_tower(BLOCK_1,BLOCK_2),true,t) :- holds(AL,on(BLOCK_2),BLOCK_3,t); holds(AL,in_tower(BLOCK_1,BLOCK_3),true,t); fluent(AL,defined,in_tower(BLOCK_1,BLOCK_2),true); fluent(AL,defined,in_tower(BLOCK_1,BLOCK_3),true); fluent(AL,inertial,on(BLOCK_2),BLOCK_3); BLOCK_1 != BLOCK_2; insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); insta_of(AL,block,BLOCK_3); sl(AL).
holds(AL,unordered_tower(BASE),true,t) :- holds(AL,on(BLOCK_1),BLOCK_2,t); holds(AL,in_tower(BASE,BLOCK_1),true,t); holds(AL,in_tower(BASE,BLOCK_2),true,t); holds(AL,tower_base(BASE),true,t); fluent(AL,defined,unordered_tower(BASE),true); fluent(AL,defined,in_tower(BASE,BLOCK_1),true); fluent(AL,defined,in_tower(BASE,BLOCK_2),true); fluent(AL,defined,tower_base(BASE),true); fluent(AL,inertial,on(BLOCK_1),BLOCK_2); BLOCK_1 = (block,N_1); number(N_1); BLOCK_2 = (block,N_2); number(N_2); BLOCK_1 != BLOCK_2; N_1 > N_2; insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); insta_of(AL,block,BASE); sl(AL).
holds(AL,complete(COLOUR),true,t) :- N = #count { BLOCK: holds(AL,in_tower(BASE,BLOCK),true,t), is(AL,colour_of(BLOCK,COLOUR)), fluent(AL,defined,in_tower(BASE,BLOCK),true), static(AL,colour_of(BLOCK,COLOUR)), insta_of(AL,block,BLOCK) }; N = #count { BLOCK: is(AL,colour_of(BLOCK,COLOUR)), static(AL,colour_of(BLOCK,COLOUR)), insta_of(AL,block,BLOCK) }; holds(AL,unordered_tower(BASE),false,t); holds(AL,tower_base(BASE),true,t); fluent(AL,defined,unordered_tower(BASE),true); fluent(AL,defined,tower_base(BASE),true); is(AL,colour_of(BASE,COLOUR)); static(AL,colour_of(BASE,COLOUR)); insta_of(AL,colour,COLOUR); insta_of(AL,block,BASE); sl(AL).
#program abstraction_mappings(t).
is(AL_1,connected(L_1,L_2)) :- is(AL_2,connected(L_1_C,L_2_C)); static(AL_1,connected(L_1,L_2)); static(AL_2,connected(L_1_C,L_2_C)); L_1 != L_2; desce_of(AL_2,L_1,L_1_C); desce_of(AL_2,L_2,L_2_C); insta_of(AL_1,location,L_1); insta_of(AL_1,location,L_2); insta_of(AL_2,location,L_1_C); insta_of(AL_2,location,L_2_C); al(AL_1); al(AL_2); AL_1 >= AL_2.
is(AL_1,connected(L_1,L_2)) :- is(AL_2,connected(L_1,L_2)); static(AL_1,connected(L_1,L_2)); static(AL_2,connected(L_1,L_2)); L_1 != L_2; insta_of(AL_1,location,L_1); insta_of(AL_1,location,L_2); insta_of(AL_2,location,L_1); insta_of(AL_2,location,L_2); al(AL_1); al(AL_2); AL_1 >= AL_2.
is(AL_1,connected_by_door(D,L_1,L_2)) :- is(AL_2,connected_by_door(D,L_1_C,L_2_C)); static(AL_1,connected_by_door(D,L_1,L_2)); static(AL_2,connected_by_door(D,L_1_C,L_2_C)); L_1 != L_2; desce_of(AL_2,L_1,L_1_C); desce_of(AL_2,L_2,L_2_C); insta_of(AL_1,door,D); insta_of(AL_2,door,D); insta_of(AL_1,location,L_1); insta_of(AL_1,location,L_2); insta_of(AL_2,location,L_1_C); insta_of(AL_2,location,L_2_C); al(AL_1); al(AL_2); AL_1 >= AL_2.
is(AL_1,in(OBJ,L_1)) :- is(AL_2,in(OBJ,L_2)); static(AL_1,in(OBJ,L_1)); static(AL_2,in(OBJ,L_2)); desce_of(AL_2,L_1,L_2); insta_of(AL_1,location,L_1); insta_of(AL_1,object,OBJ); insta_of(AL_1,grounded,OBJ); insta_of(AL_1,location,L_1); insta_of(AL_2,location,L_2); al(AL_1); al(AL_2); AL_1 >= AL_2.
holds(AL_1,in(OBJ),L_1,t) :- holds(AL_2,in(OBJ),L_2,t); fluent(AL_1,inertial,in(OBJ),L_1); fluent(AL_2,inertial,in(OBJ),L_2); desce_of(AL_2,L_1,L_2); insta_of(AL_1,location,L_1); insta_of(AL_2,location,L_2); insta_of(AL_3,object,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
holds(AL_1,in(OBJ),L,t) :- holds(AL_2,in(OBJ),L,t); fluent(AL_1,inertial,in(OBJ),L); fluent(AL_2,inertial,in(OBJ),L); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,object,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
holds(AL_1,in(DESC),L,t) :- holds(AL_2,in(OBJ),L,t); fluent(AL_1,inertial,in(DESC),L); fluent(AL_2,inertial,in(OBJ),L); desce_of(AL_2,OBJ,DESC); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,object,OBJ); insta_of(AL_4,_,DESC); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_2; sl(AL_4); AL_4 >= AL_1.
holds(AL_1,in(OBJ),L,t) :- holds(AL_2,in(DESC),L,t); fluent(AL_1,inertial,in(OBJ),L); fluent(AL_2,inertial,in(DESC),L); desce_of(AL_2,OBJ,DESC); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,object,OBJ); insta_of(AL_4,_,DESC); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_2.
holds(AL_1,in(OBJ),L,t) :- holds(AL_2,in(ROBO),L,t); holds(AL_3,grasping(DESC),OBJ,t); fluent(AL_1,inertial,in(OBJ),L); fluent(AL_2,inertial,in(ROBO),L); fluent(AL_3,inertial,grasping(DESC),OBJ); desce_of(AL_2,ROBO,DESC); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,graspable,OBJ); OBJ != nothing; insta_of(AL_4,grasper,DESC); insta_of(AL_5,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_3; sl(AL_5); AL_5 >= AL_3.
holds(AL_1,grasping(DESC),OBJ_1,t) :- holds(AL_2,grasping(DESC),OBJ_2,t); fluent(AL_1,inertial,grasping(DESC),OBJ_1); fluent(AL_2,inertial,grasping(DESC),OBJ_2); desce_of(AL_2,ROBO,DESC); desce_of(AL_2,OBJ_1,OBJ_2); insta_of(AL_1,graspable,OBJ_1); insta_of(AL_2,graspable,OBJ_2); insta_of(AL_3,grasper,DESC); insta_of(AL_4,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_1.
holds(AL_1,grasping(DESC_1),OBJ,t) :- holds(AL_2,grasping(DESC_2),OBJ,t); fluent(AL_1,inertial,grasping(DESC_1),OBJ); fluent(AL_2,inertial,grasping(DESC_2),OBJ); desce_of(AL_2,ROBO,DESC_1); desce_of(AL_2,ROBO,DESC_2); desce_of(AL_2,DESC_1,DESC_2); insta_of(AL_1,graspable,OBJ); insta_of(AL_2,graspable,OBJ); insta_of(AL_3,grasper,DESC_1); insta_of(AL_4,grasper,DESC_2); insta_of(AL_5,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_2; sl(AL_5); AL_5 >= AL_1.
holds(AL_1,grasping(DESC),OBJ,t) :- holds(AL_2,grasping(DESC),OBJ,t); fluent(AL_1,inertial,grasping(DESC),OBJ); fluent(AL_2,inertial,grasping(DESC),OBJ); desce_of(AL_2,ROBO,DESC); insta_of(AL_1,graspable,OBJ); insta_of(AL_2,graspable,OBJ); insta_of(AL_3,grasper,DESC); insta_of(AL_4,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_1; boolean(B).
holds(AL_1,configuration(DESC_1),STATE,t) :- holds(AL_2,configuration(DESC_2),STATE,t); fluent(AL_1,inertial,configuration(DESC_1),STATE); fluent(AL_2,inertial,configuration(DESC_2),STATE); desce_of(AL_2,DESC_1,DESC_2); state_of(AL_1,DESC_1,STATE); state_of(AL_2,DESC_2,STATE); insta_of(AL_1,configurable,DESC_1); insta_of(AL_2,configurable,DESC_2); sl(AL_1); sl(AL_2); AL_1 >= AL_2.
holds(AL_1,configuration(DESC),STATE,t) :- holds(AL_2,configuration(DESC),STATE,t); fluent(AL_1,inertial,configuration(DESC),STATE); fluent(AL_2,inertial,configuration(DESC),STATE); state_of(AL_1,DESC,STATE); state_of(AL_2,DESC,STATE); insta_of(AL_1,configurable,DESC); insta_of(AL_2,configurable,DESC); sl(AL_1); sl(AL_2); AL_1 >= AL_2.
holds(AL_1,on(OBJ),SURFACE_1,t) :- holds(AL_2,on(OBJ),SURFACE_2,t); fluent(AL_1,inertial,on(OBJ),SURFACE_1); fluent(AL_2,inertial,on(OBJ),SURFACE_2); desce_of(AL_2,SURFACE_1,SURFACE_2); insta_of(AL_1,surface,SURFACE_1); insta_of(AL_2,surface,SURFACE_2); insta_of(AL_3,placeable,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
holds(AL_1,on(OBJ),SURFACE,t) :- holds(AL_2,on(OBJ),SURFACE,t); fluent(AL_1,inertial,on(OBJ),SURFACE); fluent(AL_2,inertial,on(OBJ),SURFACE); insta_of(AL_1,surface,SURFACE); insta_of(AL_2,surface,SURFACE); insta_of(AL_3,placeable,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
#program static_state.
is(1,connected((starting_room,1),(hallway,1))).
is(1,connected((store_room,1),(hallway,0))).
is(1,connected((hallway,2),(puzzle_room,0))).
is(1,connected_by_door(store_room_door,(store_room,1),(hallway,0))).
is(1,connected_by_door(puzzle_room_door,(hallway,2),(puzzle_room,0))).
is(1,in(store_room_door_handle_inner,(store_room,1))).
is(1,in(store_room_door_handle_outer,(hallway,0))).
is(1,in(starting_room_door_handle_inner,(starting_room,1))).
is(1,in(starting_room_door_handle_outer,(hallway,1))).
is(1,in(puzzle_room_door_handle_inner,(puzzle_room,0))).
is(1,in(puzzle_room_door_handle_outer,(hallway,2))).
is(AL,colour_of((BLOCK,N),red)) :- static(AL,colour_of((BLOCK,N),red)); insta_of(AL,block,(BLOCK,N)); N <= 3; al(AL).
is(AL,colour_of((BLOCK,N),blue)) :- static(AL,colour_of((BLOCK,N),blue)); insta_of(AL,block,(BLOCK,N)); N > 3; N <= 6; al(AL).
is(1,connected((A,X_1),(A,X_2))) :- insta_of(1,cell,(A,X_1)); insta_of(1,cell,(A,X_2)); X_2 = (X_1+1).
is(1,connected(C_1,C_2)) :- is(1,connected(C_2,C_1)); insta_of(1,cell,C_1); insta_of(1,cell,C_2).
is(1,connected_by_door(D,C_1,C_2)) :- is(1,connected_by_door(D,C_2,C_1)); insta_of(1,door,D); insta_of(1,cell,C_1); insta_of(1,cell,C_2).
#program initial_state.
holds(1,in(talos),(starting_room,0),0).
holds(AL,grasping(DESC),nothing,0) :- fluent(AL,inertial,grasping(DESC),nothing); insta_of(AL,grasper,DESC); al(AL).
holds(AL,configuration(DESC),retracted,0) :- fluent(AL,inertial,configuration(DESC),retracted); insta_of(AL,extensible,DESC); sl(AL).
holds(1,configuration(END),aligned_with(nothing),0) :- fluent(AL,inertial,configuration(END),aligned_with(nothing)); insta_of(AL,manipulator_end,END); state_of(AL,END,aligned_with(nothing)); sl(AL).
holds(1,configuration(DOOR),closed,0) :- fluent(AL,inertial,configuration(DOOR),closed); insta_of(AL,door,DOOR); state_of(AL,DOOR,closed); sl(AL).
holds(1,in(puzzle_room_table),(puzzle_room,1),0).
holds(1,on((block,1)),puzzle_room_table_left,0).
holds(1,on((block,2)),puzzle_room_table_right,0).
holds(1,on((block,3)),(block,1),0).
holds(1,in((block,4)),(store_room,0),0).
holds(1,in((block,5)),(store_room,0),0).
holds(1,in((block,6)),(store_room,0),0).
holds(1,on((block,4)),nothing,0).
holds(1,on((block,5)),nothing,0).
holds(1,on((block,6)),nothing,0).
#program goal_state.
goal_fluent(AL,complete(COLOUR)) :- insta_of(AL,colour,COLOUR); al(AL).
goal_fluent(AL,on((block,3))) :- al(AL).
goal_fluent(AL,on((block,6))) :- al(AL).
final_goal(AL,complete(COLOUR),true,true) :- insta_of(AL,colour,COLOUR); al(AL).
final_goal(1,on((block,3)),puzzle_room_table_left,true).
final_goal(1,on((block,6)),puzzle_room_table_right,true).
#program entities.
entity(armed_robot,talos).
entity(manipulator_arm,manipulator_arm_1).
entity(manipulator_limb,manipulator_limb_1).
entity(manipulator_end,manipulator_end_1).
entity(manipulator_arm,manipulator_arm_2).
entity(manipulator_limb,manipulator_limb_2).
entity(manipulator_end,manipulator_end_2).
number((1..6)).
entity(block,(block,N)) :- number(N).
entity(room,starting_room).
entity(room,store_room).
entity(room,puzzle_room).
entity(room,hallway).
x((0..3)).
size(starting_room,2).
size(store_room,2).
size(hallway,3).
size(puzzle_room,2).
entity(cell,(ROOM,X)) :- entity(room,ROOM); size(ROOM,MAX); X < MAX; x(X).
entity(door,store_room_door).
entity(door,starting_room_door).
entity(door,puzzle_room_door).
entity(handle,store_room_door_handle_inner).
entity(handle,store_room_door_handle_outer).
entity(handle,starting_room_door_handle_inner).
entity(handle,starting_room_door_handle_outer).
entity(handle,puzzle_room_door_handle_inner).
entity(handle,puzzle_room_door_handle_outer).
entity(table,puzzle_room_table).
entity(side,puzzle_room_table_left).
entity(side,puzzle_room_table_right).
entity(colour,red).
entity(colour,blue).
entity(surface,nothing).
entity(graspable,nothing).
ancestry_relation(talos,manipulator_arm_1).
ancestry_relation(talos,manipulator_arm_2).
ancestry_relation(manipulator_arm_1,manipulator_limb_1).
ancestry_relation(manipulator_arm_2,manipulator_limb_2).
ancestry_relation(manipulator_arm_1,manipulator_end_1).
ancestry_relation(manipulator_arm_2,manipulator_end_2).
ancestry_relation(ROOM,(ROOM,X)) :- entity(room,ROOM); entity(cell,(ROOM,X)); x(X).
ancestry_relation(store_room_door,store_room_door_handle_inner).
ancestry_relation(store_room_door,store_room_door_handle_outer).
ancestry_relation(starting_room_door,starting_room_door_handle_inner).
ancestry_relation(starting_room_door,starting_room_door_handle_outer).
ancestry_relation(puzzle_room_door,puzzle_room_door_handle_inner).
ancestry_relation(puzzle_room_door,puzzle_room_door_handle_outer).
ancestry_relation(puzzle_room_table,puzzle_room_table_left).
ancestry_relation(puzzle_room_table,puzzle_room_table_right)., Main #1 || Generate Initial States #1))
	('solver_options', ['--models=2', '--parallel-mode=6,compete', '--warn=none', '--enum-mode=auto'])
	('assumptions', [])
	('context', None)
	('solve_incrementor', None)
	('base_parts', [('entities', []), ('static_state', []), ('initial_state', []), ('abstraction_levels', [1, 'hierarchical']), ('instance_module', []), ('state_module', [0, 0]), ('domain_sorts', []), ('variable_relations', [0]), ('abstraction_mappings', [0])])
	('inc_parts', [IncPart(name='step', args=['#inc'], range_=None)])
	('incremental', False)

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Setting input storing variables:
	solver_options = ['--models=2', '--parallel-mode=6,compete', '--warn=none', '--enum-mode=auto']
	assumptions = []
	context = None
	incrementor = None
	base_parts = [('entities', []), ('static_state', []), ('initial_state', []), ('abstraction_levels', [1, 'hierarchical']), ('instance_module', []), ('state_module', [0, 0]), ('domain_sorts', []), ('variable_relations', [0]), ('abstraction_mappings', [0])]
	inc_parts = [IncPart(name='step', args=['#inc'], range_=None)]

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Output storing variables reset.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Program building started :: Processing 336 rules

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Program building completed in 0.002175799999999839s

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Running one-shot ground and solve of program parts:
[BasePart(name='entities', args=[]), BasePart(name='static_state', args=[]), BasePart(name='initial_state', args=[]), BasePart(name='abstraction_levels', args=[1, 'hierarchical']), BasePart(name='instance_module', args=[]), BasePart(name='state_module', args=[0, 0]), BasePart(name='domain_sorts', args=[]), BasePart(name='variable_relations', args=[0]), BasePart(name='abstraction_mappings', args=[0])]

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Grounding program parts:
[('entities', []), ('static_state', []), ('initial_state', []), ('abstraction_levels', [Number(1), Function('hierarchical', [], True)]), ('instance_module', []), ('state_module', [Number(0), Number(0)]), ('domain_sorts', []), ('variable_relations', [Number(0)]), ('abstraction_mappings', [Number(0)])]

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Grounding completed in 0.099946s.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Solving program.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Model found:
Model :: Total atoms = 2731, Cost = (), Optimality proven = False, Number = 1, Thread ID = 0, Model type = ModelType.StableModel

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Solving completed in 0.018643s with result Satisfiable.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Freeing held grounding...

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Setting input storing variables:
	solver_options = []
	assumptions = []
	context = None
	incrementor = None
	base_parts = []
	inc_parts = []

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Held grounding freed.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Initial States #1 >> Returning from standard solve call:
Result :: SATISFIABLE : SEARCH EXHAUSTED : Total models = 1
Statistics :: Grounding = 0.099946s, Solving = 0.018643s, Total = 0.118589s, Memory = (RSS = 56, VMS = 51)
Final Model :: Total atoms = 2731, Cost = (), Optimality proven = False, Number = 1, Thread ID = 0, Model type = ModelType.StableModel

[09-09-2021_16-35-07] DEBUG :: ASH Planner Main #1 >> Initial states generated successfully:
Result :: SATISFIABLE : SEARCH EXHAUSTED
Statistics :: Grounding = 0.099946s, Solving = 0.018643s, Total = 0.118589s, Memory = (RSS = 56, VMS = 51)
Model :: Total atoms = 2731, Cost = (), Optimality proven = False, Number = 1, Thread ID = 0, Model type = ModelType.StableModel

[09-09-2021_16-35-07] DEBUG :: ASH Planner Main #1 >> 

          ========================================          
            Initial state at abstraction level 3            
          ========================================          

holds(3, complete(blue), false, 0)
holds(3, complete(red), false, 0)
holds(3, grasping(manipulator_arm_1), nothing, 0)
holds(3, grasping(manipulator_arm_2), nothing, 0)
holds(3, in((block,1)), puzzle_room, 0)
holds(3, in((block,2)), puzzle_room, 0)
holds(3, in((block,3)), puzzle_room, 0)
holds(3, in((block,4)), store_room, 0)
holds(3, in((block,5)), store_room, 0)
holds(3, in((block,6)), store_room, 0)
holds(3, in(manipulator_arm_1), starting_room, 0)
holds(3, in(manipulator_arm_2), starting_room, 0)
holds(3, in(puzzle_room_table), puzzle_room, 0)
holds(3, in(talos), starting_room, 0)
holds(3, in_tower((block,1),(block,1)), true, 0)
holds(3, in_tower((block,1),(block,2)), false, 0)
holds(3, in_tower((block,1),(block,3)), true, 0)
holds(3, in_tower((block,1),(block,4)), false, 0)
holds(3, in_tower((block,1),(block,5)), false, 0)
holds(3, in_tower((block,1),(block,6)), false, 0)
holds(3, in_tower((block,2),(block,1)), false, 0)
holds(3, in_tower((block,2),(block,2)), true, 0)
holds(3, in_tower((block,2),(block,3)), false, 0)
holds(3, in_tower((block,2),(block,4)), false, 0)
holds(3, in_tower((block,2),(block,5)), false, 0)
holds(3, in_tower((block,2),(block,6)), false, 0)
holds(3, in_tower((block,3),(block,1)), false, 0)
holds(3, in_tower((block,3),(block,2)), false, 0)
holds(3, in_tower((block,3),(block,3)), false, 0)
holds(3, in_tower((block,3),(block,4)), false, 0)
holds(3, in_tower((block,3),(block,5)), false, 0)
holds(3, in_tower((block,3),(block,6)), false, 0)
holds(3, in_tower((block,4),(block,1)), false, 0)
holds(3, in_tower((block,4),(block,2)), false, 0)
holds(3, in_tower((block,4),(block,3)), false, 0)
holds(3, in_tower((block,4),(block,4)), false, 0)
holds(3, in_tower((block,4),(block,5)), false, 0)
holds(3, in_tower((block,4),(block,6)), false, 0)
holds(3, in_tower((block,5),(block,1)), false, 0)
holds(3, in_tower((block,5),(block,2)), false, 0)
holds(3, in_tower((block,5),(block,3)), false, 0)
holds(3, in_tower((block,5),(block,4)), false, 0)
holds(3, in_tower((block,5),(block,5)), false, 0)
holds(3, in_tower((block,5),(block,6)), false, 0)
holds(3, in_tower((block,6),(block,1)), false, 0)
holds(3, in_tower((block,6),(block,2)), false, 0)
holds(3, in_tower((block,6),(block,3)), false, 0)
holds(3, in_tower((block,6),(block,4)), false, 0)
holds(3, in_tower((block,6),(block,5)), false, 0)
holds(3, in_tower((block,6),(block,6)), false, 0)
holds(3, on((block,1)), puzzle_room_table, 0)
holds(3, on((block,2)), puzzle_room_table, 0)
holds(3, on((block,3)), (block,1), 0)
holds(3, on((block,4)), nothing, 0)
holds(3, on((block,5)), nothing, 0)
holds(3, on((block,6)), nothing, 0)
holds(3, tower_base((block,1)), true, 0)
holds(3, tower_base((block,2)), true, 0)
holds(3, tower_base((block,3)), false, 0)
holds(3, tower_base((block,4)), false, 0)
holds(3, tower_base((block,5)), false, 0)
holds(3, tower_base((block,6)), false, 0)
holds(3, unordered_tower((block,1)), true, 0)
holds(3, unordered_tower((block,2)), false, 0)
holds(3, unordered_tower((block,3)), false, 0)
holds(3, unordered_tower((block,4)), false, 0)
holds(3, unordered_tower((block,5)), false, 0)
holds(3, unordered_tower((block,6)), false, 0)

[09-09-2021_16-35-07] DEBUG :: ASH Planner Main #1 >> 

          ========================================          
            Initial state at abstraction level 2            
          ========================================          

holds(2, complete(blue), false, 0)
holds(2, complete(red), false, 0)
holds(2, configuration(manipulator_arm_1), retracted, 0)
holds(2, configuration(manipulator_arm_2), retracted, 0)
holds(2, configuration(puzzle_room_door), closed, 0)
holds(2, configuration(starting_room_door), closed, 0)
holds(2, configuration(store_room_door), closed, 0)
holds(2, grasping(manipulator_arm_1), nothing, 0)
holds(2, grasping(manipulator_arm_2), nothing, 0)
holds(2, in((block,1)), puzzle_room, 0)
holds(2, in((block,2)), puzzle_room, 0)
holds(2, in((block,3)), puzzle_room, 0)
holds(2, in((block,4)), store_room, 0)
holds(2, in((block,5)), store_room, 0)
holds(2, in((block,6)), store_room, 0)
holds(2, in(manipulator_arm_1), starting_room, 0)
holds(2, in(manipulator_arm_2), starting_room, 0)
holds(2, in(puzzle_room_table), puzzle_room, 0)
holds(2, in(talos), starting_room, 0)
holds(2, in_tower((block,1),(block,1)), true, 0)
holds(2, in_tower((block,1),(block,2)), false, 0)
holds(2, in_tower((block,1),(block,3)), true, 0)
holds(2, in_tower((block,1),(block,4)), false, 0)
holds(2, in_tower((block,1),(block,5)), false, 0)
holds(2, in_tower((block,1),(block,6)), false, 0)
holds(2, in_tower((block,2),(block,1)), false, 0)
holds(2, in_tower((block,2),(block,2)), true, 0)
holds(2, in_tower((block,2),(block,3)), false, 0)
holds(2, in_tower((block,2),(block,4)), false, 0)
holds(2, in_tower((block,2),(block,5)), false, 0)
holds(2, in_tower((block,2),(block,6)), false, 0)
holds(2, in_tower((block,3),(block,1)), false, 0)
holds(2, in_tower((block,3),(block,2)), false, 0)
holds(2, in_tower((block,3),(block,3)), false, 0)
holds(2, in_tower((block,3),(block,4)), false, 0)
holds(2, in_tower((block,3),(block,5)), false, 0)
holds(2, in_tower((block,3),(block,6)), false, 0)
holds(2, in_tower((block,4),(block,1)), false, 0)
holds(2, in_tower((block,4),(block,2)), false, 0)
holds(2, in_tower((block,4),(block,3)), false, 0)
holds(2, in_tower((block,4),(block,4)), false, 0)
holds(2, in_tower((block,4),(block,5)), false, 0)
holds(2, in_tower((block,4),(block,6)), false, 0)
holds(2, in_tower((block,5),(block,1)), false, 0)
holds(2, in_tower((block,5),(block,2)), false, 0)
holds(2, in_tower((block,5),(block,3)), false, 0)
holds(2, in_tower((block,5),(block,4)), false, 0)
holds(2, in_tower((block,5),(block,5)), false, 0)
holds(2, in_tower((block,5),(block,6)), false, 0)
holds(2, in_tower((block,6),(block,1)), false, 0)
holds(2, in_tower((block,6),(block,2)), false, 0)
holds(2, in_tower((block,6),(block,3)), false, 0)
holds(2, in_tower((block,6),(block,4)), false, 0)
holds(2, in_tower((block,6),(block,5)), false, 0)
holds(2, in_tower((block,6),(block,6)), false, 0)
holds(2, on((block,1)), puzzle_room_table, 0)
holds(2, on((block,2)), puzzle_room_table, 0)
holds(2, on((block,3)), (block,1), 0)
holds(2, on((block,4)), nothing, 0)
holds(2, on((block,5)), nothing, 0)
holds(2, on((block,6)), nothing, 0)
holds(2, tower_base((block,1)), true, 0)
holds(2, tower_base((block,2)), true, 0)
holds(2, tower_base((block,3)), false, 0)
holds(2, tower_base((block,4)), false, 0)
holds(2, tower_base((block,5)), false, 0)
holds(2, tower_base((block,6)), false, 0)
holds(2, unordered_tower((block,1)), true, 0)
holds(2, unordered_tower((block,2)), false, 0)
holds(2, unordered_tower((block,3)), false, 0)
holds(2, unordered_tower((block,4)), false, 0)
holds(2, unordered_tower((block,5)), false, 0)
holds(2, unordered_tower((block,6)), false, 0)

[09-09-2021_16-35-07] DEBUG :: ASH Planner Main #1 >> 

          ========================================          
            Initial state at abstraction level 1            
          ========================================          

holds(1, complete(blue), false, 0)
holds(1, complete(red), false, 0)
holds(1, configuration(manipulator_end_1), aligned_with(nothing), 0)
holds(1, configuration(manipulator_end_2), aligned_with(nothing), 0)
holds(1, configuration(manipulator_limb_1), retracted, 0)
holds(1, configuration(manipulator_limb_2), retracted, 0)
holds(1, configuration(puzzle_room_door), closed, 0)
holds(1, configuration(starting_room_door), closed, 0)
holds(1, configuration(store_room_door), closed, 0)
holds(1, grasping(manipulator_arm_1), nothing, 0)
holds(1, grasping(manipulator_arm_2), nothing, 0)
holds(1, grasping(manipulator_end_1), nothing, 0)
holds(1, grasping(manipulator_end_2), nothing, 0)
holds(1, in((block,1)), (puzzle_room,1), 0)
holds(1, in((block,2)), (puzzle_room,1), 0)
holds(1, in((block,3)), (puzzle_room,1), 0)
holds(1, in((block,4)), (store_room,0), 0)
holds(1, in((block,5)), (store_room,0), 0)
holds(1, in((block,6)), (store_room,0), 0)
holds(1, in(manipulator_arm_1), (starting_room,0), 0)
holds(1, in(manipulator_arm_2), (starting_room,0), 0)
holds(1, in(manipulator_end_1), (starting_room,0), 0)
holds(1, in(manipulator_end_2), (starting_room,0), 0)
holds(1, in(manipulator_limb_1), (starting_room,0), 0)
holds(1, in(manipulator_limb_2), (starting_room,0), 0)
holds(1, in(puzzle_room_table), (puzzle_room,1), 0)
holds(1, in(puzzle_room_table_left), (puzzle_room,1), 0)
holds(1, in(puzzle_room_table_right), (puzzle_room,1), 0)
holds(1, in(talos), (starting_room,0), 0)
holds(1, in_tower((block,1),(block,1)), true, 0)
holds(1, in_tower((block,1),(block,2)), false, 0)
holds(1, in_tower((block,1),(block,3)), true, 0)
holds(1, in_tower((block,1),(block,4)), false, 0)
holds(1, in_tower((block,1),(block,5)), false, 0)
holds(1, in_tower((block,1),(block,6)), false, 0)
holds(1, in_tower((block,2),(block,1)), false, 0)
holds(1, in_tower((block,2),(block,2)), true, 0)
holds(1, in_tower((block,2),(block,3)), false, 0)
holds(1, in_tower((block,2),(block,4)), false, 0)
holds(1, in_tower((block,2),(block,5)), false, 0)
holds(1, in_tower((block,2),(block,6)), false, 0)
holds(1, in_tower((block,3),(block,1)), false, 0)
holds(1, in_tower((block,3),(block,2)), false, 0)
holds(1, in_tower((block,3),(block,3)), false, 0)
holds(1, in_tower((block,3),(block,4)), false, 0)
holds(1, in_tower((block,3),(block,5)), false, 0)
holds(1, in_tower((block,3),(block,6)), false, 0)
holds(1, in_tower((block,4),(block,1)), false, 0)
holds(1, in_tower((block,4),(block,2)), false, 0)
holds(1, in_tower((block,4),(block,3)), false, 0)
holds(1, in_tower((block,4),(block,4)), false, 0)
holds(1, in_tower((block,4),(block,5)), false, 0)
holds(1, in_tower((block,4),(block,6)), false, 0)
holds(1, in_tower((block,5),(block,1)), false, 0)
holds(1, in_tower((block,5),(block,2)), false, 0)
holds(1, in_tower((block,5),(block,3)), false, 0)
holds(1, in_tower((block,5),(block,4)), false, 0)
holds(1, in_tower((block,5),(block,5)), false, 0)
holds(1, in_tower((block,5),(block,6)), false, 0)
holds(1, in_tower((block,6),(block,1)), false, 0)
holds(1, in_tower((block,6),(block,2)), false, 0)
holds(1, in_tower((block,6),(block,3)), false, 0)
holds(1, in_tower((block,6),(block,4)), false, 0)
holds(1, in_tower((block,6),(block,5)), false, 0)
holds(1, in_tower((block,6),(block,6)), false, 0)
holds(1, on((block,1)), puzzle_room_table_left, 0)
holds(1, on((block,2)), puzzle_room_table_right, 0)
holds(1, on((block,3)), (block,1), 0)
holds(1, on((block,4)), nothing, 0)
holds(1, on((block,5)), nothing, 0)
holds(1, on((block,6)), nothing, 0)
holds(1, tower_base((block,1)), true, 0)
holds(1, tower_base((block,2)), true, 0)
holds(1, tower_base((block,3)), false, 0)
holds(1, tower_base((block,4)), false, 0)
holds(1, tower_base((block,5)), false, 0)
holds(1, tower_base((block,6)), false, 0)
holds(1, unordered_tower((block,1)), true, 0)
holds(1, unordered_tower((block,2)), false, 0)
holds(1, unordered_tower((block,3)), false, 0)
holds(1, unordered_tower((block,4)), false, 0)
holds(1, unordered_tower((block,5)), false, 0)
holds(1, unordered_tower((block,6)), false, 0)

[09-09-2021_16-35-07] DEBUG :: ASH Planner Main #1 >> The given partial initial state has a unique interpretation (only one stable model exists).

[09-09-2021_16-35-07] DEBUG :: ASH Planner Main #1 >> Generating final goals.

[09-09-2021_16-35-07] DEBUG :: Logic Program ASH #1 >> Creating copy of self: rename = Main #1 || Generate Final Goals

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Instantiating logic program...

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Setting input storing variables:
	solver_options = []
	assumptions = []
	context = None
	incrementor = None
	base_parts = []
	inc_parts = []

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Output storing variables reset.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Logic program instantiated.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Entering new one-shot solve call:
('self', LogicProgram(#program base.
#program abstraction_levels(planning_level, mode).
al((1..abstraction_max)).
pl(AL) :- AL = planning_level; al(AL).
sl(AL) :- AL = planning_level; mode = classical; al(AL).
sl(AL) :- AL >= planning_level; AL <= (planning_level+1); mode = refinement; al(AL).
sl(AL) :- AL >= planning_level; AL <= abstraction_max; mode = hierarchical; al(AL).
#program instance_module.
boolean(true;false).
insta_of(AL,CLS,EN) :- entity(CLS,EN); class(AL,CLS); al(AL).
insta_of(AL_3,CLS_1,EN) :- insta_of(AL_2,CLS_2,EN); super_class(CLS_1,CLS_2); entity(CLS_3,EN); class(AL_3,CLS_3); class(AL_1,CLS_1); AL_1 >= AL_2; al(AL_1); al(AL_2); al(AL_3).
insta_of((AL-1),CLS,EN) :- insta_of(AL,CLS,EN); not overridden((AL-1),CLS,EN); class(_,CLS); al(AL); al((AL-1)).
overridden((AL-1),CLS,EN_1) :- overridden_by((AL-1),CLS,EN_1,EN_2); insta_of(AL,CLS,EN_1); insta_of((AL-1),CLS,EN_2); class(_,CLS); al(AL); al((AL-1)).
overridden_by((AL-1),CLS_3,EN_1,EN_2) :- insta_of(AL,CLS_1,EN_1); insta_of((AL-1),CLS_2,EN_2); insta_of(AL,CLS_3,EN_1); insta_of((AL-1),CLS_3,EN_2); desce_of((AL-1),EN_1,EN_2); override_class(CLS_1,CLS_2,CLS_3); class(_,CLS_1); class(_,CLS_2); class(_,CLS_3); al(AL); al((AL-1)).
state_of(AL,EN,S) :- state(AL,CLS,S); insta_of(AL,CLS,EN); al(AL).
child_of(AL,EN,DESCE) :- ancestry_relation(EN,DESCE); insta_of(AL,_,EN); insta_of(AL,_,DESCE); al(AL).
desce_of(AL,EN,DESCE) :- child_of(AL,EN,DESCE); insta_of(AL,_,EN); insta_of(AL,_,DESCE); al(AL).
desce_of(AL,EN,DESCE_1) :- desce_of(AL,DESCE_2,DESCE_1); desce_of(AL,EN,DESCE_2); insta_of(AL,_,EN); insta_of(AL,_,DESCE_1); insta_of(AL,_,DESCE_2); al(AL).
has_desce(AL,EN) :- desce_of(AL,EN,DESCE); insta_of(AL,_,EN); insta_of(AL,_,DESCE); al(AL).
has_desce(AL,EN,CLS) :- desce_of(AL,EN,DESCE); insta_of(AL,_,EN); insta_of(AL,CLS,DESCE); al(AL).
siblings(AL,DESCE_1,DESCE_2) :- child_of(AL,EN,DESCE_1); child_of(AL,EN,DESCE_2); DESCE_1 != DESCE_2; insta_of(AL,_,EN); insta_of(AL,_,DESCE_1); insta_of(AL,_,DESCE_2); al(AL).
siblings(AL,DESCE_2,DESCE_1) :- siblings(AL,DESCE_1,DESCE_2); insta_of(AL,_,DESCE_1); insta_of(AL,_,DESCE_2); al(AL).
#program state_module(step, start).
{ holds(AL,F,V,step) } :- fluent(AL,inertial,F,V); sl(AL); step = start.
#false :- not 1 = { holds(AL,F,V,step): fluent(AL,_,F,V) }; fluent(AL,_,F,_); sl(AL).
holds(AL,F,V,step) :- holds(AL,F,V,(step-1)); not not holds(AL,F,V,step); fluent(AL,inertial,F,V); sl(AL); step > start.
holds(AL,F,false,step) :- not holds(AL,F,true,step); fluent(AL,defined,F,B); boolean(B); sl(AL).
#program plan_module(step, start, concurrency, achieve_fgoals).
{ occurs(AL,ROBOT,A,step): action(AL,_,ROBOT,A) } :- incomplete_plan((step-1)); pl(AL); step > start.
occurs(AL,ROBOT,step) :- occurs(AL,ROBOT,A,step); action(AL,_,ROBOT,A); pl(AL); step > start.
occurs(AL,step) :- occurs(AL,ROBOT,step); insta_of(AL,robot,ROBOT); pl(AL); step > start.
holds(AL,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V,step); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
holds(AL,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,true,step); not holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,true); not holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,false,step); holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); precond(AL,ROBOT,A,F,V,false); holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- not 1 = { occurs(AL,R,A,step): action(AL,_,ROBOT,A) }; incomplete_plan((step-1)); pl(AL); step > start; concurrency = false.
#false :- not 1 <= { occurs(AL,R,A,step): action(AL,_,ROBOT,A), A != do_nothing }; incomplete_plan((step-1)); pl(AL); step > start; concurrency = true.
#false :- not occurs(AL,ROBOT,(step-1)); occurs(AL,ROBOT,step); insta_of(AL,robot,ROBOT); incomplete_plan((step-1)); pl(AL); step > (start+1); concurrency = true.
has_affect(AL,ROBOT,A,step) :- effect(AL,ROBOT,A,F,V,step); not holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
has_affect(AL,ROBOT,A,step) :- effect(AL,ROBOT,A,F,V); not holds(AL,F,V,(step-1)); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); step > start.
#false :- occurs(AL,ROBOT,A,step); not has_affect(AL,ROBOT,A,step); action(AL,_,ROBOT,A); A != do_nothing; pl(AL); step > start.
action(AL,sequential,ROBOT,do_nothing) :- insta_of(AL,robot,ROBOT); sl(AL); concurrency = true.
#false :- occurs(AL,ROBOT,A_1,step); occurs(AL,ROBOT,A_2,step); A_1 != A_2; action(AL,_,ROBOT,A_1); action(AL,_,ROBOT,A_2); pl(AL); step > start; concurrency = false.
#false :- occurs(AL,ROBOT,A_1,step); occurs(AL,ROBOT,A_2,step); A_1 != A_2; action(AL,sequential,ROBOT,A_1); action(AL,_,ROBOT,A_2); pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); effect(AL,ROBOT_2,A_2,F,V_2,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; ROBOT_1 != ROBOT_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); effect(AL,ROBOT_2,A_2,F,V_2); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; ROBOT_1 != ROBOT_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1); effect(AL,ROBOT_2,A_2,F,V_2); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; ROBOT_1 != ROBOT_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); precond(AL,ROBOT_2,A_2,F,V_2,true,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1,step); precond(AL,ROBOT_2,A_2,F,V_2,true); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V,step); precond(AL,ROBOT_2,A_2,F,V,false,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V,step); precond(AL,ROBOT_2,A_2,F,V,false); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1); precond(AL,ROBOT_2,A_2,F,V_2,true,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V_1); precond(AL,ROBOT_2,A_2,F,V_2,true); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V_1); fluent(AL,inertial,F,V_2); A_1 != A_2; V_1 != V_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V); precond(AL,ROBOT_2,A_2,F,V,false,step); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#false :- occurs(AL,ROBOT_1,A_1,step); occurs(AL,ROBOT_2,A_2,step); effect(AL,ROBOT_1,A_1,F,V); precond(AL,ROBOT_2,A_2,F,V,false); action(AL,concurrent,ROBOT_1,A_1); action(AL,concurrent,ROBOT_2,A_2); fluent(AL,inertial,F,V); A_1 != A_2; pl(AL); step > start; concurrency = true.
#external seq_achieve_fgoals(step). [false]
enforce_achieve_fgoals(step) :- achieve_fgoals = true.
enforce_achieve_fgoals(step) :- 0 <= S; S <= step; seq_achieve_fgoals(S).
goal_satisfied(AL,F,V,true,step) :- final_goal(AL,F,V,true); holds(AL,F,V,step); fluent(AL,_,F,V); pl(AL); enforce_achieve_fgoals(step).
goal_satisfied(AL,F,V,false,step) :- final_goal(AL,F,V,false); not holds(AL,F,V,step); fluent(AL,_,F,V); pl(AL); enforce_achieve_fgoals(step).
incomplete_plan(step) :- final_goal(AL,F,V,B); not goal_satisfied(AL,F,V,B,step); fluent(AL,_,F,V); pl(AL); boolean(B); enforce_achieve_fgoals(step).
sub_goal(AL,ROBOT,A,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V,step); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); AL != 1; step > start.
sub_goal(AL,ROBOT,A,F,V,step) :- occurs(AL,ROBOT,A,step); effect(AL,ROBOT,A,F,V); action(AL,_,ROBOT,A); fluent(AL,inertial,F,V); pl(AL); AL != 1; step > start.
#program optimisation_module(step, start, minimise_length, minimise_actions, minimise_cost, preempt_pos_fgoals, preempt_neg_fgoals, order_fgoals_achievement).
:~ occurs(AL,step); incomplete_plan((step-1)); pl(AL); step > start; minimise_length = true. [1@3,step]
:~ occurs(AL,ROBOT,A,step); action(AL,_,ROBOT,A); incomplete_plan((step-1)); pl(AL); step > start; minimise_actions = true. [1@2,ROBOT,A,step]
#heuristic occurs(AL,ROBOT,A,step) : action(AL,_,ROBOT,A); effect(AL,ROBOT,A,F,V); fluent(AL,inertial,F,V); final_goal(AL,F,V,true); pl(AL); step > start; preempt_pos_fgoals = true. [10@1,true]
#heuristic occurs(AL,ROBOT,A,step) : action(AL,_,ROBOT,A); effect(AL,ROBOT,A,F,V); fluent(AL,inertial,F,V); final_goal(AL,F,V,false); pl(AL); step > start; preempt_neg_fgoals = true. [10@0,false]
#program check(step).
#external query(step). [false]
#false :- incomplete_plan(step); query(step).
#program conformance_module(step, start, first, last, type, yield).
#external current_last_sgoals(I,step) : sgoals_index(I); yield = true. [false]
include_sgoals(I,step) :- I <= I_L; S <= step; current_last_sgoals(I_L,S); sgoals_index(I).
include_sgoals(I,step) :- sgoals_index(I); yield = false.
sgoals_index((first..last)).
current_sub_goal((AL+1),ROBOT,A,F,V,first,start) :- sub_goal((AL+1),ROBOT,A,F,V,first); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
sub_goal_satisfied((AL+1),ROBOT,A,F,V,I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,(step-1)); holds((AL+1),F,V,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,(step-1)); not sub_goal_satisfied((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); type = sequential; pl(AL).
unachieved_sgoals((AL+1),I_SG,step) :- current_sub_goal_index((AL+1),I_SG,(step-1)); sub_goal((AL+1),ROBOT,A,F,V,I_SG); not sub_goal_satisfied((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,(step-1)); unachieved_sgoals((AL+1),I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); type = simultaneous; pl(AL).
current_sub_goal((AL+1),ROBOT_1,A_1,F_1,V_1,(I_SG+1),step) :- include_sgoals((I_SG+1),step); sub_goal((AL+1),ROBOT_1,A_1,F_1,V_1,(I_SG+1)); current_sub_goal_index((AL+1),I_SG,(step-1)); not current_sub_goal_index((AL+1),I_SG,step); action((AL+1),_,ROBOT_1,A_1); fluent((AL+1),inertial,F_1,V_1); pl(AL).
sgoals_ach_at((AL+1),I_SG,step) :- current_sub_goal_index((AL+1),I_SG,(step-1)); not current_sub_goal_index((AL+1),I_SG,step); pl(AL).
current_sub_goal_index((AL+1),I_SG,step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
incomplete_plan(step) :- sub_goal((AL+1),ROBOT,A,F,V,I_SG); current_sub_goal((AL+1),ROBOT,A,F,V,I_SG,step); action((AL+1),_,ROBOT,A); fluent((AL+1),inertial,F,V); pl(AL).
#program goal_abstraction_module.
holds(AL,F,V,0) :- final_goal(AL,F,V,true); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
not holds(AL,F,V,0) :- final_goal(AL,F,V,false); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
final_goal(AL,F,V,true) :- holds(AL,F,V,0); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
final_goal(AL,F,V,false) :- not holds(AL,F,V,0); goal_fluent(AL,F); fluent(AL,_,F,V); al(AL).
{ holds(AL,F,V,0) } :- goal_fluent(AL,F); fluent(AL,inertial,F,V); al(AL).
#false :- not 1 = { holds(AL,F,V,0): fluent(AL,_,F,V) }; goal_fluent(AL,F); fluent(AL,_,F,_); al(AL).
holds(AL,F,false,0) :- not holds(AL,F,true,0); goal_fluent(AL,F); fluent(AL,defined,F,B); boolean(B); al(AL).
#program domain_sorts.
#const abstraction_max = 3.
#const reduc = 3.
#const conde = 2.
#const groun = 1.
class(3,robot).
class(3,armed_robot).
class(3,location).
class(3,room).
class(3,object).
class(3,grounded).
class(3,graspable).
class(3,placeable).
class(3,block).
class(3,surface).
class(3,table).
class(3,colour).
class(3,manipulator_arm).
class(3,grasper).
class(2,door).
class(2,handle).
class(2,configurable).
class(2,extensible).
class(1,cell).
class(1,manipulator_limb).
class(1,manipulator_end).
class(1,side).
super_class(robot,armed_robot).
super_class(location,room).
super_class(location,cell).
super_class(object,robot).
super_class(object,manipulator_arm).
super_class(object,manipulator_limb).
super_class(object,manipulator_end).
super_class(object,table).
super_class(object,side).
super_class(object,block).
super_class(object,grounded).
super_class(grounded,handle).
super_class(configurable,extensible).
super_class(configurable,grasper).
super_class(configurable,door).
super_class(extensible,manipulator_arm).
super_class(extensible,manipulator_limb).
super_class(grasper,manipulator_arm).
super_class(grasper,manipulator_end).
super_class(graspable,block).
super_class(graspable,handle).
super_class(placeable,block).
super_class(surface,table).
super_class(surface,side).
super_class(surface,block).
override_class(manipulator_arm,manipulator_end,grasper).
override_class(manipulator_arm,manipulator_limb,extensible).
override_class(room,cell,location).
override_class(table,side,surface).
state(AL,extensible,extended) :- AL < reduc; al(AL).
state(AL,extensible,retracted) :- AL < reduc; al(AL).
state(AL,manipulator_end,aligned_with(OBJ)) :- insta_of(AL,graspable,OBJ); class(AL,manipulator_end); AL < reduc; al(AL).
state(AL,manipulator_end,aligned_with(nothing)) :- AL < reduc; al(AL).
state(AL,door,open) :- AL < reduc; al(AL).
state(AL,door,closed) :- AL < reduc; al(AL).
static(AL,connected(L_1,L_2)) :- insta_of(AL,location,L_1); insta_of(AL,location,L_2); al(AL).
static(AL,connected_by_door(D,L_1,L_2)) :- insta_of(AL,door,D); insta_of(AL,location,L_1); insta_of(AL,location,L_2); AL < reduc; al(AL).
static(AL,in(OBJ,L)) :- insta_of(AL,object,OBJ); insta_of(AL,grounded,OBJ); insta_of(AL,location,L); AL < reduc; al(AL).
static(AL,colour_of(BLOCK,COLOUR)) :- insta_of(AL,block,BLOCK); insta_of(AL,colour,COLOUR); al(AL).
fluent(AL_1,inertial,in(OBJ),L) :- insta_of(AL_1,location,L); insta_of(AL_2,object,OBJ); OBJ != nothing; not insta_of(AL_2,grounded,OBJ); sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,on(OBJ),SURFACE) :- OBJ != SURFACE; insta_of(AL_1,surface,SURFACE); insta_of(AL_2,placeable,OBJ); sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,grasping(DESC),OBJ) :- insta_of(AL_1,graspable,OBJ); insta_of(AL_2,grasper,DESC); sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,configuration(DESC),STATE) :- state_of(AL_1,DESC,STATE); insta_of(AL_2,configurable,DESC); AL_1 < reduc; AL_2 < reduc; sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL_1,inertial,configuration(D),STATE) :- state_of(AL_1,D,STATE); insta_of(AL_2,door,D); AL_1 < reduc; AL_2 < reduc; sl(AL_1); sl(AL_2); AL_2 >= AL_1.
fluent(AL,defined,tower_base(BASE),B) :- insta_of(AL,block,BASE); sl(AL); boolean(B).
fluent(AL,defined,in_tower(BASE,BLOCK),B) :- insta_of(AL,block,BASE); insta_of(AL,block,BLOCK); sl(AL); boolean(B).
fluent(AL,defined,unordered_tower(BASE),B) :- insta_of(AL,block,BASE); sl(AL); boolean(B).
fluent(AL,defined,complete(COLOUR),B) :- insta_of(AL,colour,COLOUR); sl(AL); boolean(B).
action(AL,sequential,ROBO,move(L)) :- insta_of(AL,robot,ROBO); insta_of(AL,location,L); sl(AL).
action(AL,concurrent,ROBO,grasp(DESC,OBJ)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; sl(AL).
action(AL,concurrent,ROBO,release(DESC,OBJ)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; sl(AL).
action(AL,concurrent,ROBO,configure(DESC,STATE)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,configurable,DESC); state_of(AL,DESC,STATE); AL < reduc; sl(AL).
action(AL,concurrent,ROBO,put(DESC,OBJ,SURFACE)) :- OBJ != SURFACE; SURFACE != nothing; desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); sl(AL).
action(AL,concurrent,ROBO,lift(DESC,OBJ)) :- desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); sl(AL).
action(AL,sequential,ROBO,actuate(DESC,D)) :- insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,door,D); AL < reduc; sl(AL).
#program action_effects(t).
effect(AL,ROBO,move(L),in(ROBO),L) :- action(AL,_,ROBO,move(L)); fluent(AL,inertial,in(ROBO),L); insta_of(AL,robot,ROBO); insta_of(AL,location,L); pl(AL).
effect(AL,ROBO,grasp(DESC,OBJ),grasping(DESC),OBJ) :- action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; pl(AL).
effect(AL,ROBO,release(DESC,OBJ),grasping(DESC),nothing) :- action(AL,_,ROBO,release(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); pl(AL).
effect(AL,ROBO,release(END,OBJ),configuration(END),aligned_with(nothing)) :- action(AL,_,ROBO,release(END,OBJ)); fluent(AL,inertial,configuration(END),aligned_with(nothing)); desce_of(AL,ROBO,END); insta_of(AL,armed_robot,ROBO); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); state_of(AL,END,aligned_with(nothing)); AL < reduc; pl(AL).
effect(AL,ROBO,configure(DESC,STATE),configuration(DESC),STATE) :- action(AL,_,ROBO,configure(DESC,STATE)); fluent(AL,inertial,configuration(DESC),STATE); desce_of(AL,ROBO,DESC); insta_of(AL,robot,ROBO); insta_of(AL,configurable,DESC); state_of(AL,DESC,STATE); AL < reduc; pl(AL).
effect(AL,ROBO,configure(ARM,retracted),configuration(END),aligned_with(nothing),t) :- holds(AL,grasping(END),nothing,(t-1)); action(AL,_,ROBO,configure(ARM,retracted)); fluent(AL,inertial,configuration(END),aligned_with(nothing)); desce_of(AL,ROBO,ARM); desce_of(AL,ROBO,END); siblings(AL,ARM,END); insta_of(AL,armed_robot,ROBO); insta_of(AL,extensible,ARM); insta_of(AL,manipulator_end,END); state_of(AL,END,aligned_with(nothing)); AL < reduc; pl(AL).
effect(AL,ROBO,put(DESC,OBJ,SURFACE),on(OBJ),SURFACE) :- action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,on(OBJ),SURFACE); OBJ != SURFACE; SURFACE != nothing; desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); pl(AL).
effect(AL,ROBO,lift(DESC,OBJ),on(OBJ),nothing) :- action(AL,_,ROBO,lift(DESC,OBJ)); fluent(AL,inertial,on(OBJ),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); pl(AL).
effect(AL,ROBO,actuate(DESC,D),configuration(D),STATE_1,t) :- holds(AL,configuration(D),STATE_2,(t-1)); fluent(AL,inertial,configuration(D),STATE_1); fluent(AL,inertial,configuration(D),STATE_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,door,D); state_of(AL,D,STATE_1); state_of(AL,D,STATE_2); STATE_1 != STATE_2; AL < reduc; pl(AL).
#program action_preconditions(t).
1 = { precond(AL,ROBO,move(P_2),in(ROBO),P_1,true,t): is(AL,connected(P_1,P_2)), fluent(AL,inertial,in(ROBO),P_1), static(AL,connected(P_1,P_2)), P_1 != P_2, insta_of(AL,location,P_1) } :- action(AL,_,ROBO,move(P_2)); insta_of(AL,robot,ROBO); insta_of(AL,location,P_2); AL < reduc; pl(AL).
precond(AL,ROBO,move(L_2),configuration(D),open,true,t) :- holds(AL,in(ROBO),L_1,(t-1)); is(AL,connected_by_door(D,L_1,L_2)); L_1 != L_2; action(AL,_,ROBO,move(L_2)); fluent(AL,inertial,configuration(D),open); fluent(AL,_,in(ROBO),L_1); static(AL,connected_by_door(D,L_1,L_2)); insta_of(AL,robot,ROBO); insta_of(AL,location,L_1); insta_of(AL,location,L_2); insta_of(AL,door,D); AL < reduc; pl(AL).
1 = { precond(AL,ROBO,actuate(COMP,D),grasping(COMP),H,true,t): desce_of(AL,D,H), insta_of(AL,handle,H), action(AL,_,ROBO,actuate(COMP,D)), fluent(AL,inertial,grasping(COMP),H) } :- desce_of(AL,ROBO,COMP); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,COMP); insta_of(AL,door,D); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),in(ROBO),L,true) :- is(AL,in(OBJ,L)); action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,in(ROBO),L); static(AL,in(OBJ,L)); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,grounded,OBJ); insta_of(AL,location,L); AL < reduc; pl(AL).
precond(AL,ROBO,move(L),configuration(DESC),retracted,true) :- action(AL,_,ROBO,move(L)); fluent(AL,inertial,configuration(DESC),retracted); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,extensible,DESC); insta_of(AL,location,L); state_of(AL,DESC,retracted); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),in(OBJ),L,true,t) :- holds(AL,in(ROBO),L,(t-1)); OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,in(OBJ),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),in(ROBO),L,true,t) :- holds(AL,in(OBJ),L,(t-1)); OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,in(OBJ),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),grasping(DESC),nothing,true) :- OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ_1),on(OBJ_2),OBJ_1,false) :- OBJ_1 != OBJ_2; OBJ_1 != nothing; action(AL,_,ROBO,grasp(DESC,OBJ_1)); fluent(AL,inertial,on(OBJ_2),OBJ_1); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ_1); insta_of(AL,surface,OBJ_1); insta_of(AL,placeable,OBJ_2); pl(AL).
precond(AL,ROBO,grasp(DESC,OBJ),configuration(DESC),extended,true) :- OBJ != nothing; action(AL,_,ROBO,grasp(DESC,OBJ)); fluent(AL,inertial,configuration(DESC),extended); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,extensible,DESC); insta_of(AL,graspable,OBJ); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(DESC_1,OBJ),configuration(DESC_2),extended,true) :- OBJ != nothing; action(AL,_,ROBO,grasp(DESC_1,OBJ)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC_1); not insta_of(AL,extensible,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,graspable,OBJ); AL < reduc; pl(AL).
precond(AL,ROBO,grasp(END,OBJ),configuration(END),aligned_with(OBJ),true) :- OBJ != nothing; action(AL,_,ROBO,grasp(END,OBJ)); fluent(AL,inertial,configuration(END),aligned_with(OBJ)); desce_of(AL,ROBO,END); insta_of(AL,armed_robot,ROBO); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); state_of(AL,END,aligned_with(OBJ)); AL < reduc; pl(AL).
precond(AL,ROBO,release(DESC,OBJ),grasping(DESC),OBJ,true) :- OBJ != nothing; action(AL,_,ROBO,release(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); pl(AL).
precond(AL,ROBO,release(DESC,OBJ),configuration(DESC),extended,true) :- OBJ != nothing; action(AL,_,ROBO,release(DESC,OBJ)); fluent(AL,inertial,configuration(DESC),extended); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); state_of(AL,DESC,extended); pl(AL); t > 0.
precond(AL,ROBO,release(DESC_1,OBJ),configuration(DESC_2),extended,true) :- OBJ != nothing; action(AL,_,ROBO,release(DESC_1,OBJ)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC_1); not insta_of(AL,extensible,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,graspable,OBJ); pl(AL).
precond(AL,ROBO,configure(DESC_1,STATE),configuration(DESC_2),extended,true) :- action(AL,_,ROBO,configure(DESC_1,STATE)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); desce_of(AL,ROBO,ARM); child_of(AL,ARM,DESC_1); child_of(AL,ARM,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,configurable,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,manipulator_arm,ARM); state_of(AL,DESC_1,STATE); AL < reduc; pl(AL).
precond(AL,ROBO,configure(DESC,aligned_with(OBJ)),grasping(DESC),nothing,true) :- action(AL,_,ROBO,configure(DESC,aligned_with(OBJ))); fluent(AL,inertial,grasping(DESC),nothing); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,manipulator_end,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; state_of(AL,DESC,aligned_with(OBJ)); AL < reduc; pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),in(SURFACE),L,true,t) :- holds(AL,in(ROBO),L,(t-1)); action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,in(SURFACE),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),in(ROBO),L,true,t) :- holds(AL,in(SURFACE),L,(t-1)); action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,in(SURFACE),L); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); insta_of(AL,location,L); pl(AL).
precond(AL,ROBO,put(DESC,OBJ_1,BLOCK),on(OBJ_2),BLOCK,false) :- OBJ_1 != OBJ_2; action(AL,_,ROBO,put(DESC,OBJ_1,SURFACE)); fluent(AL,inertial,on(OBJ_2),BLOCK); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ_1); insta_of(AL,placeable,OBJ_2); insta_of(AL,block,BLOCK); pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),grasping(DESC),OBJ,true) :- OBJ != SURFACE; OBJ != nothing; SURFACE != nothing; action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ); insta_of(AL,surface,SURFACE); pl(AL).
precond(AL,ROBO_1,put(DESC_1,OBJ_1,OBJ_2),grasping(DESC_2),OBJ_2,false) :- OBJ_1 != OBJ_2; DESC_1 != DESC_2; action(AL,_,ROBO,put(DESC_1,OBJ_1,OBJ_2)); fluent(AL,inertial,grasping(DESC_2),OBJ_2); desce_of(AL,ROBO_1,DESC_1); desce_of(AL,ROBO_2,DESC_2); insta_of(AL,armed_robot,ROBO_1); insta_of(AL,armed_robot,ROBO_2); insta_of(AL,grasper,DESC_1); insta_of(AL,grasper,DESC_2); insta_of(AL,placeable,OBJ_1); insta_of(AL,surface,OBJ_2); insta_of(AL,graspable,OBJ_2); pl(AL).
precond(AL,ROBO,put(DESC,OBJ,SURFACE),configuration(DESC),extended,true) :- action(AL,_,ROBO,put(DESC,OBJ,SURFACE)); fluent(AL,inertial,configuration(DESC),extended); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,extensible,DESC); insta_of(AL,graspable,OBJ); insta_of(AL,surface,SURFACE); AL < reduc; pl(AL).
precond(AL,ROBO,put(DESC_1,OBJ,SURFACE),configuration(DESC_2),extended,true) :- action(AL,_,ROBO,put(DESC_1,OBJ,SURFACE)); fluent(AL,inertial,configuration(DESC_2),extended); desce_of(AL,ROBO,DESC_1); desce_of(AL,ROBO,DESC_2); siblings(AL,DESC_1,DESC_2); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC_1); not insta_of(AL,extensible,DESC_1); insta_of(AL,extensible,DESC_2); insta_of(AL,graspable,OBJ); insta_of(AL,surface,SURFACE); AL < reduc; pl(AL).
precond(AL,ROBO,lift(DESC,OBJ_1),on(OBJ_2),OBJ_1,false) :- OBJ_1 != OBJ_2; action(AL,_,ROBO,lift(DESC,OBJ_1)); fluent(AL,inertial,on(OBJ_2),OBJ_1); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,placeable,OBJ_1); insta_of(AL,surface,OBJ_1); insta_of(AL,placeable,OBJ_2); pl(AL).
precond(AL,ROBO,lift(DESC,OBJ),grasping(DESC),OBJ,true) :- OBJ != SURFACE; action(AL,_,ROBO,lift(DESC,OBJ)); fluent(AL,inertial,grasping(DESC),OBJ); desce_of(AL,ROBO,DESC); insta_of(AL,armed_robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,surface,SURFACE); pl(AL).
#program variable_relations(t).
#false :- holds(AL,grasping(DESC),OBJ,t); holds(AL,in(ROBO),L,t); not holds(AL,in(OBJ),L,t): not insta_of(AL,grounded,OBJ), fluent(AL,inertial,in(OBJ),L); not is(AL,in(OBJ,L)): insta_of(AL,grounded,OBJ), static(AL,in(OBJ,L)); fluent(AL,inertial,grasping(DESC),OBJ); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,DESC); insta_of(AL,robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,location,L); sl(AL).
#false :- holds(AL,configuration(END),aligned_with(OBJ),t); holds(AL,in(ROBO),L,t); not holds(AL,in(OBJ),L,t): not insta_of(AL,grounded,OBJ), fluent(AL,inertial,in(OBJ),L); not is(AL,in(OBJ,L)): insta_of(AL,grounded,OBJ), static(AL,in(OBJ,L)); fluent(AL,inertial,configuration(END),aligned_with(OBJ)); fluent(AL,inertial,in(ROBO),L); desce_of(AL,ROBO,END); insta_of(AL,robot,ROBO); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); OBJ != nothing; insta_of(AL,location,L); state_of(AL,END,aligned_with(OBJ)); sl(AL).
#false :- holds(AL,grasping(END),OBJ,t); not holds(AL,configuration(END),aligned_with(OBJ),t); fluent(AL,inertial,grasping(END),OBJ); fluent(AL,inertial,configuration(END),aligned_with(OBJ)); insta_of(AL,manipulator_end,END); insta_of(AL,graspable,OBJ); OBJ != nothing; state_of(AL,END,aligned_with(OBJ)); sl(AL).
#false :- holds(AL,grasping(DESC),OBJ_1,t); holds(AL,on(OBJ_2),OBJ_1,t); fluent(AL,inertial,grasping(DESC),OBJ_1); fluent(AL,inertial,on(OBJ_2),OBJ_1); desce_of(AL,ROBO,DESC); insta_of(AL,robot,ROBO); insta_of(AL,grasper,DESC); insta_of(AL,graspable,OBJ_1); OBJ_1 != nothing; insta_of(AL,surface,OBJ_1); insta_of(AL,placeable,OBJ_2); sl(AL).
#false :- holds(AL,on(OBJ),SURFACE,t); holds(AL,in(SURFACE),L,t); not holds(AL,in(OBJ),L,t); fluent(AL,inertial,on(OBJ),SURFACE); fluent(AL,inertial,in(SURFACE),L); fluent(AL,inertial,in(OBJ),L); insta_of(AL,location,L); insta_of(AL,location,L); insta_of(AL,surface,SURFACE); insta_of(AL,object,OBJ); sl(AL).
#false :- holds(AL,on(BLOCK_1),BLOCK_2,t); holds(AL,on(BLOCK_2),nothing,t); fluent(AL,inertial,on(BLOCK_1),BLOCK_2); fluent(AL,inertial,on(BLOCK_2),nothing); insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); sl(AL).
#false :- holds(AL,on(BLOCK_1),BLOCK_3,t); holds(AL,on(BLOCK_2),BLOCK_3,t); fluent(AL,inertial,on(BLOCK_1),BLOCK_3); fluent(AL,inertial,on(BLOCK_2),BLOCK_3); BLOCK_1 != BLOCK_2; insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); insta_of(AL,block,BLOCK_3); sl(AL).
holds(AL,tower_base(BASE),true,t) :- holds(AL,on(BASE),TABLE,t); fluent(AL,defined,tower_base(BASE),true); fluent(AL,inertial,on(BASE),TABLE); insta_of(AL,block,BASE); insta_of(AL,table,TABLE); sl(AL).
holds(AL,tower_base(BASE),true,t) :- holds(AL,on(BASE),SURFACE,t); fluent(AL,defined,tower_base(BASE),true); fluent(AL,inertial,on(BASE),SURFACE); desce_of(AL,TABLE,SURFACE); insta_of(AL,block,BASE); insta_of(AL,surface,SURFACE); insta_of(AL,table,TABLE); sl(AL).
holds(AL,in_tower(BASE,BASE),true,t) :- holds(AL,tower_base(BASE),true,t); fluent(AL,defined,in_tower(BASE,BASE),true); fluent(AL,defined,tower_base(BASE),true); insta_of(AL,block,BASE); sl(AL).
holds(AL,in_tower(BLOCK_1,BLOCK_2),true,t) :- holds(AL,on(BLOCK_2),BLOCK_3,t); holds(AL,in_tower(BLOCK_1,BLOCK_3),true,t); fluent(AL,defined,in_tower(BLOCK_1,BLOCK_2),true); fluent(AL,defined,in_tower(BLOCK_1,BLOCK_3),true); fluent(AL,inertial,on(BLOCK_2),BLOCK_3); BLOCK_1 != BLOCK_2; insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); insta_of(AL,block,BLOCK_3); sl(AL).
holds(AL,unordered_tower(BASE),true,t) :- holds(AL,on(BLOCK_1),BLOCK_2,t); holds(AL,in_tower(BASE,BLOCK_1),true,t); holds(AL,in_tower(BASE,BLOCK_2),true,t); holds(AL,tower_base(BASE),true,t); fluent(AL,defined,unordered_tower(BASE),true); fluent(AL,defined,in_tower(BASE,BLOCK_1),true); fluent(AL,defined,in_tower(BASE,BLOCK_2),true); fluent(AL,defined,tower_base(BASE),true); fluent(AL,inertial,on(BLOCK_1),BLOCK_2); BLOCK_1 = (block,N_1); number(N_1); BLOCK_2 = (block,N_2); number(N_2); BLOCK_1 != BLOCK_2; N_1 > N_2; insta_of(AL,block,BLOCK_1); insta_of(AL,block,BLOCK_2); insta_of(AL,block,BASE); sl(AL).
holds(AL,complete(COLOUR),true,t) :- N = #count { BLOCK: holds(AL,in_tower(BASE,BLOCK),true,t), is(AL,colour_of(BLOCK,COLOUR)), fluent(AL,defined,in_tower(BASE,BLOCK),true), static(AL,colour_of(BLOCK,COLOUR)), insta_of(AL,block,BLOCK) }; N = #count { BLOCK: is(AL,colour_of(BLOCK,COLOUR)), static(AL,colour_of(BLOCK,COLOUR)), insta_of(AL,block,BLOCK) }; holds(AL,unordered_tower(BASE),false,t); holds(AL,tower_base(BASE),true,t); fluent(AL,defined,unordered_tower(BASE),true); fluent(AL,defined,tower_base(BASE),true); is(AL,colour_of(BASE,COLOUR)); static(AL,colour_of(BASE,COLOUR)); insta_of(AL,colour,COLOUR); insta_of(AL,block,BASE); sl(AL).
#program abstraction_mappings(t).
is(AL_1,connected(L_1,L_2)) :- is(AL_2,connected(L_1_C,L_2_C)); static(AL_1,connected(L_1,L_2)); static(AL_2,connected(L_1_C,L_2_C)); L_1 != L_2; desce_of(AL_2,L_1,L_1_C); desce_of(AL_2,L_2,L_2_C); insta_of(AL_1,location,L_1); insta_of(AL_1,location,L_2); insta_of(AL_2,location,L_1_C); insta_of(AL_2,location,L_2_C); al(AL_1); al(AL_2); AL_1 >= AL_2.
is(AL_1,connected(L_1,L_2)) :- is(AL_2,connected(L_1,L_2)); static(AL_1,connected(L_1,L_2)); static(AL_2,connected(L_1,L_2)); L_1 != L_2; insta_of(AL_1,location,L_1); insta_of(AL_1,location,L_2); insta_of(AL_2,location,L_1); insta_of(AL_2,location,L_2); al(AL_1); al(AL_2); AL_1 >= AL_2.
is(AL_1,connected_by_door(D,L_1,L_2)) :- is(AL_2,connected_by_door(D,L_1_C,L_2_C)); static(AL_1,connected_by_door(D,L_1,L_2)); static(AL_2,connected_by_door(D,L_1_C,L_2_C)); L_1 != L_2; desce_of(AL_2,L_1,L_1_C); desce_of(AL_2,L_2,L_2_C); insta_of(AL_1,door,D); insta_of(AL_2,door,D); insta_of(AL_1,location,L_1); insta_of(AL_1,location,L_2); insta_of(AL_2,location,L_1_C); insta_of(AL_2,location,L_2_C); al(AL_1); al(AL_2); AL_1 >= AL_2.
is(AL_1,in(OBJ,L_1)) :- is(AL_2,in(OBJ,L_2)); static(AL_1,in(OBJ,L_1)); static(AL_2,in(OBJ,L_2)); desce_of(AL_2,L_1,L_2); insta_of(AL_1,location,L_1); insta_of(AL_1,object,OBJ); insta_of(AL_1,grounded,OBJ); insta_of(AL_1,location,L_1); insta_of(AL_2,location,L_2); al(AL_1); al(AL_2); AL_1 >= AL_2.
holds(AL_1,in(OBJ),L_1,t) :- holds(AL_2,in(OBJ),L_2,t); fluent(AL_1,inertial,in(OBJ),L_1); fluent(AL_2,inertial,in(OBJ),L_2); desce_of(AL_2,L_1,L_2); insta_of(AL_1,location,L_1); insta_of(AL_2,location,L_2); insta_of(AL_3,object,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
holds(AL_1,in(OBJ),L,t) :- holds(AL_2,in(OBJ),L,t); fluent(AL_1,inertial,in(OBJ),L); fluent(AL_2,inertial,in(OBJ),L); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,object,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
holds(AL_1,in(DESC),L,t) :- holds(AL_2,in(OBJ),L,t); fluent(AL_1,inertial,in(DESC),L); fluent(AL_2,inertial,in(OBJ),L); desce_of(AL_2,OBJ,DESC); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,object,OBJ); insta_of(AL_4,_,DESC); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_2; sl(AL_4); AL_4 >= AL_1.
holds(AL_1,in(OBJ),L,t) :- holds(AL_2,in(DESC),L,t); fluent(AL_1,inertial,in(OBJ),L); fluent(AL_2,inertial,in(DESC),L); desce_of(AL_2,OBJ,DESC); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,object,OBJ); insta_of(AL_4,_,DESC); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_2.
holds(AL_1,in(OBJ),L,t) :- holds(AL_2,in(ROBO),L,t); holds(AL_3,grasping(DESC),OBJ,t); fluent(AL_1,inertial,in(OBJ),L); fluent(AL_2,inertial,in(ROBO),L); fluent(AL_3,inertial,grasping(DESC),OBJ); desce_of(AL_2,ROBO,DESC); insta_of(AL_1,location,L); insta_of(AL_2,location,L); insta_of(AL_3,graspable,OBJ); OBJ != nothing; insta_of(AL_4,grasper,DESC); insta_of(AL_5,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_3; sl(AL_5); AL_5 >= AL_3.
holds(AL_1,grasping(DESC),OBJ_1,t) :- holds(AL_2,grasping(DESC),OBJ_2,t); fluent(AL_1,inertial,grasping(DESC),OBJ_1); fluent(AL_2,inertial,grasping(DESC),OBJ_2); desce_of(AL_2,ROBO,DESC); desce_of(AL_2,OBJ_1,OBJ_2); insta_of(AL_1,graspable,OBJ_1); insta_of(AL_2,graspable,OBJ_2); insta_of(AL_3,grasper,DESC); insta_of(AL_4,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_1.
holds(AL_1,grasping(DESC_1),OBJ,t) :- holds(AL_2,grasping(DESC_2),OBJ,t); fluent(AL_1,inertial,grasping(DESC_1),OBJ); fluent(AL_2,inertial,grasping(DESC_2),OBJ); desce_of(AL_2,ROBO,DESC_1); desce_of(AL_2,ROBO,DESC_2); desce_of(AL_2,DESC_1,DESC_2); insta_of(AL_1,graspable,OBJ); insta_of(AL_2,graspable,OBJ); insta_of(AL_3,grasper,DESC_1); insta_of(AL_4,grasper,DESC_2); insta_of(AL_5,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_2; sl(AL_5); AL_5 >= AL_1.
holds(AL_1,grasping(DESC),OBJ,t) :- holds(AL_2,grasping(DESC),OBJ,t); fluent(AL_1,inertial,grasping(DESC),OBJ); fluent(AL_2,inertial,grasping(DESC),OBJ); desce_of(AL_2,ROBO,DESC); insta_of(AL_1,graspable,OBJ); insta_of(AL_2,graspable,OBJ); insta_of(AL_3,grasper,DESC); insta_of(AL_4,robot,ROBO); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1; sl(AL_4); AL_4 >= AL_1; boolean(B).
holds(AL_1,configuration(DESC_1),STATE,t) :- holds(AL_2,configuration(DESC_2),STATE,t); fluent(AL_1,inertial,configuration(DESC_1),STATE); fluent(AL_2,inertial,configuration(DESC_2),STATE); desce_of(AL_2,DESC_1,DESC_2); state_of(AL_1,DESC_1,STATE); state_of(AL_2,DESC_2,STATE); insta_of(AL_1,configurable,DESC_1); insta_of(AL_2,configurable,DESC_2); sl(AL_1); sl(AL_2); AL_1 >= AL_2.
holds(AL_1,configuration(DESC),STATE,t) :- holds(AL_2,configuration(DESC),STATE,t); fluent(AL_1,inertial,configuration(DESC),STATE); fluent(AL_2,inertial,configuration(DESC),STATE); state_of(AL_1,DESC,STATE); state_of(AL_2,DESC,STATE); insta_of(AL_1,configurable,DESC); insta_of(AL_2,configurable,DESC); sl(AL_1); sl(AL_2); AL_1 >= AL_2.
holds(AL_1,on(OBJ),SURFACE_1,t) :- holds(AL_2,on(OBJ),SURFACE_2,t); fluent(AL_1,inertial,on(OBJ),SURFACE_1); fluent(AL_2,inertial,on(OBJ),SURFACE_2); desce_of(AL_2,SURFACE_1,SURFACE_2); insta_of(AL_1,surface,SURFACE_1); insta_of(AL_2,surface,SURFACE_2); insta_of(AL_3,placeable,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
holds(AL_1,on(OBJ),SURFACE,t) :- holds(AL_2,on(OBJ),SURFACE,t); fluent(AL_1,inertial,on(OBJ),SURFACE); fluent(AL_2,inertial,on(OBJ),SURFACE); insta_of(AL_1,surface,SURFACE); insta_of(AL_2,surface,SURFACE); insta_of(AL_3,placeable,OBJ); sl(AL_1); sl(AL_2); AL_1 >= AL_2; sl(AL_3); AL_3 >= AL_1.
#program static_state.
is(1,connected((starting_room,1),(hallway,1))).
is(1,connected((store_room,1),(hallway,0))).
is(1,connected((hallway,2),(puzzle_room,0))).
is(1,connected_by_door(store_room_door,(store_room,1),(hallway,0))).
is(1,connected_by_door(puzzle_room_door,(hallway,2),(puzzle_room,0))).
is(1,in(store_room_door_handle_inner,(store_room,1))).
is(1,in(store_room_door_handle_outer,(hallway,0))).
is(1,in(starting_room_door_handle_inner,(starting_room,1))).
is(1,in(starting_room_door_handle_outer,(hallway,1))).
is(1,in(puzzle_room_door_handle_inner,(puzzle_room,0))).
is(1,in(puzzle_room_door_handle_outer,(hallway,2))).
is(AL,colour_of((BLOCK,N),red)) :- static(AL,colour_of((BLOCK,N),red)); insta_of(AL,block,(BLOCK,N)); N <= 3; al(AL).
is(AL,colour_of((BLOCK,N),blue)) :- static(AL,colour_of((BLOCK,N),blue)); insta_of(AL,block,(BLOCK,N)); N > 3; N <= 6; al(AL).
is(1,connected((A,X_1),(A,X_2))) :- insta_of(1,cell,(A,X_1)); insta_of(1,cell,(A,X_2)); X_2 = (X_1+1).
is(1,connected(C_1,C_2)) :- is(1,connected(C_2,C_1)); insta_of(1,cell,C_1); insta_of(1,cell,C_2).
is(1,connected_by_door(D,C_1,C_2)) :- is(1,connected_by_door(D,C_2,C_1)); insta_of(1,door,D); insta_of(1,cell,C_1); insta_of(1,cell,C_2).
#program initial_state.
holds(1,in(talos),(starting_room,0),0).
holds(AL,grasping(DESC),nothing,0) :- fluent(AL,inertial,grasping(DESC),nothing); insta_of(AL,grasper,DESC); al(AL).
holds(AL,configuration(DESC),retracted,0) :- fluent(AL,inertial,configuration(DESC),retracted); insta_of(AL,extensible,DESC); sl(AL).
holds(1,configuration(END),aligned_with(nothing),0) :- fluent(AL,inertial,configuration(END),aligned_with(nothing)); insta_of(AL,manipulator_end,END); state_of(AL,END,aligned_with(nothing)); sl(AL).
holds(1,configuration(DOOR),closed,0) :- fluent(AL,inertial,configuration(DOOR),closed); insta_of(AL,door,DOOR); state_of(AL,DOOR,closed); sl(AL).
holds(1,in(puzzle_room_table),(puzzle_room,1),0).
holds(1,on((block,1)),puzzle_room_table_left,0).
holds(1,on((block,2)),puzzle_room_table_right,0).
holds(1,on((block,3)),(block,1),0).
holds(1,in((block,4)),(store_room,0),0).
holds(1,in((block,5)),(store_room,0),0).
holds(1,in((block,6)),(store_room,0),0).
holds(1,on((block,4)),nothing,0).
holds(1,on((block,5)),nothing,0).
holds(1,on((block,6)),nothing,0).
#program goal_state.
goal_fluent(AL,complete(COLOUR)) :- insta_of(AL,colour,COLOUR); al(AL).
goal_fluent(AL,on((block,3))) :- al(AL).
goal_fluent(AL,on((block,6))) :- al(AL).
final_goal(AL,complete(COLOUR),true,true) :- insta_of(AL,colour,COLOUR); al(AL).
final_goal(1,on((block,3)),puzzle_room_table_left,true).
final_goal(1,on((block,6)),puzzle_room_table_right,true).
#program entities.
entity(armed_robot,talos).
entity(manipulator_arm,manipulator_arm_1).
entity(manipulator_limb,manipulator_limb_1).
entity(manipulator_end,manipulator_end_1).
entity(manipulator_arm,manipulator_arm_2).
entity(manipulator_limb,manipulator_limb_2).
entity(manipulator_end,manipulator_end_2).
number((1..6)).
entity(block,(block,N)) :- number(N).
entity(room,starting_room).
entity(room,store_room).
entity(room,puzzle_room).
entity(room,hallway).
x((0..3)).
size(starting_room,2).
size(store_room,2).
size(hallway,3).
size(puzzle_room,2).
entity(cell,(ROOM,X)) :- entity(room,ROOM); size(ROOM,MAX); X < MAX; x(X).
entity(door,store_room_door).
entity(door,starting_room_door).
entity(door,puzzle_room_door).
entity(handle,store_room_door_handle_inner).
entity(handle,store_room_door_handle_outer).
entity(handle,starting_room_door_handle_inner).
entity(handle,starting_room_door_handle_outer).
entity(handle,puzzle_room_door_handle_inner).
entity(handle,puzzle_room_door_handle_outer).
entity(table,puzzle_room_table).
entity(side,puzzle_room_table_left).
entity(side,puzzle_room_table_right).
entity(colour,red).
entity(colour,blue).
entity(surface,nothing).
entity(graspable,nothing).
ancestry_relation(talos,manipulator_arm_1).
ancestry_relation(talos,manipulator_arm_2).
ancestry_relation(manipulator_arm_1,manipulator_limb_1).
ancestry_relation(manipulator_arm_2,manipulator_limb_2).
ancestry_relation(manipulator_arm_1,manipulator_end_1).
ancestry_relation(manipulator_arm_2,manipulator_end_2).
ancestry_relation(ROOM,(ROOM,X)) :- entity(room,ROOM); entity(cell,(ROOM,X)); x(X).
ancestry_relation(store_room_door,store_room_door_handle_inner).
ancestry_relation(store_room_door,store_room_door_handle_outer).
ancestry_relation(starting_room_door,starting_room_door_handle_inner).
ancestry_relation(starting_room_door,starting_room_door_handle_outer).
ancestry_relation(puzzle_room_door,puzzle_room_door_handle_inner).
ancestry_relation(puzzle_room_door,puzzle_room_door_handle_outer).
ancestry_relation(puzzle_room_table,puzzle_room_table_left).
ancestry_relation(puzzle_room_table,puzzle_room_table_right)., Main #1 || Generate Final Goals #1))
	('solver_options', ['--models=2', '--parallel-mode=6,compete', '--warn=none'])
	('assumptions', [])
	('context', None)
	('solve_incrementor', None)
	('base_parts', [('entities', []), ('static_state', []), ('goal_state', []), ('abstraction_levels', [1, 'hierarchical']), ('instance_module', []), ('goal_abstraction_module', []), ('domain_sorts', []), ('variable_relations', [0]), ('abstraction_mappings', [0])])
	('inc_parts', [IncPart(name='step', args=['#inc'], range_=None)])
	('incremental', False)

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Setting input storing variables:
	solver_options = ['--models=2', '--parallel-mode=6,compete', '--warn=none']
	assumptions = []
	context = None
	incrementor = None
	base_parts = [('entities', []), ('static_state', []), ('goal_state', []), ('abstraction_levels', [1, 'hierarchical']), ('instance_module', []), ('goal_abstraction_module', []), ('domain_sorts', []), ('variable_relations', [0]), ('abstraction_mappings', [0])]
	inc_parts = [IncPart(name='step', args=['#inc'], range_=None)]

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Output storing variables reset.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Program building started :: Processing 336 rules

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Program building completed in 0.0021704000000000168s

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Running one-shot ground and solve of program parts:
[BasePart(name='entities', args=[]), BasePart(name='static_state', args=[]), BasePart(name='goal_state', args=[]), BasePart(name='abstraction_levels', args=[1, 'hierarchical']), BasePart(name='instance_module', args=[]), BasePart(name='goal_abstraction_module', args=[]), BasePart(name='domain_sorts', args=[]), BasePart(name='variable_relations', args=[0]), BasePart(name='abstraction_mappings', args=[0])]

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Grounding program parts:
[('entities', []), ('static_state', []), ('goal_state', []), ('abstraction_levels', [Number(1), Function('hierarchical', [], True)]), ('instance_module', []), ('goal_abstraction_module', []), ('domain_sorts', []), ('variable_relations', [Number(0)]), ('abstraction_mappings', [Number(0)])]

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Grounding completed in 0.040099s.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Solving program.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Model found:
Model :: Total atoms = 2599, Cost = (), Optimality proven = False, Number = 1, Thread ID = 5, Model type = ModelType.StableModel

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Solving completed in 0.005488s with result Satisfiable.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Freeing held grounding...

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Setting input storing variables:
	solver_options = []
	assumptions = []
	context = None
	incrementor = None
	base_parts = []
	inc_parts = []

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Held grounding freed.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 || Generate Final Goals #1 >> Returning from standard solve call:
Result :: SATISFIABLE : SEARCH EXHAUSTED : Total models = 1
Statistics :: Grounding = 0.040099s, Solving = 0.005488s, Total = 0.045587s, Memory = (RSS = 53, VMS = 50)
Final Model :: Total atoms = 2599, Cost = (), Optimality proven = False, Number = 1, Thread ID = 5, Model type = ModelType.StableModel

[09-09-2021_16-35-07] DEBUG :: ASH Planner Main #1 >> Final goals generated successfully:
Result :: SATISFIABLE : SEARCH EXHAUSTED
Statistics :: Grounding = 0.040099s, Solving = 0.005488s, Total = 0.045587s, Memory = (RSS = 53, VMS = 50)
Model :: Total atoms = 2599, Cost = (), Optimality proven = False, Number = 1, Thread ID = 5, Model type = ModelType.StableModel

[09-09-2021_16-35-07] DEBUG :: ASH Planner Main #1 >> The given partial final goal has a unique complete interpretation (only one stable model exists).

[09-09-2021_16-35-07] DEBUG :: ASH Planner Main #1 >> 

          ========================================          
             Final goal at abstraction level 3              
          ========================================          

final_goal(3, complete(blue), false, false)
final_goal(3, complete(blue), true, true)
final_goal(3, complete(red), false, false)
final_goal(3, complete(red), true, true)
final_goal(3, on((block,3)), (block,1), false)
final_goal(3, on((block,3)), (block,2), false)
final_goal(3, on((block,3)), (block,4), false)
final_goal(3, on((block,3)), (block,5), false)
final_goal(3, on((block,3)), (block,6), false)
final_goal(3, on((block,3)), nothing, false)
final_goal(3, on((block,3)), puzzle_room_table, true)
final_goal(3, on((block,6)), (block,1), false)
final_goal(3, on((block,6)), (block,2), false)
final_goal(3, on((block,6)), (block,3), false)
final_goal(3, on((block,6)), (block,4), false)
final_goal(3, on((block,6)), (block,5), false)
final_goal(3, on((block,6)), nothing, false)
final_goal(3, on((block,6)), puzzle_room_table, true)

[09-09-2021_16-35-07] DEBUG :: ASH Planner Main #1 >> 

          ========================================          
             Final goal at abstraction level 2              
          ========================================          

final_goal(2, complete(blue), false, false)
final_goal(2, complete(blue), true, true)
final_goal(2, complete(red), false, false)
final_goal(2, complete(red), true, true)
final_goal(2, on((block,3)), (block,1), false)
final_goal(2, on((block,3)), (block,2), false)
final_goal(2, on((block,3)), (block,4), false)
final_goal(2, on((block,3)), (block,5), false)
final_goal(2, on((block,3)), (block,6), false)
final_goal(2, on((block,3)), nothing, false)
final_goal(2, on((block,3)), puzzle_room_table, true)
final_goal(2, on((block,6)), (block,1), false)
final_goal(2, on((block,6)), (block,2), false)
final_goal(2, on((block,6)), (block,3), false)
final_goal(2, on((block,6)), (block,4), false)
final_goal(2, on((block,6)), (block,5), false)
final_goal(2, on((block,6)), nothing, false)
final_goal(2, on((block,6)), puzzle_room_table, true)

[09-09-2021_16-35-07] DEBUG :: ASH Planner Main #1 >> 

          ========================================          
             Final goal at abstraction level 1              
          ========================================          

final_goal(1, complete(blue), false, false)
final_goal(1, complete(blue), true, true)
final_goal(1, complete(red), false, false)
final_goal(1, complete(red), true, true)
final_goal(1, on((block,3)), (block,1), false)
final_goal(1, on((block,3)), (block,2), false)
final_goal(1, on((block,3)), (block,4), false)
final_goal(1, on((block,3)), (block,5), false)
final_goal(1, on((block,3)), (block,6), false)
final_goal(1, on((block,3)), nothing, false)
final_goal(1, on((block,3)), puzzle_room_table_left, true)
final_goal(1, on((block,3)), puzzle_room_table_right, false)
final_goal(1, on((block,6)), (block,1), false)
final_goal(1, on((block,6)), (block,2), false)
final_goal(1, on((block,6)), (block,3), false)
final_goal(1, on((block,6)), (block,4), false)
final_goal(1, on((block,6)), (block,5), false)
final_goal(1, on((block,6)), nothing, false)
final_goal(1, on((block,6)), puzzle_room_table_left, false)
final_goal(1, on((block,6)), puzzle_room_table_right, true)

[09-09-2021_16-35-07] DEBUG :: ASH Planner Main #1 >> Hierarchical planning problem successfully initialised:
Initial State is UNIQUE, Final-Goal is UNIQUE

[09-09-2021_16-35-07] INFO :: ASH Planner Main #1 >> Generating hierarchical plan : LEVELS [1-3] : ONLINE MODE

[09-09-2021_16-35-07] DEBUG :: ASH Planner Main #1 >> Arguments:
	('bottom_level', 1)
	('top_level', None)
	('conformance', True)
	('concurrency', False)
	('save_grounding', False)
	('sequential_yield', False)
	('division_strategy', <core.Strategies.Basic object at 0x000001762DCFBEA0>)
	('online_method', <OnlineMethod.GroundFirst: 'ground-first'>)
	('pause_on_level_change', True)
	('pause_on_increment_change', False)
	('conformance_type', <ConformanceType.SequentialAchievement: 'sequential'>)
	('use_minimum_search_length_bound', None)
	('avoid_refining_sgoals_marked_for_blending', True)
	('detect_interleaving', False)
	('detect_dependencies', False)
	('preempt_pos_fgoals', None)
	('preempt_neg_fgoals', None)
	('order_fgoals_achievement', None)
	('minimise_length', None)
	('minimise_actions', None)
	('minimise_cost', None)
	('time_limit', 3600)
	('length_limit', 100)
	('level_range', range(1, 4))
	('online', True)
	('self', HierarchicalPlanner(PlanningDomain(['./test_problems/blocks_world_plus/BWP_system_laws.lp', './test_problems/blocks_world_plus/BWP_problem_small_3.lp'], Anon #1), Main #1, 6, Verbosity.Simple, True))

[09-09-2021_16-35-07] DEBUG :: ASH Planner Main #1 >> Current refinement diagram progress:
Level 3 : Total sgoals 0 : Achieved sgoals 0 : Unachieved sgoals 0
Level 2 : Total sgoals 0 : Achieved sgoals 0 : Unachieved sgoals 0
Level 1 : Total sgoals 0 : Achieved sgoals 0 : Unachieved sgoals 0

[09-09-2021_16-35-07] DEBUG :: ASH Planner Main #1 >> Current planning increment level range: [1-3]

[09-09-2021_16-35-07] DEBUG :: ASH Planner Main #1 >> Starting top-level classical planning: level = 3

[09-09-2021_16-35-07] DEBUG :: ASH Planner Main #1 >> Starting monolevel planning:
	('conformance', False)
	('conformance_type', <ConformanceType.SequentialAchievement: 'sequential'>)
	('first_sgoals', None)
	('last_sgoals', None)
	('sequential_yield', False)
	('concurrency', False)
	('reactive_callback', <bound method DivisionStrategy.react of <core.Strategies.Basic object at 0x000001762DCFBEA0>>)
	('save_grounding', False)
	('use_saved_grounding', False)
	('use_minimum_search_length_bound', None)
	('detect_interleaving', False)
	('generate_search_space', False)
	('generate_solution_space', False)
	('preempt_pos_fgoals', None)
	('preempt_neg_fgoals', None)
	('order_fgoals_achievement', None)
	('minimise_cost', None)
	('time_limit', 3600)
	('length_limit', 100)
	('make_observable', False)
	('pause_on_yield', False)
	('level', 3)
	('minimise_actions', None)
	('minimise_length', None)
	('self', HierarchicalPlanner(PlanningDomain(['./test_problems/blocks_world_plus/BWP_system_laws.lp', './test_problems/blocks_world_plus/BWP_problem_small_3.lp'], Anon #1), Main #1, 6, Verbosity.Simple, True))

[09-09-2021_16-35-07] DEBUG :: ASH Planner Main #1 >> Problem type obtained: start step = 0, initial = True, final = True, sgoals = [1-0]

[09-09-2021_16-35-07] DEBUG :: ASH Planner Main #1 >> Minimum search length bound: enabled = None, value = 0

[09-09-2021_16-35-07] DEBUG :: ASH Planner Main #1 >> Generating monolevel plan : Level 3
Planning mode = classical 
Problem type = complete
Concurrency = disabled

[09-09-2021_16-35-07] DEBUG :: ASH Planner Main #1 >> Optimisation details:Length minimisation = None
Action minimisation = False
Cost minimisation = False
Positive final goal preemptive achievement = False
Negative final goal preemptive achievement = False
Final goal intermediate achievement ordering preferences = False

[09-09-2021_16-35-07] DEBUG :: Logic Program ASH #1 >> Creating copy of self: rename = Main #1 :: Generate monolevel plan

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Instantiating logic program...

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Setting input storing variables:
	solver_options = []
	assumptions = []
	context = None
	incrementor = None
	base_parts = []
	inc_parts = []

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Output storing variables reset.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Logic program instantiated.

[09-09-2021_16-35-07] DEBUG :: ASH Planner Main #1 >> Adding start state as initial state...

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> The logic program was extended with 68 rules into program part ash_initial_state.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> The logic program was extended with 18 rules into program part ash_goal_state.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Starting new incremental solve call.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Setting input storing variables:
	solver_options = ['--heuristic=Domain', '--stats', '--parallel-mode=6,compete', '--warn=none', '--opt-mode=ignore']
	assumptions = []
	context = None
	incrementor = SolveIncrementor(step_start=0, step_increase=1, step_increase_initial=2, step_end_min=None, step_end_max=100, stop_condition=<SolveResult.Satisfiable: 'SAT'>, increment_limit=None, increment_time_limit=None, cumulative_time_limit=3600, preempt=False)
	base_parts = [BasePart(name='base', args=()), BasePart(name='abstraction_levels', args=(3, 'classical')), BasePart(name='entities', args=()), BasePart(name='domain_sorts', args=()), BasePart(name='instance_module', args=()), BasePart(name='static_state', args=()), BasePart(name='ash_initial_state', args=()), BasePart(name='ash_goal_state', args=())]
	inc_parts = [IncPart(name='action_effects', args=('#inc',), range_=None), IncPart(name='action_preconditions', args=('#inc',), range_=None), IncPart(name='variable_relations', args=('#inc',), range_=None), IncPart(name='abstraction_mappings', args=('#inc',), range_=None), IncPart(name='state_module', args=('#inc', 0), range_=None), IncPart(name='plan_module', args=('#inc', 0, 'false', 'true'), range_=None), IncPart(name='optimisation_module', args=('#inc', 0, 'none', 'false', 'false', 'false', 'false', 'false'), range_=None)]

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Output storing variables reset.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Program building started :: Processing 426 rules

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Program building completed in 0.0033994999999999997s

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Running one-shot ground and solve of program parts:
[BasePart(name='base', args=()), BasePart(name='abstraction_levels', args=(3, 'classical')), BasePart(name='entities', args=()), BasePart(name='domain_sorts', args=()), BasePart(name='instance_module', args=()), BasePart(name='static_state', args=()), BasePart(name='ash_initial_state', args=()), BasePart(name='ash_goal_state', args=())]

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('base', []), ('abstraction_levels', [Number(3), Function('classical', [], True)]), ('entities', []), ('domain_sorts', []), ('instance_module', []), ('static_state', []), ('ash_initial_state', []), ('ash_goal_state', [])]

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.020311s.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Model found:
Model :: Total atoms = 1636, Cost = (), Optimality proven = False, Number = 1, Thread ID = 0, Model type = ModelType.StableModel

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.003010s with result Satisfiable.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Creating solve signal...

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solve signal created:
<ASP_Parser.SolveSignal object at 0x000001762DD19F40>

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Running incremental ground and solve of program parts:
#program action_effects(#inc). %* None *%
#program action_preconditions(#inc). %* None *%
#program variable_relations(#inc). %* None *%
#program abstraction_mappings(#inc). %* None *%
#program state_module(#inc, 0). %* None *%
#program plan_module(#inc, 0, false, true). %* None *%
#program optimisation_module(#inc, 0, none, false, false, false, false, false). %* None *%

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [1]:
Running step bounds   | Previous =     -1 : Current =      1
Incrementor step ends | Minimum  =   None : Maximum =    100

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(1)]), ('action_effects', [Number(0)]), ('action_preconditions', [Number(0)]), ('variable_relations', [Number(0)]), ('abstraction_mappings', [Number(0)]), ('state_module', [Number(0), Number(0)]), ('plan_module', [Number(0), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(0), Number(0), Function('none', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)]), ('action_effects', [Number(1)]), ('action_preconditions', [Number(1)]), ('variable_relations', [Number(1)]), ('abstraction_mappings', [Number(1)]), ('state_module', [Number(1), Number(0)]), ('plan_module', [Number(1), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(1), Number(0), Function('none', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.056191s.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.004541s with result Unsatisfiable.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [1]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.06073229999999996, Incremental time limit = None
Running cumulative time = 0.06073229999999996, Cumulative time limit = 3600
(RSS = 56, VMS = 51)

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [2]:
Running step bounds   | Previous =      1 : Current =      2
Incrementor step ends | Minimum  =   None : Maximum =    100

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(2)]), ('action_effects', [Number(2)]), ('action_preconditions', [Number(2)]), ('variable_relations', [Number(2)]), ('abstraction_mappings', [Number(2)]), ('state_module', [Number(2), Number(0)]), ('plan_module', [Number(2), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(2), Number(0), Function('none', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.046859s.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.002359s with result Unsatisfiable.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [2]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.049217899999999926, Incremental time limit = None
Running cumulative time = 0.10995019999999989, Cumulative time limit = 3600
(RSS = 57, VMS = 52)

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [3]:
Running step bounds   | Previous =      2 : Current =      3
Incrementor step ends | Minimum  =   None : Maximum =    100

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(3)]), ('action_effects', [Number(3)]), ('action_preconditions', [Number(3)]), ('variable_relations', [Number(3)]), ('abstraction_mappings', [Number(3)]), ('state_module', [Number(3), Number(0)]), ('plan_module', [Number(3), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(3), Number(0), Function('none', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.047972s.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.004379s with result Unsatisfiable.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [3]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.052351000000000036, Incremental time limit = None
Running cumulative time = 0.16230119999999992, Cumulative time limit = 3600
(RSS = 58, VMS = 54)

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [4]:
Running step bounds   | Previous =      3 : Current =      4
Incrementor step ends | Minimum  =   None : Maximum =    100

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(4)]), ('action_effects', [Number(4)]), ('action_preconditions', [Number(4)]), ('variable_relations', [Number(4)]), ('abstraction_mappings', [Number(4)]), ('state_module', [Number(4), Number(0)]), ('plan_module', [Number(4), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(4), Number(0), Function('none', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.050210s.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.005170s with result Unsatisfiable.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [4]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.05537969999999981, Incremental time limit = None
Running cumulative time = 0.21768089999999973, Cumulative time limit = 3600
(RSS = 60, VMS = 55)

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [5]:
Running step bounds   | Previous =      4 : Current =      5
Incrementor step ends | Minimum  =   None : Maximum =    100

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(5)]), ('action_effects', [Number(5)]), ('action_preconditions', [Number(5)]), ('variable_relations', [Number(5)]), ('abstraction_mappings', [Number(5)]), ('state_module', [Number(5), Number(0)]), ('plan_module', [Number(5), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(5), Number(0), Function('none', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.050317s.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.005670s with result Unsatisfiable.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [5]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.055987099999999845, Incremental time limit = None
Running cumulative time = 0.2736679999999996, Cumulative time limit = 3600
(RSS = 62, VMS = 57)

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [6]:
Running step bounds   | Previous =      5 : Current =      6
Incrementor step ends | Minimum  =   None : Maximum =    100

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(6)]), ('action_effects', [Number(6)]), ('action_preconditions', [Number(6)]), ('variable_relations', [Number(6)]), ('abstraction_mappings', [Number(6)]), ('state_module', [Number(6), Number(0)]), ('plan_module', [Number(6), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(6), Number(0), Function('none', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.051717s.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.005784s with result Unsatisfiable.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [6]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.057501500000000094, Incremental time limit = None
Running cumulative time = 0.3311694999999997, Cumulative time limit = 3600
(RSS = 65, VMS = 61)

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [7]:
Running step bounds   | Previous =      6 : Current =      7
Incrementor step ends | Minimum  =   None : Maximum =    100

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(7)]), ('action_effects', [Number(7)]), ('action_preconditions', [Number(7)]), ('variable_relations', [Number(7)]), ('abstraction_mappings', [Number(7)]), ('state_module', [Number(7), Number(0)]), ('plan_module', [Number(7), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(7), Number(0), Function('none', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.052277s.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.006501s with result Unsatisfiable.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [7]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.05877740000000009, Incremental time limit = None
Running cumulative time = 0.38994689999999976, Cumulative time limit = 3600
(RSS = 67, VMS = 63)

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [8]:
Running step bounds   | Previous =      7 : Current =      8
Incrementor step ends | Minimum  =   None : Maximum =    100

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(8)]), ('action_effects', [Number(8)]), ('action_preconditions', [Number(8)]), ('variable_relations', [Number(8)]), ('abstraction_mappings', [Number(8)]), ('state_module', [Number(8), Number(0)]), ('plan_module', [Number(8), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(8), Number(0), Function('none', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.052972s.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.006491s with result Unsatisfiable.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [8]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.059463299999999775, Incremental time limit = None
Running cumulative time = 0.44941019999999954, Cumulative time limit = 3600
(RSS = 69, VMS = 65)

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [9]:
Running step bounds   | Previous =      8 : Current =      9
Incrementor step ends | Minimum  =   None : Maximum =    100

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(9)]), ('action_effects', [Number(9)]), ('action_preconditions', [Number(9)]), ('variable_relations', [Number(9)]), ('abstraction_mappings', [Number(9)]), ('state_module', [Number(9), Number(0)]), ('plan_module', [Number(9), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(9), Number(0), Function('none', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.054816s.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.008465s with result Unsatisfiable.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [9]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.06328069999999997, Incremental time limit = None
Running cumulative time = 0.5126908999999995, Cumulative time limit = 3600
(RSS = 72, VMS = 68)

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [10]:
Running step bounds   | Previous =      9 : Current =     10
Incrementor step ends | Minimum  =   None : Maximum =    100

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(10)]), ('action_effects', [Number(10)]), ('action_preconditions', [Number(10)]), ('variable_relations', [Number(10)]), ('abstraction_mappings', [Number(10)]), ('state_module', [Number(10), Number(0)]), ('plan_module', [Number(10), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(10), Number(0), Function('none', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.056390s.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.008448s with result Unsatisfiable.

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [10]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.0648377, Incremental time limit = None
Running cumulative time = 0.5775285999999995, Cumulative time limit = 3600
(RSS = 74, VMS = 70)

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [11]:
Running step bounds   | Previous =     10 : Current =     11
Incrementor step ends | Minimum  =   None : Maximum =    100

[09-09-2021_16-35-07] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(11)]), ('action_effects', [Number(11)]), ('action_preconditions', [Number(11)]), ('variable_relations', [Number(11)]), ('abstraction_mappings', [Number(11)]), ('state_module', [Number(11), Number(0)]), ('plan_module', [Number(11), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(11), Number(0), Function('none', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.054671s.

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.012501s with result Unsatisfiable.

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [11]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.06717230000000018, Incremental time limit = None
Running cumulative time = 0.6447008999999997, Cumulative time limit = 3600
(RSS = 76, VMS = 71)

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [12]:
Running step bounds   | Previous =     11 : Current =     12
Incrementor step ends | Minimum  =   None : Maximum =    100

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(12)]), ('action_effects', [Number(12)]), ('action_preconditions', [Number(12)]), ('variable_relations', [Number(12)]), ('abstraction_mappings', [Number(12)]), ('state_module', [Number(12), Number(0)]), ('plan_module', [Number(12), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(12), Number(0), Function('none', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.055878s.

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.017179s with result Unsatisfiable.

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [12]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.07305720000000004, Incremental time limit = None
Running cumulative time = 0.7177580999999997, Cumulative time limit = 3600
(RSS = 78, VMS = 73)

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [13]:
Running step bounds   | Previous =     12 : Current =     13
Incrementor step ends | Minimum  =   None : Maximum =    100

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(13)]), ('action_effects', [Number(13)]), ('action_preconditions', [Number(13)]), ('variable_relations', [Number(13)]), ('abstraction_mappings', [Number(13)]), ('state_module', [Number(13), Number(0)]), ('plan_module', [Number(13), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(13), Number(0), Function('none', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.056373s.

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.019959s with result Unsatisfiable.

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [13]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.07633120000000027, Incremental time limit = None
Running cumulative time = 0.7940893, Cumulative time limit = 3600
(RSS = 82, VMS = 79)

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [14]:
Running step bounds   | Previous =     13 : Current =     14
Incrementor step ends | Minimum  =   None : Maximum =    100

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(14)]), ('action_effects', [Number(14)]), ('action_preconditions', [Number(14)]), ('variable_relations', [Number(14)]), ('abstraction_mappings', [Number(14)]), ('state_module', [Number(14), Number(0)]), ('plan_module', [Number(14), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(14), Number(0), Function('none', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.057393s.

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.024428s with result Unsatisfiable.

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [14]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.08182109999999998, Incremental time limit = None
Running cumulative time = 0.8759104, Cumulative time limit = 3600
(RSS = 84, VMS = 80)

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [15]:
Running step bounds   | Previous =     14 : Current =     15
Incrementor step ends | Minimum  =   None : Maximum =    100

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(15)]), ('action_effects', [Number(15)]), ('action_preconditions', [Number(15)]), ('variable_relations', [Number(15)]), ('abstraction_mappings', [Number(15)]), ('state_module', [Number(15), Number(0)]), ('plan_module', [Number(15), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(15), Number(0), Function('none', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.059806s.

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.038096s with result Unsatisfiable.

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [15]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.09790269999999968, Incremental time limit = None
Running cumulative time = 0.9738130999999997, Cumulative time limit = 3600
(RSS = 87, VMS = 83)

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [16]:
Running step bounds   | Previous =     15 : Current =     16
Incrementor step ends | Minimum  =   None : Maximum =    100

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(16)]), ('action_effects', [Number(16)]), ('action_preconditions', [Number(16)]), ('variable_relations', [Number(16)]), ('abstraction_mappings', [Number(16)]), ('state_module', [Number(16), Number(0)]), ('plan_module', [Number(16), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(16), Number(0), Function('none', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.060028s.

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.073202s with result Unsatisfiable.

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [16]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.13323039999999997, Incremental time limit = None
Running cumulative time = 1.1070434999999996, Cumulative time limit = 3600
(RSS = 88, VMS = 84)

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [17]:
Running step bounds   | Previous =     16 : Current =     17
Incrementor step ends | Minimum  =   None : Maximum =    100

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(17)]), ('action_effects', [Number(17)]), ('action_preconditions', [Number(17)]), ('variable_relations', [Number(17)]), ('abstraction_mappings', [Number(17)]), ('state_module', [Number(17), Number(0)]), ('plan_module', [Number(17), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(17), Number(0), Function('none', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.062324s.

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.111529s with result Unsatisfiable.

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [17]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.17385260000000002, Incremental time limit = None
Running cumulative time = 1.2808960999999996, Cumulative time limit = 3600
(RSS = 92, VMS = 88)

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [18]:
Running step bounds   | Previous =     17 : Current =     18
Incrementor step ends | Minimum  =   None : Maximum =    100

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(18)]), ('action_effects', [Number(18)]), ('action_preconditions', [Number(18)]), ('variable_relations', [Number(18)]), ('abstraction_mappings', [Number(18)]), ('state_module', [Number(18), Number(0)]), ('plan_module', [Number(18), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(18), Number(0), Function('none', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.060748s.

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.158639s with result Unsatisfiable.

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [18]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.21938650000000015, Incremental time limit = None
Running cumulative time = 1.5002825999999998, Cumulative time limit = 3600
(RSS = 97, VMS = 95)

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [19]:
Running step bounds   | Previous =     18 : Current =     19
Incrementor step ends | Minimum  =   None : Maximum =    100

[09-09-2021_16-35-08] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(19)]), ('action_effects', [Number(19)]), ('action_preconditions', [Number(19)]), ('variable_relations', [Number(19)]), ('abstraction_mappings', [Number(19)]), ('state_module', [Number(19), Number(0)]), ('plan_module', [Number(19), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(19), Number(0), Function('none', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[09-09-2021_16-35-09] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.061172s.

[09-09-2021_16-35-09] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[09-09-2021_16-35-09] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.273060s with result Unsatisfiable.

[09-09-2021_16-35-09] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [19]:
Result = SolveResult.Unsatisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.33423259999999955, Incremental time limit = None
Running cumulative time = 1.8345151999999993, Cumulative time limit = 3600
(RSS = 102, VMS = 99)

[09-09-2021_16-35-09] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Beginning incremental call [20]:
Running step bounds   | Previous =     19 : Current =     20
Incrementor step ends | Minimum  =   None : Maximum =    100

[09-09-2021_16-35-09] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding program parts:
[('check', [Number(20)]), ('action_effects', [Number(20)]), ('action_preconditions', [Number(20)]), ('variable_relations', [Number(20)]), ('abstraction_mappings', [Number(20)]), ('state_module', [Number(20), Number(0)]), ('plan_module', [Number(20), Number(0), Function('false', [], True), Function('true', [], True)]), ('optimisation_module', [Number(20), Number(0), Function('none', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True), Function('false', [], True)])]

[09-09-2021_16-35-09] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Grounding completed in 0.061059s.

[09-09-2021_16-35-09] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving program.

[09-09-2021_16-35-09] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Model found:
Model :: Total atoms = 9341, Cost = (), Optimality proven = False, Number = 1, Thread ID = 1, Model type = ModelType.StableModel

[09-09-2021_16-35-09] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Solving completed in 0.041674s with result Satisfiable.

[09-09-2021_16-35-09] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Completed incremental call [20]:
Result = SolveResult.Satisfiable, Stop condition = SolveResult.Satisfiable
Increment time = 0.10273310000000002, Incremental time limit = None
Running cumulative time = 1.9372482999999994, Cumulative time limit = 3600
(RSS = 106, VMS = 104)

[09-09-2021_16-35-09] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Incremental solving has found a model, current answer:
Result :: SATISFIABLE : SEARCH INTERRUPTED : Total models = 2
IncrementalStatistics :: Cumulative = (Statistics :: Grounding = 1.109172s, Solving = 0.828076s, Total = 1.937248s, Memory = (RSS = 0.0, VMS = 0.0)), Calls = 20
Final Model :: Total atoms = 9341, Cost = (), Optimality proven = False, Number = 1, Thread ID = 1, Model type = ModelType.StableModel

[09-09-2021_16-35-09] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Incremental statistics:
1 : Statistics :: Grounding = 0.056191s, Solving = 0.004541s, Total = 0.060732s, Memory = (RSS = 56, VMS = 51)
2 : Statistics :: Grounding = 0.046859s, Solving = 0.002359s, Total = 0.049218s, Memory = (RSS = 57, VMS = 52)
3 : Statistics :: Grounding = 0.047972s, Solving = 0.004379s, Total = 0.052351s, Memory = (RSS = 58, VMS = 54)
4 : Statistics :: Grounding = 0.050210s, Solving = 0.005170s, Total = 0.055380s, Memory = (RSS = 60, VMS = 55)
5 : Statistics :: Grounding = 0.050317s, Solving = 0.005670s, Total = 0.055987s, Memory = (RSS = 62, VMS = 57)
6 : Statistics :: Grounding = 0.051717s, Solving = 0.005784s, Total = 0.057502s, Memory = (RSS = 65, VMS = 61)
7 : Statistics :: Grounding = 0.052277s, Solving = 0.006501s, Total = 0.058777s, Memory = (RSS = 67, VMS = 63)
8 : Statistics :: Grounding = 0.052972s, Solving = 0.006491s, Total = 0.059463s, Memory = (RSS = 69, VMS = 65)
9 : Statistics :: Grounding = 0.054816s, Solving = 0.008465s, Total = 0.063281s, Memory = (RSS = 72, VMS = 68)
10 : Statistics :: Grounding = 0.056390s, Solving = 0.008448s, Total = 0.064838s, Memory = (RSS = 74, VMS = 70)
11 : Statistics :: Grounding = 0.054671s, Solving = 0.012501s, Total = 0.067172s, Memory = (RSS = 76, VMS = 71)
12 : Statistics :: Grounding = 0.055878s, Solving = 0.017179s, Total = 0.073057s, Memory = (RSS = 78, VMS = 73)
13 : Statistics :: Grounding = 0.056373s, Solving = 0.019959s, Total = 0.076331s, Memory = (RSS = 82, VMS = 79)
14 : Statistics :: Grounding = 0.057393s, Solving = 0.024428s, Total = 0.081821s, Memory = (RSS = 84, VMS = 80)
15 : Statistics :: Grounding = 0.059806s, Solving = 0.038096s, Total = 0.097903s, Memory = (RSS = 87, VMS = 83)
16 : Statistics :: Grounding = 0.060028s, Solving = 0.073202s, Total = 0.133230s, Memory = (RSS = 88, VMS = 84)
17 : Statistics :: Grounding = 0.062324s, Solving = 0.111529s, Total = 0.173853s, Memory = (RSS = 92, VMS = 88)
18 : Statistics :: Grounding = 0.060748s, Solving = 0.158639s, Total = 0.219387s, Memory = (RSS = 97, VMS = 95)
19 : Statistics :: Grounding = 0.061172s, Solving = 0.273060s, Total = 0.334233s, Memory = (RSS = 102, VMS = 99)
20 : Statistics :: Grounding = 0.061059s, Solving = 0.041674s, Total = 0.102733s, Memory = (RSS = 106, VMS = 104)

[09-09-2021_16-35-09] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Incremental ground and solve completed in 1.937248s because Stop condition reached.

[09-09-2021_16-35-09] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Stopping incremental solve call.

[09-09-2021_16-35-09] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Freeing held grounding...

[09-09-2021_16-35-09] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Setting input storing variables:
	solver_options = []
	assumptions = []
	context = None
	incrementor = None
	base_parts = []
	inc_parts = []

[09-09-2021_16-35-09] DEBUG :: Logic Program Main #1 :: Generate monolevel plan #1 >> Held grounding freed.

[09-09-2021_16-35-09] DEBUG :: ASH Planner Main #1 >> Search finished as expected, the requested partial problem has been solved entirely.

[09-09-2021_16-35-09] DEBUG :: ASH Planner Main #1 >> Monolevel plan generated successfully:
Result :: SATISFIABLE : SEARCH INTERRUPTED : COMPLETE PLAN OBTAINED
IncrementalStatistics :: Cumulative = (Statistics :: Grounding = 1.109172s, Solving = 0.828076s, Total = 1.937248s, Memory = (RSS = 0.0, VMS = 0.0)), Calls = 20
Model :: Total atoms = 9341, Cost = (), Optimality proven = False, Number = 1, Thread ID = 1, Model type = ModelType.StableModel

[09-09-2021_16-35-09] DEBUG :: ASH Planner Main #1 >> 

          ========================================          
                Plan at abstraction level 3                 
          ========================================          
                 Steps = 20 :: Actions = 20                 
                ----------------------------                

(1, [{'L': 3, 'R': 'talos', 'A': 'move(store_room)', 'S': 1}])
(2, [{'L': 3, 'R': 'talos', 'A': 'grasp(manipulator_arm_1,(block,6))', 'S': 2}])
(3, [{'L': 3, 'R': 'talos', 'A': 'move(puzzle_room)', 'S': 3}])
(4, [{'L': 3, 'R': 'talos', 'A': 'grasp(manipulator_arm_2,(block,3))', 'S': 4}])
(5, [{'L': 3, 'R': 'talos', 'A': 'put(manipulator_arm_2,(block,3),puzzle_room_table)', 'S': 5}])
(6, [{'L': 3, 'R': 'talos', 'A': 'release(manipulator_arm_2,(block,3))', 'S': 6}])
(7, [{'L': 3, 'R': 'talos', 'A': 'grasp(manipulator_arm_2,(block,2))', 'S': 7}])
(8, [{'L': 3, 'R': 'talos', 'A': 'put(manipulator_arm_1,(block,6),puzzle_room_table)', 'S': 8}])
(9, [{'L': 3, 'R': 'talos', 'A': 'put(manipulator_arm_2,(block,2),(block,3))', 'S': 9}])
(10, [{'L': 3, 'R': 'talos', 'A': 'release(manipulator_arm_2,(block,2))', 'S': 10}])
(11, [{'L': 3, 'R': 'talos', 'A': 'release(manipulator_arm_1,(block,6))', 'S': 11}])
(12, [{'L': 3, 'R': 'talos', 'A': 'move(store_room)', 'S': 12}])
(13, [{'L': 3, 'R': 'talos', 'A': 'grasp(manipulator_arm_1,(block,5))', 'S': 13}])
(14, [{'L': 3, 'R': 'talos', 'A': 'grasp(manipulator_arm_2,(block,4))', 'S': 14}])
(15, [{'L': 3, 'R': 'talos', 'A': 'move(puzzle_room)', 'S': 15}])
(16, [{'L': 3, 'R': 'talos', 'A': 'put(manipulator_arm_1,(block,5),(block,6))', 'S': 16}])
(17, [{'L': 3, 'R': 'talos', 'A': 'release(manipulator_arm_1,(block,5))', 'S': 17}])
(18, [{'L': 3, 'R': 'talos', 'A': 'put(manipulator_arm_2,(block,4),(block,5))', 'S': 18}])
(19, [{'L': 3, 'R': 'talos', 'A': 'grasp(manipulator_arm_1,(block,1))', 'S': 19}])
(20, [{'L': 3, 'R': 'talos', 'A': 'put(manipulator_arm_1,(block,1),(block,2))', 'S': 20}])

[09-09-2021_16-35-09] DEBUG :: ASH Planner Main #1 >> Extracting monolevel plan: level=3, start_step=0, plan_length=20, step_range=range(0, 21)

[09-09-2021_16-35-09] DEBUG :: ASH Planner Main #1 >> Current plan lengths: level=1 len(self.__actions.get(level, []))=0 : level=2 len(self.__actions.get(level, []))=0 : level=3 len(self.__actions.get(level, []))=20

[09-09-2021_16-35-09] DEBUG :: ASH Planner Main #1 >> Dividing abstract plan:
Level = 3, Length = 20, Actions = 20, Time = 1.94s (Grounding = 1.11s, Search = 0.83s), Expansion = 1.00, Deviation = 0.00, Balance = 0.00

[09-09-2021_16-35-09] DEBUG :: core.Strategies >> Making homogenous divisions: partial_problems=2, plan_length=20, start_step=0, blend=Blend(left=0, right=0)

[09-09-2021_16-35-09] DEBUG :: core.Strategies >> Decided: number_small_problems=2, number_large_problems=0, small_group_size=10, large_group_size=11

[09-09-2021_16-35-09] DEBUG :: core.Strategies >> Division points generated:
[DivisionPoint(index=10, blend=Blend(left=0, right=0))]

[09-09-2021_16-35-09] DEBUG :: ASH Planner Main #1 >> Division scenario generated:
Divided plan : Level = 3, Length = 20, Actions = 20, Time = 1.94s (Grounding = 1.11s, Search = 0.83s), Expansion = 1.00, Deviation = 0.00, Balance = 0.00
Division points [total=1] : [(Index = 10, Blend = (Left = 0, Right = 0))]

[09-09-2021_16-35-39] ERROR :: __main__ >> Exception during main:

Traceback (most recent call last):
  File "D:\ASH\Launch.py", line 622, in <module>
    exit_code = __main()
  File "D:\ASH\Launch.py", line 272, in __main
    planner.hierarchical_plan(bottom_level=namespace.bottom_level,
  File "D:\ASH\core\Planner.py", line 1913, in hierarchical_plan
    input(f"Planning paused before downwards level change :: Current range [{max(current_level_range)}-{min(current_level_range)}] :: Progression [{planning_level_tracking_progress_bar.n}/{len(current_level_range)}]")
KeyboardInterrupt
[09-09-2021_16-35-39] INFO :: __main__ >> Overall time: Real = 33.506484, Process = 5.453125

[09-09-2021_16-35-39] INFO :: __main__ >> Exiting with code -1

